<!--
Google IO 2012 HTML5 Slide Template

Authors: Eric Bidelman <ebidel@gmail.com>
         Luke Mahe <lukem@google.com>

URL: https://code.google.com/p/io-2012-slides
-->
<!DOCTYPE html>
<html>
<head>
  <title>Linguaggio C++11</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="stylesheet" media="all" href="theme/css/default.css">
  <link rel="stylesheet" media="all" href="theme/css/tomamic.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="theme/css/phone.css">
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
  <script data-main="js/slides" src="js/require-1.0.8.min.js"></script>
</head>
<body style="opacity: 0">

<slides class="layout-widescreen">

<slide class="title-slide segue nobackground">
  <aside class="gdbar"><img src="images/logo.png"></aside>
  <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
  <h1 data-config-title><!-- populated from slide_config.json --></h1>
  <figure><img src="images/misc/cpp-logo.jpg"></figure>
  <hgroup>
    <h2>Ereditarietà</h2>
    <p>Michele Tomaiuolo<br>Ingegneria dell'Informazione, UniPR</p>
  </hgroup>
</slide>


<slide  >
  
    <hgroup>
      <h2>title: Ereditarietà</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Una nuova classe (classe derivata) viene creata a partire da una classe esistente (classe base)</li>
<li>La classe derivata eredita le variabili membro e le funzioni membro della classe base</li>
<li>Eredita interfaccia e implementazione</li>
<li>Può aggiungere variabili membro e funzioni membro</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Relazione “is a”</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Un oggetto di una classe derivata può essere usato ovunque può essere usato uno della classe base</li>
<li>Un oggetto di una classe derivata ha più di un tipo<ul>
<li>class HourlyEmployee : public Employee {</li>
<li>public:</li>
<li>HourlyEmployee(string name, string code,</li>
<li>double wageRate, double hours);</li>
<li>// …</li>
<li>private:</li>
<li>// …</li>
<li>};</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Ridefinizione dei metodi</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Una classe derivata può cambiare la definizione di una funzione membro ereditata (overriding)</li>
<li>In questo caso la definizione della classe derivata deve contenere la dichiarazione della funzione membro ereditata</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Accesso a un metodo della classe base</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Una classe derivata può ridefinire una funzione della classe base
    È comunque possibile invocare su un oggetto della classe derivata la versione della funzione data nella classe base</li>
<li>Per fare ciò si utilizza l’operatore ::, che in questo caso è obbligatorio, altrimenti la funzione chiamante continuerebbe in realtà a chiamare se stessa generando un loop</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Overriding / overloading</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Overriding<ul>
<li>Una funzione ridefinita in una classe derivata ha lo stesso numero e tipo di parametri della funzione della classe base</li>
<li>Sostituisce la funzione della classe base</li>
</ul>
</li>
<li>Overloading<ul>
<li>Una funzione sovraccaricata in una classe derivata ha un diverso numero e/o tipo di parametri rispetto alla funzione della classe base</li>
<li>La classe derivata ha entrambe le funzioni</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Uso dei membri privati della classe base</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>I membri privati della classe base non sono referenziabili nelle definizioni delle funzioni membro della classe derivata</li>
<li>Diversamente verrebbe violato il principio di incapsulamento</li>
<li>Le funzioni membro della classe derivata possono accedere alle variabili membro private della classe base tramite le funzioni accessor e mutator</li>
<li>Le funzioni membro private della classe base non sono accessibili (di fatto non sono ereditate)</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Il qualificatore protected</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Una variabile o funzione membro qualificata come protected può essere referenziata nelle funzioni membro di una classe derivata</li>
<li>Le variabili membro protected agiscono come se fossero protected in ogni classe derivata</li>
<li>Molti ritengono che l’uso di variabili membro protected comprometta l’incapsulamento
    È quindi buona norma utilizzare protected solo quando assolutamente necessario</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Cosa non viene ereditato</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Oltre alle funzioni membro private non vengono ereditati<ul>
<li>Costruttori</li>
<li>Distruttori</li>
<li>Costruttori di copia</li>
<li>Operatori di assegnamento</li>
</ul>
</li>
<li>Se non vengono definiti vengono creati quelli di default</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Costruttori nelle classi derivate</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>I costruttori della classe base non sono ereditati</li>
<li>Per inizializzare le variabili ereditate…<ul>
<li>Un costruttore della classe derivata può invocare esplicitamente un costruttore della classe base</li>
<li>Altrimenti, viene invocato automaticamente il costruttore di default della classe base</li>
<li>HourlyEmployee::HourlyEmployee(string name, string number,</li>
<li>double wageRate, double hours)</li>
<li>: Employee(name, number), wageRate(wageRate), hours(hours) {</li>
<li>//deliberately empty</li>
<li>}</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Ordine di chiamata dei costruttori</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>La chiamata del costruttore della classe base è la prima azione del costruttore della classe derivata</li>
<li>Se A ◅- B ◅- C, quando viene creato un oggetto di classe C…<ul>
<li>prima viene chiamato un costruttore della classe A</li>
<li>poi un costruttore della classe B</li>
<li>poi vengono intraprese le rimanenti azioni del costruttore di classe C</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Distruttori in classi derivate</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Quando il distruttore di una classe derivata è invocato, viene invocato automaticamente il distruttore della classe base</li>
<li>I distruttori sono chiamati in ordine inverso rispetto ai costruttori</li>
<li>Se A ◅- B ◅- C, quando termina lo scope di un oggetto di classe C…<ul>
<li>viene chiamato prima il distruttore della classe C</li>
<li>poi quello della classe B</li>
<li>infine quello della classe A</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Relazioni tra oggetti</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Relazione “is a”<ul>
<li>Esempio: a HourlyEmployee is an Employee</li>
<li>Utile soprattutto per polimorfismo</li>
<li>Sempre possibile usare un oggetto di una sotto-classe al posto di un oggetto di una classe base</li>
</ul>
</li>
<li>Relazione “has a”<ul>
<li>Esempio: <em>an Employee has a Date (of employment)</em></li>
<li>Serve per riutilizzo di funzionalità</li>
<li>Grado elevato di flessibilità: ...</li>
<li>Gli oggetti membri sono di solito nascosti</li>
<li>Inaccessibili ai programmatori che usano l’oggetto esterno</li>
<li>Possono essere cambiati senza disturbare il codice esterno</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Ereditarietà e riuso</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>La classe base contiene il codice comune alle classi derivate<ul>
<li>L’ereditarietà è una forma di riuso del codice</li>
<li>Si eredita il codice della classe base</li>
</ul>
</li>
<li>Ma la classe derivata è strettamente dipendente dalla classe base, ne eredita anche l’interfaccia!<ul>
<li>Per il semplice riuso è meglio far ricorso al contenimento</li>
<li>Oggetti incapsulati forniscono funzionalità di base</li>
<li>Vedi Eckel, Thinking in C++: http://www.mindview.net/Books</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Ereditarietà protetta e privata</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Ereditarietà protetta: i membri pubblici della classe base sono protetti nella classe derivata quando sono ereditati</li>
<li>Ereditarietà privata: nessun membro della classe base può essere referenziato nella classe derivata</li>
<li>La relazione “is a” non è valida</li>
<li>Sono raramente usate</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Ereditarietà multipla</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Una classe derivata può avere più di una classe base</li>
<li>Possono esserci situazioni ambigue</li>
<li>Richiede una conoscenza approfondita del linguaggio</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Operatori di assegnamento in classi derivate</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Una classe derivata quando sovraccarica l’operatore di assegnamento può fare uso dell’operatore di assegnamento della classe base</li>
</ul>
<pre class="prettyprint" data-lang="c++"><code>Derived&amp; Derived::operator=(const Derived&amp; rtside)
{
    Base::operator=(rtSide);
    //…
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Costruttori di copia in classi derivate</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Una classe derivata quando sovraccarica il costruttore di copia può fare uso del costruttore di copia della classe base</li>
</ul>
<pre class="prettyprint" data-lang="c++"><code>Derived::Derived(const Derived&amp; obj) : Base(obj), …
{
    // …
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Polimorfismo e funzioni virtuali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Polimorfismo e funzioni virtuali sono un meccanismo fondamentale per realizzare sistemi estensibili</li>
<li>Consentono di trattare gli oggetti di tutte le classi di una gerarchia come se fossero oggetti della classe base</li>
<li>Risultato: scrittura di programmi più semplici (meno branching logic), in cui viene favorito il testing ed il mantenimento del codice</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Metodi virtuali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Quando un metodo di una classe base è dichiarato virtuale…</li>
<li>Se invocato tramite un puntatore o un riferimento…<ul>
<li>Il programma sceglie a tempo di esecuzione la funzione della classe appropriata (late binding o dynamic binding)</li>
</ul>
</li>
<li>Se invocato su un oggetto…<ul>
<li>La risoluzione del riferimento avviene a tempo di compilazione (static binding) e la funzione chiamata è quella della classe dell’oggetto (ottimizzazione)</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Metodi virtuali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Per specificare che una funzione è virtuale si include il modificatore virtual nella dichiarazione (non nella definizione)</li>
<li>Quando la definizione di una funzione virtuale viene cambiata in una classe derivata si parla di overriding</li>
<li>La proprietà di essere una funzione virtuale viene ereditata lungo tutta la gerarchia</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Polimorfismo</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Capacità di oggetti appartenenti a classi che derivano da una classe base comune di rispondere in modi diversi alla chiamata di una certa funzione</li>
<li>Si implementa tramite le funzioni virtuali<ul>
<li>Alla chiamata di una funzione virtuale tramite un puntatore o un riferimento alla classe base, il programma sceglie la ridefinizione corretta della funzione nella classe derivata appropriata</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Polimorfismo</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Se una funzione non virtuale è ridefinita in una classe derivata non si ha polimorfismo<ul>
<li>Se viene chiamata tramite un puntatore alla classe base, è utilizzata la versione della classe base</li>
<li>Se viene chiamata tramite un puntatore alla classe derivata, è utilizzata la versione della classe derivata</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>The slicing problem</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Assegnando un oggetto di una classe derivata a una variabile della sua classe base, le variabili e funzioni membro aggiunte dalla classe derivata vengono perse</li>
<li>Il problema può essere risolto usando funzioni virtuali e puntatori</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Overriding e overloading</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Il meccanismo di overriding è concettualmente molto diverso da quello di overloading, e non deve essere confuso con esso</li>
<li>L'overloading consente di definire in una stessa classe più metodi aventi lo stesso nome, ma che differiscano nella signature</li>
<li>L'overriding, invece, consente di ridefinire un metodo in una sottoclasse: il metodo originale e quello che lo ridefinisce hanno necessariamente la stessa firma, e solo a tempo di esecuzione si determina quale dei due deve essere eseguito</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Implementazione delle funzioni virtuali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Se una classe ha una o più funzioni membro virtuali il compilatore crea una tabella che per ogni funzione virtuale contiene l’indirizzo in memoria del codice della funzione</li>
<li>Quando viene creato un oggetto della classe, la sua descrizione contiene un puntatore alla tabella delle funzioni virtuali</li>
<li>Quando una funzione virtuale viene chiamata usando un puntatore all’oggetto, il sistema runtime usa la tabella invece del tipo del puntatore per decidere quale definizione della funzione usare</li>
<li>Le funzioni virtuali introducono overhead</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Classi astratte e funzioni virtuali pure</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Se una funzione è virtuale pura la sua definizione non è necessaria</li>
<li>Una classe con una o più funzioni virtuali pure è detta astratta</li>
<li>Una classe astratta può essere usata solo come classe base per derivare altre classi, non si possono creare oggetti<ul>
<li>Ex: class Abs { public: virtual void f() = 0; };</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Ereditarietà di interfaccia e di implementazione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Con l’ereditarietà pubblica si può ereditare:<ul>
<li>La sola interfaccia (funzioni virtuali pure), oppure...</li>
<li>L’interfaccia più...</li>
<li>Un’implementazione di default (funzioni virtuali)</li>
<li>Un’implementazione obbligatoria (funzioni non virtuali)</li>
</ul>
</li>
<li>È bene non ridefinire le funzioni ereditate non virtuali</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Distruttori delle classi base</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Se si dealloca un oggetto di una classe derivata attraverso un puntatore alla classe base e la classe base ha un distruttore non virtuale, il risultato è indefinito</li>
<li>È bene dichiarare virtuali i distruttori delle classi base</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Polimorfismo</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Aumento di generalità: è il runtime a doversi occupare delle specificità, non il programmatore</li>
<li>Estendibilità: il codice è scritto indipendentemente dai tipi derivati, nuovi tipi possono essere aggiunti senza dover apportare modifiche a quanto già sviluppato</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Funzioni virtuali e parametri di default</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Quando si eredita una funzione virtuale con un parametro di default, è bene non cambiarne il valore</li>
<li>Motivazione<ul>
<li>Le funzioni virtuali usano dynamic binding</li>
<li>I parametri di default usano static binding</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Upcasting e downcasting</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Il casting da un tipo discendente a un tipo antenato è detto upcasting ed è sicuro</li>
<li>Il casting da un tipo antenato a un tipo discendente è detto downcasting ed è pericoloso</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Dynamic cast</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Consente di fare un downcasting sicuro</li>
<li>Va usato su puntatori</li>
<li>Se il cast riesce (cioè se il tipo dinamico corrisponde al tipo che si vuole ottenere), restituisce un puntatore al nuovo tipo, altrimenti restituisce NULL</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Template</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>I template consentono di definire funzioni e classi molto generali che hanno parametri al posto dei tipi</li>
<li>Tecnica particolarmente apprezzata perché consente una notevole riusabilità del software</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Template di Funzioni</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>I template di funzioni supportano l’astrazione algoritmica: esprimere algoritmi in modo molto generale trascurando dettagli implementativi<ul>
<li>Esempio: scambio dei valori di due variabili</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Funzioni Template: Sintassi</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>La dichiarazione e la definizione di una funzione template devono essere precedute dal prefisso di template<ul>
<li>template<class T></li>
</ul>
</li>
<li>Una funzione template corrisponde a un insieme di definizioni di funzione, il compilatore ne produce una per ogni tipo per cui si usa il template</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Funzioni Template: Sintassi (2)</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>È possibile avere template di funzioni con più di un parametro di tipo<ul>
<li>template<class T1, class T2></li>
</ul>
</li>
<li>Generalmente si usano template di funzioni con un solo parametro di tipo</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Funzioni Template e Compilatori</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Molti compilatori non supportano la compilazione separata e richiedono che la definizione della funzione template sia nello stesso file in cui viene usata, prima della prima invocazione
    È possibile mettere la definizione della funzione template in un file separato ed includere questo file</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Definzione e Uso di Funzioni Template</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre><code>È buona norma scrivere prima una funzione ordinaria e, solo dopo che la si è verificata, convertirla in un template
</code></pre>
<ul>
<li>Una funzione template può essere usata per ogni tipo per cui il codice della funzione ha senso</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Template di Classi</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>La definizione di una classe template deve essere preceduta da<ul>
<li>template<class T></li>
</ul>
</li>
<li>Le funzioni membro sono template</li>
<li>Specificando il tipo è possibile dichiarare oggetti della classe template, usare il nome della classe come tipo di un parametro di una funzione, …</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Template di Classi (2)</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Spesso le definizioni di classi template hanno restrizioni implicite sui tipi che possono essere sostituti al parametro</li>
<li>Molti compilatori non supportano la compilazione separata, occorre includere anche il file di implementazione nel file di applicazione</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Template ed Ereditarietà</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre><code>È possibile definire una classe template derivata a partire da una classe base (anche non template)
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Gestione delle Eccezioni</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>C++ fornisce strumenti per gestire situazioni eccezionali</li>
<li>Terminologia<ul>
<li>Sollevare un’eccezione (to throw an exception) = segnalare una situazione eccezionale</li>
<li>Intercettare l’eccezione (to catch or handle the exception) = gestire la situazione eccezionale</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Costrutto try-throw-catch</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="c++"><code>try
{
    /* Some statements */
    if (Exceptional_Case) throw exception;
    /* Some more statements */
}
catch(Type e)
{
    /* Code to be performed if a value of type `Type` */
    /* is thrown in the try block */
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Blocco try</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Contiene il codice per gestire le situazioni normali</li>
<li>Può riconoscere e segnalare situazioni speciali sollevando eccezioni</li>
<li>Se non si verificano eccezioni, l’esecuzione del blocco try è quella standard</li>
<li>E’ buona norma inserire in un blocco try il solo codice che potenzialmente può sollevare un’eccezione</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Istruzione throw</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Usata per “lanciare” un valore detto eccezione</li>
<li>Il valore lanciato può essere di qualsiasi tipo</li>
<li>L’esecuzione del blocco try termina e il controllo passa a un blocco catch</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Blocco catch</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Contiene il codice per gestire la situazione eccezionale</li>
<li>Ha un parametro che<ul>
<li>Specifica quale tipo di valore può essere intercettato dal blocco</li>
<li>Consente di utilizzare il valore intercettato all’interno del blocco</li>
</ul>
</li>
<li>Se non viene sollevata nessuna eccezione l’esecuzione del blocco try viene completata e il blocco catch viene ignorato</li>
<li>Una volta completato il blocco catch, viene eseguito il codice che segue</li>
<li>Un blocco catch risponde solo a un blocco try immediatamente precedente</li>
<li>Se non c’è un blocco catch del tipo opportuno il programma termina</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Classi di Eccezioni</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Sono classi i cui oggetti contengono l’informazione che si vuole lanciare al blocco catch</li>
<li>In questo modo si ottiene un diverso tipo per ogni possibile situazione eccezionale</li>
<li>Può essere utile definire una gerarchia di classi di eccezioni</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Eccezioni Multiple</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Un blocco try può potenzialmente sollevare più eccezioni di tipi diversi</li>
<li>In ogni esecuzione verrà sollevata al massimo una eccezione</li>
<li>Ogni blocco catch può intercettare valori di un solo tipo</li>
<li>Si possono avere più blocchi catch dopo un blocco try per gestire eccezioni di tipo diverso</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Blocco catch di Default</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Quando in un blocco try viene sollevata un’eccezione, i blocchi catch che seguono sono considerati in ordine, viene eseguito il primo che intercetta quel tipo di eccezione</li>
<li>Blocco catch speciale che intercetta ogni tipo di eccezione, da usare come default<ul>
<li>catch(…) { cout &lt;&lt; “Unexplained exception”;}</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Sollevare un’Eccezione in una Funzione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Spesso è utile ritardare la gestione di un’eccezione</li>
<li>Una funzione può sollevare un’eccezione e non intercettarla</li>
<li>Sarà il programma che usa la funzione a gestire l’eccezione</li>
<li>Il programma metterà la chiamata della funzione in un blocco try seguito da un blocco catch che intercetta l’eccezione</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Specifica delle Eccezioni</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Elenca le eccezioni che possono essere sollevate da una funzione e non vengono da essa intercettate</li>
<li>Deve apparire sia nella dichiarazione che nella definizione della funzione</li>
<li>Se viene sollevata un’eccezione che non viene intercettata e non compare nella specifica, viene chiamata la funzione unexpected che per default termina il programma, ma può essere ridefinita</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Specifica delle Eccezioni ed Ereditarietà</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Se B-&gt;D, un’eccezione di tipo D viene gestita come se fosse di tipo B, anche rispetto alla specifica</li>
<li>Quando si dà una nuova definizione o si fa overriding di una funzione ereditata, non si possono aggiungere eccezioni alla specifica, ma se ne possono eliminare</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Quando Sollevare un’Eccezione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Se la funzione è in grado di gestire in modo semplice il caso speciale, non deve sollevare l’eccezione</li>
<li>Se invece il modo in cui il caso speciale va gestito dipende da dove la funzione è usata, si delega la gestione al livello superiore (le eccezioni non intercettate risalgono di scope)</li>
<li>Non usare le eccezioni nei distruttori</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Esempio: Allocazione Dinamica</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="c++"><code>#include &lt;new&gt;
using std::bad_alloc;
//…
try
{
    int *p = new int[100];
}
catch(bad_alloc)
{
    cout &lt;&lt; “Cannot alloc p”;
    //…
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Abuso delle Eccezioni</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>La gestione delle eccezioni genera overhead sia temporale che spaziale</li>
<li>Le istruzioni throw rendono contorto il flusso di controllo (come le istruzioni di salto)</li>
<li>La gestione delle eccezioni va usata con moderazione</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Vantaggi della Gestione delle Eccezioni</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>In un linguaggio che non la supporta si può restituire un codice di errore<ul>
<li>Occorre controllarlo ogni volta</li>
<li>Il programma può ignorarlo</li>
<li>Alcune funzioni non possono restituire un codice di errore</li>
</ul>
</li>
<li>In C++<ul>
<li>Gestione uniforme delle eccezioni per tutte le funzioni</li>
<li>L’eccezione non può essere ignorata</li>
<li>Non si mescola la gestione del caso speciale e dei casi normali</li>
<li>Migliora la gestione delle variabili locali</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Strutture Dati Collegate</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Sono composte da variabili dinamiche di tipo struct o classe dette nodi</li>
<li>I nodi contengono puntatori che puntano ad altri nodi</li>
<li>La Standard Template Library (STL) contiene versioni predefinite di queste strutture dati</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Liste Concatenate</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Sono liste di nodi in cui ogni nodo contiene un puntatore che punta al nodo successivo</li>
<li>Il primo nodo è detto testa, la lista è referenziata tramite un puntatore alla testa</li>
<li>L’ultimo nodo contiene un puntatore NULL</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Pile o Stack</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Una pila (o stack) è una struttura dati che gestisce i dati in modo LIFO</li>
<li>Ha due operazioni base:<ul>
<li>Aggiungere un elemento in cima alla pila (push)</li>
<li>Prelevare un elemento dalla cima della pila (pop)</li>
</ul>
</li>
<li>Può essere implementata tramite una lista concatenata</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Code</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Una coda (o queue) è una struttura dati che gestisce i dati in modo FIFO</li>
<li>Può essere implementata tramite una lista concatenata</li>
<li>Occorrono due puntatori: uno alla testa e un uno alla fine della lista</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Classi friend</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Se una classe F è friend di una classe C, tutte le funzioni membro di F sono friend della classe C</li>
</ul>
<pre class="prettyprint" data-lang="c++"><code>class F; // forward declaration
class C
{
public:
    /*…*/
    friend class F;
    /*…*/
};
class F
{ /*…*/ };
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Iteratori</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Un iteratore è un costrutto usato per indicare un elemento all’interno di una struttura dati</li>
<li>Una classe iteratore estende il concetto di puntatore definendo operatori che consentono di usare la sintassi dei puntatori con gli oggetti della classe (++, --, ==, !=, *)</li>
<li>Un iteratore è usato insieme a una classe struttuta dati che ha le funzioni membro begin() e end()</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Standard Template Library</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Progettata per gestire insiemi di dati in modo comodo ed efficiente senza conoscere dettagli implementativi</li>
<li>Fa parte dello standard C++</li>
<li>È basata sulla programmazione generica</li>
<li>Containers<ul>
<li>Sono classi template usate per contenere insiemi di dati</li>
</ul>
</li>
<li>Iterators<ul>
<li>Servono per muoversi nell’insieme di dati</li>
</ul>
</li>
<li>Algorithms<ul>
<li>Implementazioni di molti algoritmi per operare sull’insieme di dati</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Iteratori</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>È un’astrazione progettata per nascondere i dettagli implementativi e fornire un modo uniforme per esplorare le strutture dati</li>
<li>Ogni classe container ha il suo tipo di iteratori ma la terminologia, la sintassi e la semantica sono le stesse</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Operatori che Operano sugli Iteratori</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Operatore di incremento ++ (in forma prefissa e postfissa)<ul>
<li>Fa avanzare l’iteratore all’elemento successivo</li>
</ul>
</li>
<li>Operatore di decremento -- (in forma prefissa e postfissa)<ul>
<li>Fa retrocedere l’iteratore all’elemento precedente</li>
</ul>
</li>
<li>Operatori di confronto == e !=<ul>
<li>Per verificare se due iteratori puntano allo stesso elemento</li>
</ul>
</li>
<li>Operatore di dereferenziazione *<ul>
<li>Per accedere all’elemento puntato dall’iteratore (l’accesso può essere di sola lettura)</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Iteratori e Containers</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Le classi container hanno due funzioni membro che restituiscono iteratori collocati in posizioni speciali<ul>
<li>begin() restituisce un iteratore che punta al primo elemento</li>
<li>end() restituisce un valore speciale che può essere usato per verificare se un iteratore punta oltre l’ultimo elemento</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Tipi di Iteratori</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Gli iteratori sono classificati secondo il tipo di operazioni ad essi applicabili<ul>
<li>Forward iterators: si può applicare l’operazione ++</li>
<li>Bidirectional iterators: si possono applicare le operazioni ++ e --</li>
<li>Random access iterators: si possono applicare le operazioni ++ e -- e si può accedere a qualsiasi elemento in un solo passo</li>
</ul>
</li>
<li>Ogni categoria include le precedenti</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Iteratori constant e mutable</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Un iteratore di qualsiasi tipo è<ul>
<li>Constant se l’operatore * restituisce l’elemento puntato come r-value</li>
<li>Mutable se l’operatore * restituisce l’elemento puntato come l-value</li>
</ul>
</li>
<li>Se una classe container ha iteratori mutable, ha anche iteratori const</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Reverse Iterators</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Se una classe container ha iteratori bidirezionali, per passare gli elementi in ordine inverso si possono usare i reverse iterators</li>
<li>La funzione membro rbegin() restituisce un iteratore che punta all’ultimo elemento</li>
<li>La funzione membro rend() restituisce un valore speciale che può essere usato per verificare se un reverse iterator punta oltre il primo elemento</li>
<li>L’operatore ++ fa avanzare un reverse iterator in senso inverso</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Sequential Containers</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Gli elementi sono ordinati in base al modo in cui sono inseriti<ul>
<li>slist (lista concatenata semplice, non standard)</li>
<li>list (lista concatenata doppia)</li>
<li>vector</li>
<li>deque (coda in cui si inseriscono e rimuovono elementi a entrambe le estremità)</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Lists (vs vectors)</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Gli elementi non sono contigui in memoria</li>
<li>Non forniscono accesso casuale agli elementi</li>
<li>L’inserimento e la rimozione degli elementi impiegano lo stesso tempo in tutte le posizioni</li>
<li>L’inserimento o la rimozione di un elemento non invalidano puntatori, iteratori e reference</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Container Adapters</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Sono classi template implementate a partire da altre classi<ul>
<li>stack, queue basate su deque</li>
<li>priority_queue basata su vector</li>
</ul>
</li>
<li>È possibile specificare un container sottostante differente da quello di default<ul>
<li>Es: stack<int, vector<int> &gt;</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Associative Containers</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Ogni elemento ha associato un valore detto chiave</li>
<li>Gli elementi sono individuati per mezzo della chiave</li>
<li>set, multiset, map, multimap</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Set</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Ogni elemento coincide con la sua chiave</li>
<li>Ogni elemento può comparire al più una volta</li>
<li>Per motivi di efficienza memorizza gli elementi in ordine rispetto al loro valore (i set sono implementati come alberi binari)</li>
<li>Per default l’ordinamento usa l’operatore &lt;
    È possibile specificare un diverso criterio di ordinamento purché sia<ul>
<li>Antisimmetrico: op(x,y)=TRUE -&gt; op(y,x)=FALSE</li>
<li>Transitivo: op(x,y)=TRUE &amp;&amp; op(y,z)=TRUE -&gt; op(x,z) = TRUE</li>
<li>Irriflessivo: op(x,x) = FALSE</li>
</ul>
</li>
<li>multiset è come set ma consente la ripetizione degli elementi</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Map</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre><code>È un insieme di coppie ordinate di elementi (corrisponde a una funzione)
- Es: map&lt;string, int&gt; numberMap;
</code></pre>
<ul>
<li>Per motivi di efficienza memorizza gli elementi in ordine rispetto al valore della chiave</li>
<li>Se non si specifica un ordinamento, viene usato quello di default</li>
<li>multimap è come map ma consente che più valori siano associati alla stessa chiave</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Generic Algorithms</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>STL contiene algoritmi generici</li>
<li>STL specifica non solo<ul>
<li>sintassi (interfaccia)</li>
<li>semantica (relazioni di I/O)</li>
</ul>
</li>
<li>ma anche<ul>
<li>tempo di calcolo</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Miscellanea</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Regole di buona programmazione<ul>
<li>Pre-condizioni e post-condizioni</li>
<li>Programmazione difensiva</li>
<li>La macro assert</li>
</ul>
</li>
<li>Checklist for class authors</li>
<li>Cosa fare ora</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Pre-condizioni e Post-condizioni</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre><code>È buona norma includere nella dichiarazione di una funzione un commento che indichi
- Pre-condizioni: condizioni che devono esistere quando la funzione è chiamata
- Post-condizioni: condizioni che si verificano dopo che la funzione è eseguita
-     Descrizione del valore ritornato o delle modifiche al valore degli argomenti
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Pre-condizioni e Post-condizioni</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Esempio<ul>
<li>void showInterest(double balance, double rate);</li>
<li>//Precondition: balance is a non-negative savings</li>
<li>//account balance, rate is the interest rate expressed</li>
<li>//as a percentage, such as 5 for 5%.</li>
<li>//Postcondition: the amount of interest on the given</li>
<li>//balance at the given rate is shown on the screen.</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Programmazione Difensiva</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Metodologia che punta alla prevenzione dell’errore piuttosto che alla sua correzione</li>
<li>Si introducono controlli (detti invarianti) in punti del programma in cui certe condizioni devono sicuramente essere verificate</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>La Macro assert</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Un altro modo per introdurre controlli di errore al fine di documentare e verificare la correttezza dei programmi</li>
<li>Valuta un’espressione booleana:<ul>
<li>se è vera non accade nulla</li>
<li>se è falsa il programma termina e invia un messaggio di errore</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>La Macro assert (2)</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Può essere usata per verificare le pre-condizioni
    È definita nella libreria cassert</li>
<li>Utile nella fase di debug, dopo il test introduco #define NDEBUG e gli assert vengono ignorati<ul>
<li>assert infatti è definita come una macro: definendo NDEBUG prima di includere assert.h, si disattiva la macro</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Deallocazione autom.</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Reference counting vs. garbage collection<ul>
<li>Quando ci sono 0 riferimenti, oggetto rimosso</li>
<li>Risolve maggior parte di memory leak</li>
<li>Non funziona con riferim. ciclici! (Cfr. weak_ptr)</li>
</ul>
</li>
<li>TR1 (2005) di C++ introduce shared_ptr<ul>
<li>// vector<Polygon*> elements; vector<shared_ptr<Polygon> &gt; elements;</li>
<li>Oggetti rimossi quando si distrugge il vector</li>
<li>O cmq quando si annulla l'ultimo shared_ptr</li>
</ul>
</li>
<li><em>Last one out, turn off the lights</em></li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Lista con smart ptr</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="c++"><code>#include &lt;tr1/memory&gt;
typedef std::tr1::shared_ptr&lt;Polygon&gt; PolyPtr;

class ListOfPolygons {
  public:
    void addElement(Polygon* p); // Same signature, or...
    Polygon* getElement(int i);  // PolyPtr everywhere
    int getSize();
    void sort();
  private:
    vector&lt;PolyPtr&gt; elements;
}
typedef std::tr1::shared_ptr&lt;ListOfPolygons&gt; ListPtr;

void ListOfPolygons::addElement(Polygon* p) {
  elements.push_back(PolyPtr(p));
}
Polygon* ListOfPolygons::getElement(int i) {
  return elements[i].get();
}
int ListOfPolygons::getSize() { return elements.size(); }
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Smart ptr all'opera</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="c++"><code>// Create a list and fill it with polygons
ListPtr list(new ListOfPolygons());
list-&gt;addElement(new Rectangle(5, 7));
list-&gt;addElement(new Square(6));
list-&gt;addElement(new Triangle(3, 4, 5));
list-&gt;addElement(new RegularPolygon(5, 7));

// Print areas
list-&gt;sort();
for (int i = 0; i &lt; list-&gt;getSize(); ++i) {
  PolyPtr p(list-&gt;getElement(i));
  cout &lt;&lt; p-&gt;getName() &lt;&lt; ": " &lt;&lt; p-&gt;area();
}

// Delete polygons and list
list = NULL; // No need to do anything else!
</code></pre></article>
 
</slide>


<slide class="thank-you-slide segue nobackground">
  <aside class="gdbar right"><img src="images/logo.png"></aside>
  <article class="flexbox vleft auto-fadein">
    <h2>&lt;Domande?&gt;</h2>
  </article>
  <p class="auto-fadein" data-config-contact>
    Michele Tomaiuolo
    <br>
    Palazzina 1, int. 5708
    <br>
    Ingegneria dell'Informazione, UniPR
    <br>
    <a href="http://www.ce.unipr.it/people/tomamic">www.ce.unipr.it/people/tomamic</a>
  </p>
</slide>

<slide class="backdrop"></slide>

</slides>

</body>
</html>