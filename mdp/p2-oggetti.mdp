title: Funzioni e oggetti
subtitle: Introduzione alla programmazione
figure: images/oop/balls.png

---

title: Definizione di funzioni
figure: images/fun/function.png

- *Operatore*, applicato a *operandi*, per ottenere un *risultato*
    - **`def`** per definire una funzione
    - **`return`** per terminare e restituire un risultato

code: py

    def hypotenuse(a, b):
        c = (a ** 2 + b ** 2) ** 0.5
        return c

---

title: Chiamata di funzioni

- **`def`** definisce una funzione, ma non la esegue!
- Bisogna *chiamarla*
- Funzione, quando eseguita, crea nuovo *spazio di nomi*
    - Parametri e variabili hanno **ambito locale**
    - Non visibili nel resto del programma
    - Nomi uguali, definiti in ambiti diversi, restano distinti

code: py

    side1 = float(input('1st side? '))
    side2 = float(input('2nd side? '))
    side3 = hypotenuse(side1, side2)
    print('3rd side:', side3)

---

title: Funzione main

- A volte si preferisce creare una *funzione principale*
    - In questo modo si limitano le **variabili globali**

code: py

    def hypotenuse(a, b):
        c = (a ** 2 + b ** 2) ** 0.5
        return c

    def main():
        side1 = float(input("1st side? "))
        side2 = float(input("2nd side? "))
        side3 = hypotenuse(side1, side2)
        print("3rd side:", side3)

    main()  ## remove, if importing the module elsewhere

>

<http://www.ce.unipr.it/brython/?p2_fun_hypotenuse.py>

---

title: Parametri di funzioni

- **Parametri formali**: nomi usati nella *definizione*
- **Parametri effettivi**: oggetti passati alla funz.
- Parametri passati “*per oggetto*”;
    - Variabili all'esterno: non vengono modificate
    - Liste e oggetti passati ad una funz.: modifiche *permanenti*
- Si possono restituire più valori, come *tupla*
    - `return 7, 5, 'black'`

code: py

    def inc(a):
        a += 1
        print(a)  # just for debug
    x = 10
    inc(x)
    print(x)      # just for debug

---

title: Documentazione di funzioni

- **Annotazioni**: utili per documentare il tipo di param. e valore di ritorno (ma non c'è verifica!)
- **Docstring**: descrizione testuale di una funzione
- **`help`**: funzione per visualizzare la documentazione

code: py

    def hypotenuse(leg1: float, leg2: float) -> float:
        '''
        Return the hypotenuse of a right triangle,
        given both its legs (catheti).
        '''
        return (leg1 ** 2 + leg2 ** 2) ** 0.5

---

title: Cicli su stringhe

- Il ciclo `for` scorre i valori qualsiasi sequenza
- Una stringa è una sequenza di caratteri

code: py

    text = input("text? ")
    min_char = input("Min char to uppercase? ")
    max_char = input("Max char to uppercase? ")

    for c in text:
        if min_char <= c <= max_char:
            print(c.upper(), end="")
        else:
            print(c, end="")

---

title: Cicli e annidamento
figure: images/fun/multiplication-table.jpg

code: py

    size = 10
    y = int(input("Insert a value: "))
    for x in range(1, size + 1):
        print(x * y, end=" ")  # ends with blank
                               # no newline
code: py

    size = 10
    for y in range(1, size + 1):
        for x in range(1, size + 1):
            val = x * y
            print(f"{val:3}", end=" ")  # val represented as text
                                        # with at least 3 chars
        print()

>

<http://www.ce.unipr.it/brython/?p2_for_tables.py>

---

title: Procedura

- Funzione senza `return`, solo I/O ed effetti collaterali
    - *Astrazione*, per riuso e leggibilità
    - Riduce i livelli di annidamento

code: py

    def print_row(y: int, size: int):
        for x in range(1, size + 1):
            val = x * y
            print(f"{val:3}", end=" ")
        print()

    def print_table(size: int):
        for y in range(1, size + 1):
            print_row(y, size)

    def main():
        print_table(10)

---

title: Animazione
figure: images/oop/anim-right.png

code: py

    import g2d

    x, y, dx = 50, 50, 5
    ARENA_W, ARENA_H = 320, 240
    image = g2d.load_image("ball.png")

    def update():
        global x
        g2d.fill_canvas((255, 255, 255))  # Draw background
        g2d.draw_image(image, (x, y))     # Draw foreground
        x = (x + dx) ##% ARENA_W          # Update ball's position

    g2d.init_canvas((ARENA_W, ARENA_H))
    g2d.main_loop(update, 1000 // 30)     # <-- Call update 30 times/second

>

<http://www.ce.unipr.it/brython/?p2_fun_anim.py>

---

title: Eventi della tastiera

code: py

    import g2d

    def keydown(code: str):
        print("Key pressed: ", code)

    def keyup(code: str):
        print("Key released: ", code)

    g2d.init_canvas((320, 240))
    g2d.handle_keyboard(keydown, keyup)  # <-- Keyb events
    g2d.main_loop()

>

<https://developer.mozilla.org/es/docs/Web/API/KeyboardEvent/code>

<http://www.ce.unipr.it/brython/?p2_fun_keyb.py>

---

title: Funzione per rimbalzi
figure: images/oop/anim-bounce.png

- Le funzioni forniscono limitata astrazione
    - Incapsulano il comportamento
    - Ma espongono i dati

code: py

    def move_ball(x: int, y: int,
                  dx: int, dy: int) -> (int, int, int, int):
        if x + dx < 0 or x + dx + BALL_W > ARENA_W:
            dx = -dx
        x += dx
        if y + dy < 0 or y + dy + BALL_H > ARENA_H:
            dy = -dy
        y += dy
        return x, y, dx, dy

<http://www.ce.unipr.it/brython/?p2_fun_ball.py>

---

title: Effetti collaterali 🤔

- Modifica di oggetti passati come parametri o variabili globali, operazioni di lettura/scrittura...
- Annullano la **trasparenza referenziale**
    - Impossibile semplificare, sostituendo una chiamata a funzione col suo valore di ritorno (es. presenti operazioni di I/O)
- Rendono la funzione **non idempotente**
    - Chiamata più volte, con gli stessi parametri, restituisce risultati diversi
- → Difficile fare verifiche matematiche
    - `z = f(sqrt(2), sqrt(2))`
    - `s = sqrt(2)` <br> `z = f(s, s)`

---

title: Funzioni non idempotenti 🤔

- Esempio di semplificazione
    - `p = rq(x) + rq(y) * (rq(x) – rq(x))`
    - `p = rq(x) + rq(y) * (0)`
    - `p = rq(x) + 0`
    - `p = rq(x)`
- Ma se `rq` ha effetti collaterali, non si può!

code: py

    base_value = 0  # global variable

    def rq(x: int) -> int:
        global base_value
        base_value += 1
        return x + base_value

>

Ad esempio, con `x = 3` e `y = 4` i due risultati sono `-2` e `4`

---

title: Oggetti
class: segue dark

---

title: Oggetto
figure: images/oop/basic-object.svg

- Rappresenta un *oggetto fisico* o un *concetto* del dominio
- Memorizza il suo **stato** interno in *campi privati*
    - *Incapsulamento (black box)*
- Offre un insieme di **servizi**, come *metodi pubblici*
    - Realizza un *tipo di dato astratto (ADT)*

---

title: Classi ed oggetti
figure: images/oop/cookie-cutter.png

- Ogni *oggetto* ha una **classe** di origine
    - La classe dà la stessa forma iniziale (campi e metodi) a tutti i suoi oggetti
- Ma ogni *oggetto* ha la sua **identità**
    - Stato e locazione in memoria distinti da quelli di altri oggetti
    - Sia instanze di classi diverse che della stessa classe

---

title: Definizione della classe
figure: images/oop/ball-object.svg images/oop/ball-uml.svg
figcaption: Class diagram UML

- **Incapsulamento** dei dati: *convenzione* sui nomi
    - Prefisso `_` per i nomi dei *campi privati*

> We're all consenting adults here. *(GvR)*

code: py

    class Ball:

        def __init__(self, x: int, y: int):
            self._x = x
            self._y = y
            self._dx = 5
            self._dy = 5
        # ...

---

title: Costruzione oggetti
figure: images/oop/bob-builder.jpg

- **`__init__`**: metodo *inizializzatore*
    - Eseguito automaticamente alla creazione di un oggetto
    - *Instantiation is initialization*
- **`self`**: primo parametro di tutti i metodi
    - Non bisogna passare un valore esplicito
    - Assegnato l'oggetto di cui si chiama il metodo
    - Permette ai metodi di accedere ai campi

code: py

    ball = Ball(40, 80)  # Allocation and initialization

---

title: Metodi
figure: images/oop/anim-bounce.png

- Espongono *servizi* ad altri oggetti

code: py

    ARENA_W, ARENA_H = 320, 240
    BALL_W, BALL_H = 20, 20

    class Ball:
        # ...
        def move(self):
            if not (0 <= self._x + self._dx <= ARENA_W - BALL_W):
                self._dx = -self._dx
            if not (0 <= self._y + self._dy <= ARENA_H - BALL_H):
                self._dy = -self._dy
            self._x += self._dx
            self._y += self._dy

        def position(self) -> (int, int, int, int):
            return self._x, self._y, BALL_W, BALL_H

---

title: Uso degli oggetti
figure: images/oop/balls.png

code: py

    # Create two objects, instances of the Ball class
    b1 = Ball(140, 180)
    b2 = Ball(180, 140)

    for i in range(25):
        print("b1 @", b1.position(),
              "b2 @", b2.position())
        b1.move()
        b2.move()

>

<http://www.ce.unipr.it/brython/?p2_oop_ball.py>

---

title: Il primo parametro, self

- Il primo parametro di ogni metodo si chiama `self` (per convenzione)
- L'oggetto, di cui viene invocato il metodo, viene assegnato come valore di `self`
- In Python, una chiamata a metodo è interpretata così:

code: py

    b1 = Ball(40, 80)
    b1.move()

code: py

    # Python internals, DON'T do this!
    b1 = object.__new__(Ball)
    Ball.__init__(b1, 40, 80)
    Ball.move(b1)

---

title: Animazione di due palline

code: py

    import g2d
    from p2_oop_ball import Ball, ARENA_W, ARENA_H

    def update():
        g2d.fill_canvas((255, 255, 255))  # BG
        b1.move()
        b2.move()
        g2d.draw_rect((127, 127, 127), b1.position())  # FG
        g2d.draw_rect((127, 127, 127), b2.position())  # FG

    b1 = Ball(40, 80)
    b2 = Ball(80, 40)
    g2d.init_canvas((ARENA_W, ARENA_H))
    g2d.main_loop(update, 1000 // 30)  # Millis

>

<http://www.ce.unipr.it/brython/?p2_oop_ball_anim.py>

---

title: Variabili locali, parametri, campi

- *Campi*: memorizzano i dati caratteristici di una istanza
    - Ogni pallina ha la sua posizione `(x, y)` e la sua direzione `(dx, dy)`
- *Parametri*: passano altri valori ad un metodo
    - Se alcuni dati necessari non sono nei campi
- *Variabili locali*: memorizzano risultati parziali
    - Generati durante l'elaborazione del metodo
    - Nomi cancellati dopo l'uscita dal metodo
- *Variabili globali*: definite fuori da tutte le funzioni
    - Usare sono se strettamente necessario
    - Meglio avere qualche parametro in più, per le funzioni

---

title: Proprietà 🤔

- Permettono un accesso controllato allo stato

code: py

    class Ball:

        @property  # a getter for the pos property
        def pos(self) -> (int, int):
            return self._x, self._y

        # @pos.setter  # if you also really need a setter
        # def pos(self, val: (int, int)):
        #     self._x, self._y = val

code: py

    ball = Ball(40, 80)
    print('ball @', ball.pos)
    # ball.pos = (60, 20)   # with the setter, you could change the pos

---

title: Esercizi
class: segue dark

---

title: Area di un'ellisse
figure: images/misc/ellipse.svg

- Definire una *funzione* `ellipse_area` che:
    - Riceve come *parametri* i semiassi di una ellisse: `a`, `b`
    - Restituisce come risultato l'area dell'ellisse: `π⋅a⋅b`
- Definire una *funzione* `main` che:
    - Chiede all'utente due valori
    - Invoca la funzione `ellipse_area` con questi parametri
    - Stampa il risultato ottenuto

>

<http://www.ce.unipr.it/brython/?p2_fun_ellipse.py>

---

title: Griglia di colori
figure: images/misc/color-grid.png images/oop/raster-tile.png

- Chiedere all'utente dei valori per `rows` e `cols`
- Mostrare una griglia di rettangoli di dimensione `rows×cols`
- Partire da un rettangolo nero in alto a sinistra
- In orizzontale, aumentare gradatamente la componente di blu
- In verticale, aumentare gradatamente la componente di verde

>

Cominciare a creare una griglia di riquadri tutti neri, con due cicli `for` annidati

Lasciare tra i riquadri un piccolo margine

<http://www.ce.unipr.it/brython/?p2_for_color_grid.py>

---

title: Conteggio cifre
figure: images/misc/numbers.jpg

- Chiedere una riga di testo all'utente
- Contare il numero complessivo di cifre presenti (da `'0'` a `'9'`)
- Valutare anche la somma di tutte le singole cifre trovate

>

Usare un ciclo `for` sulla stringa (sequenza di caratteri)

<http://www.ce.unipr.it/brython/?p2_for_digits.py>

---

title: Testo tra parentesi

- Chiedere all'utente un testo
- Riscrivere il testo in output, ma...
- Escludere le parti racchiuse tra parentesi: `( )`

>

Segnare in un bool se si è letta una parentesi aperta, ma non ancora una parentesi chiusa

<http://www.ce.unipr.it/brython/?p2_for_parens.py>

---

title: Movimento orizzontale
figure: images/misc/street-fighter.jpg

- Mostrare una pallina che si muove in orizzontale
    - Variabile `dx` indica lo spostamento da effettuare ad ogni ciclo
- La pallina rimbalza sui bordi
    - Cambiare segno a `dx`
    - Quando `x` raggiunge un bordo

>

<http://www.ce.unipr.it/brython/?p2_fun_anim.py>

---

title: Movimento a serpentina
figure: images/misc/science-of-spaceships.jpg

- Mostrare una pallina che si muove a serpentina
- Partire dall'esercizio precedente
    - Al momento del rimbalzo, imporre un spostamento verso il basso
    - Fare in modo che, in ogni frame, lo spostamento sia solo orizzontale, o solo verticale, ma *non* diagonale

>

<http://www.ce.unipr.it/brython/?p2_fun_serpentine.py>

---

title: Spirale
figure: images/misc/spiral-circles.png

- Mostrare l'*animazione* di un cerchio lungo una spirale
- Ruotare attorno ad un centro fisso `(xc, yc)`
- Amentare dist. `r` dal centro ad ogni passo
- Cancellare lo sfondo ad ogni passo
- Disegnare un cerchio sempre più grande
- Dopo `n` passi, ricominciare daccapo

>

<http://www.ce.unipr.it/brython/?p2_fun_spiral.py>

---

title: Ellisse
figure: images/misc/ellipse.svg

- Classe che modella un'ellisse
- Campi privati (parametri del costruttore)
    - Semiassi: `a, b`
- Metodi pubblici per ottenere...
    - Area: `π⋅a⋅b`
    - Distanza focale: `2⋅√|a^^2^^ - b^^2^^|`
- Nel corpo principale del programma...
    - Creare un oggetto con dati forniti dall'utente
    - Visualizzare area e distanza focale dell'ellisse

>

<http://www.ce.unipr.it/brython/?p2_oop_ellipse.py>

---

title: Animazione di una pallina
figure: images/misc/street-fighter.jpg

- Partire dalla classe `Ball` vista a lezione
- Eseguire l'animazione
    - Per ogni frame, chiamare il metodo `move` della pallina
    - Rappresentare un rettangolo o un cerchio nella posizione aggiornata della pallina
- Modificare però il metodo `move`
    - La pallina si sposta sempre di pochi pixel in orizzontale
    - La pallina non si sposta verticalmente
    - Se esce dal bordo destro, ricompare al bordo sinistro e viceversa

>

<http://www.ce.unipr.it/brython/?p2_oop_hcycle.py>

---

title: Classe degli alieni
figure: images/misc/invaders-path.jpg

- Creare una classe `Alien`, che contenga i dati ed il comportamento dell'alieno
    - Campi privati: `x`, `y`, `dx`
    - Metodo `move` per avanzare a serpentina
    - Metodo `position` per ottenere la posizione attuale
- Istanziare un oggetto `Alien` e farlo muovere sullo schermo
    - Chiamare il metodo `move` ad ogni ciclo
    - Visualizzare un rettangolo nella posizione corrispondente

>

Definire nella classe delle opportune costanti

<http://www.ce.unipr.it/brython/?p2_oop_alien.py>

---

title: Spirale con classe
figure: images/misc/spiral-circles.png

- Mostrare l'*animazione* di un cerchio lungo una spirale
- Realizzare una classe per gestire dati e comportamento del cerchio
- Implementare il movimento in un metodo `move()`
- Campi: `xc`, `yc`, `i`
    - `i` conta i passi; se accede il limite, torna a 0

>

<http://www.ce.unipr.it/brython/?p2_oop_spiral.py>

---

title: Modulo main 🤔
class: break

- Nome del modulo in esecuzione: `__name__`
    - É il nome del file, senza estensione
- Il modulo di avvio dell'app ha nome speciale
    - In *CPython*, nome `"__main__"`
    - In *Brython* nome `"script..."`; il “trucco” non funziona

code: py

    # def hypotenuse ...
    def main():
        side1 = float(input("1st side? "))
        side2 = float(input("2nd side? "))
        print("3rd side:", hypotenuse(side1, side2))

    # if this module is imported, main is not executed
    if __name__ == "__main__":
        main()

---

title: Ciclo di vita di un oggetto 🤔
figure: images/dev/garbage-truck.jpg

- Creazione di un oggetto: allocata memoria per tenere lo stato dell’oggetto
- In Python: variabile = riferimento ad un oggetto
    - *Oggetti*: *allocazione dinamica*, in memoria *heap*
    - *Variabili*: *allocazione automatica*, in memoria *stack*
- Oggetto non più associato a nessuna variabile: necessario liberare memoria
- **Garbage collection**: gestione automatica della restituzione di memoria

---

title: Garbage collection 🤔

- Vantaggi
    - Non è possibile dimenticare di liberare la memoria (*memory leak*)
    - Non è possibile liberare della memoria che dovrà essere utilizzata in seguito (*dangling pointer*)
- Svantaggi
    - Decide autonomamente quando liberare la memoria
    - Liberare e compattare la memoria richiede del calcolo
- Diversi algoritmi
    - *Reference counting*: idea di base, ma cicli…
    - *Mark & sweep*: parte da riferimenti locali/globali, marca oggetti raggiungibili
    - *Generational garbage collection*: controlla spesso oggetti recenti


