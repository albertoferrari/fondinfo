title: Qualit√† del software
subtitle: Introduzione all'informatica
figure: images/dev/bug-feature.jpg

---

title: Ciclo di vita del software
figure: images/dev/waterfall-model.svg
class: large-figure

- **Analisi**
    - Modello, requisiti, fattibilit√†
- **Progetto e implementazione**
    - Componenti architetturali... dettaglio classi
- **Collaudo**
    - Rispetto requisiti, qualit√† sw
- **Rilascio e manutenzione**
    - 40%-80% del costo totale (DoD, HP)
    - Non noti o non colti correttamente i requisiti
    - Cambiano le condizioni operative ‚Ä¶

>

[Winston W. Royce, 1970](http://www.cs.umd.edu/class/spring2003/cmsc838p/Process/waterfall.pdf) - [Robert L. Glass, 2001](http://www.eng.auburn.edu/~hendrix/comp6710/readings/Forgotten_Fundamentals_IEEE_Software_May_2001.pdf)

---

title: Evoluzione di un sistema sw
figure: images/dev/rup-cycle.png
class: large-figure

- Evoluzione ineliminabile per molti sistemi
    - Prestazioni, qualit√†, funzionalit√† (manutenzione *perfettiva*, ~60%)
    - Anomalie ed errori (manutenzione *correttiva*, ~20%)
    - Mutamenti dell‚Äôambiente (manutenzione *adattativa*, ~20%)
- Sviluppo iterativo e metodologie agili
    - Rilascio frequente ed incrementale
    - <http://agilemanifesto.org/>

---

title: Qualit√† del software
figure: images/dev/programmer.jpg
class: large-figure

- Le qualit√† su cui si basa la valutazione di un sistema software possono essere:
    - **Interne**, riguardano le caratteristiche legate al **processo** di sviluppo e non sono direttamente visibili agli utenti
    - **Esterne**, riguardano le funzionalit√† fornite dal **prodotto** sw e sono direttamente visibili agli utenti
- Le categorie sono legate:
    - *Product quality is process quality*

---

title: Qualit√† esterne

- **Correttezza e affidabilit√†**: il sistema rispetta le specifiche, l'utente pu√≤ affidarsi al programma
- **Robustezza**: il sistema si comporta in modo ragionevole anche fuori dalle specifiche
- **Efficienza**: usa bene le risorse di calcolo
- **Scalabilit√†**: migliori prestazioni con pi√π risorse
- **Sicurezza**: riservatezza, autenticazione, autorizzazione, accounting
- **Facilit√† d‚Äôuso**: interfaccia utente permette di interagire in modo naturale

---

title: Qualit√† interne

- **Verificabilit√†**: sistema basato su modello formale
- **Riusabilit√†**: parti per costruire nuovi sistemi
- **Manutenibilit√†**: riparabilit√†, evolvibilit√† (nuove specifiche), adattabilit√† (cambiamenti ambiente)
- **Interoperabilit√†**: capacit√† di co-operare con altri sistemi, anche di altri produttori
- **Portabilit√†**: adatto a pi√π piattaforme hw/sw
- **Comprensibilit√†**: codice leggibile, documentato
- **Modularit√†**: interazione tra componenti coesi

---

title: Specifiche
figure: images/dev/gearwheel.png

- Rispetto a cosa valutiamo **correttezza** o **affidabilit√†** di un programma?
- Idea del programmatore
    - Non formulata, non documentata
    - Incompleta, mutevole, facilmente dimenticata
- Specifiche (formali o informali)
    - Formulate, scritte, studiate e condivise <br> ‚Üí Parte del progetto e del programma
    - Spec. assiomatiche: espressioni logiche o asserzioni <br> ‚Üí **Precondizioni, postcondizioni e invarianti**

---

title: Pre- e post-condizioni

- **Precondizioni**
    - Stabiliscono se √® possibile chiamare un metodo
    - Prerequisiti per l‚Äôattivazione
- **Postcondizioni**
    - Stabiliscono se il metodo restituisce il valore atteso, cio√® se produce l‚Äôeffetto desiderato
    - ‚Ä¶ In relazione ai parametri (che soddisfano le precondizioni)
    - Definiscono il significato del metodo
- **Divisione delle responsabilit√†** tra moduli
    - Errore del codice *chiamante* (*client*) se precondizioni non soddisfatte
    - Errore del codice *chiamato* (*server*), se postcondizioni non soddisfatte

---

title: Responsabilit√† e contratti

- **Precondizioni + postcondizioni = contratto**
    - ‚Ä¶ tra modulo chiamante e modulo chiamato
- Infrazione di un contratto: problema serio
    - Errore rispetto alle specifiche
    - Eccezione e/o terminazione
- No **divisione responsabilit√†** ‚Üí sovrapposizioni
    - Tutti i moduli assumono molte responsabilit√†
    - Programmazione difensiva: tutte le parti del programma controllano tutte le condizioni
    - Grosso programma ‚Üí ancora pi√π grosso

---

title: Esempio di contratto

code: Python

    def sqrt(x: float) -> float

- Precondizioni: `x >= 0`
- Postcondizioni: `abs(result * result - x) <= 0.00001`
- Codice chiamante
    - Obblighi: deve passare un numero non negativo
    - Benefici: riceve la radice del numero
- Codice chiamato
    - Obblighi: restituisce un numero `r` tale che `r * r ‚âÉ x`
    - Benefici: pu√≤ assumere che `x` non √® negativo

---

title: Invariante di classe

- Vincolo che deve valere per ogni stato stabile di un oggetto, durante tutto il suo ciclo di vita
- Rafforzamento generale di pre- e post-condizioni
- ‚ÄúCriterio di sanit√†‚Äù dell‚Äôoggetto
- Deve essere soddisfatto dal costruttore
- Deve essere mantenuto dai metodi pubblici
- Ma non necessariamente da metodi privati o protetti

---

title: Ereditariet√† e contratti

![](images/dev/contract-inherit.svg)

- *Che relazione c‚Äô√® tra le asserzioni di una classe e quelle dei suoi discendenti?*

---

title: Principio di sostituibilit√†

- Polimorfismo: possibile esecuzione metodo di una sottoclasse, anzich√© della classe base
    - I metodi delle sottoclassi possono ridefinire i metodi delle classi base... ma non arbitrariamente
- I contratti della sottoclasse devono *rispettare i contratti della classe base* (‚Äúsottocontratti‚Äù)
    - Precondizioni: non devono essere pi√π forti
    - Postcondizioni: non devono essere pi√π deboli
    - Invarianti di classe: non devono essere pi√π deboli

> Require no more, promise no less

---

title: Design by contract

- Paradigma proposto nel linguaggio *Eiffel* (Betrand *Meyer*, 1986)
- Uso di asserzioni in varie fasi di sviluppo
    - Progetto: approccio pragmatico alle specifiche
    - Implementazione: guida per la programmazione
    - Documentazione: interfacce con info aggiuntive
    - Collaudo: DbC delimita i casi da testare (per affidabilit√†)
    - Manutenzione: DbC fa emergere prima gli errori
    - Uso finale: sollevate eccezioni se violazioni

---

title: Asserzioni Python

- Espressioni booleane, simili a predicati matematici
- Esprimono propriet√† semantiche di classi e metodi
- Utili per collaudo e debugging, ma anche documentazione
- Violazione ‚Üí **AssertionError** (e normalmente *abort*, terminazione programma)

code: Python

    assert age > 0

---

title: Asserzioni e contratti

- Asserzioni in genere utili per:
    - Precondizioni, postcondizioni, invarianti di classe
    - Invarianti interne e di controllo del flusso
- Argomenti di metodi pubblici sbagliati ‚Üí eccezione
    - `ValueError` o `TypeError`
- Di solito, asserzioni usate per debug, ma disabilitate in produzione
    - `python -O some_code.py`

---

title: Pre- e post-condizioni

code: Python

    def sqrt(x: float) -> float:
        '''
        Precondition: x >= 0
        Postcondition: abs(result * result - x) <= 0.00001
        '''
        if x < 0:
            raise ValueError("sqrt: arg < 0")

        # ...

        assert abs(result * result - x) <= 0.00001
        return result

---

title: Verifica e validazione
class: segue dark

---

title: Verifica e validazione
figure: images/dev/v-model.png
class: large-figure

- Mostrare che il sistema...
    - √à conforme alle specifiche
    - Soddisfa i bisogni dell‚Äôutente
- Comprende revisione e collaudo del sistema
- **Test case**, derivati dalle specifiche

---

title: Costo dei bug
figure: images/dev/first-bug.jpg
class: large-figure

- Scovare bug non √® un compito facile, e nemmeno una esperienza eccitante‚Ä¶
    - Costoso: non √® insolito dedicare al testing il 40% del tempo e delle risorse di un progetto
- **Far emergere** bug in prime fasi dello sviluppo!
    - B. Boehm: se trovare e correggere un problema in fase di specifica dei requisiti costa 1$...
    - 5$ in progetto, 10$ in programmazione,
    - 20$ in unit testing, fino a 200$ dopo consegna
    - Alcuni bug possono capitare gi√† a causa di specifiche non ben chiare e capite

---

title: Prove formali

- Dimostrazione matematica di un programma: alternativa (~ accademica) al testing
    - Annotazione del programma con asserzioni matematiche: comportamento atteso
    - Propriet√† valide per i vari costrutti del programma
    - Spesso per *linguaggi funzionali* (privi di effetti collaterali)
- Prova che post-condizioni verificate, se:
    - Precondizioni verificate
    - Programma termina
- Dimostrazioni automatiche
    - Se a mano ‚Üí errori (pi√π che nel programma?)

---

title: Revisione del software

- Analisi del codice (o pseudocodice) per capirne le caratteristiche e le funzionalit√†
- **Code walk-through**
    - Selezione porzioni di codice e valori di input
    - Simulazione su carta comportamento del sistema
- **Code inspection**, pi√π formale e focalizzato
    - Uso di variabili non inizializzate
    - Loop infiniti
    - Letture di porzioni di memoria non allocata
    - Rilascio improprio della memoria

---

title: Testing

> Le operazioni di testing possono individuare la presenza di errori nel software ma non ne possono dimostrare la correttezza. *(E. Dijkstra)*

> Eseguire un programma con l'intento di trovare errori. *(Glen Myers, ‚ÄúThe art of Software Testing‚Äù)*

- Verificare sistema in un insieme abbastanza ampio di casi... ‚Üí plausibile comportamento analogo anche nelle restanti situazioni

---

title: Classificazione dei test
figure: images/dev/v-model.png
class: large-figure

- Tipi di test
    - **White box** (*in the small*)
    - **Black box** (*in the large*)
- Livelli di test
    - *Unit test*
    - *Integration test*
    - *System test*
- Ripetizione di test
    - *Regression test*

---

title: Testabilit√†

- Qualit√† software che facilitano rilevazione errori
    - **Osservabilit√†** ‚Äì Disponibili i risultati dei test
    - **Controllabilit√†** ‚Äì Possibilit√† di impostare ingressi e stato del programma prima di eseguire un test
    - **Decomponibilit√†** ‚Äì Programma diviso in parti che possono essere testate individualmente
    - **Comprensibilit√†** ‚Äì Si capisce il comportamento corretto (desiderato) del programma
- ‚Üí Sviluppo per testabilit√†

---

title: White-box testing
class: segue dark

---

title: White-box testing

- Test basati sulla conoscenza della struttura interna del codice
- Un errore non pu√≤ essere scoperto se la parte di codice che lo contiene non viene mai eseguita
- **Statement test**
    - Insieme di test T tali che, eseguendo su tutti i casi di T il programma P, ogni istruzione di P venga eseguita almeno una volta (test utopia?)
    - **Branch test** (copertura delle decisioni)
    - **Branch & condition test** (‚Ä¶ condizioni)

---

title: Basic path testing

- Scelto insieme minimo di percorsi per coprire tutte le istruzioni e condizioni (*white box*)
    - Tracciare diagramma di flusso
    - Astrarre il diagramma in un grafo di flusso
    - Complessit√† ciclomatica `n` = metrica di test
    - Trovare `n` casi di test che seguono ciascun cammino indipendente
- Cammino: sequenza di comandi, da inizio a fine
- Cammino indipendente: aggiunge almeno una nuova istruzione rispetto ai cammini gi√† identificati

---

title: Diagramma di flusso
figure: images/dev/flow-chart.png
class: large-figure

code: Python

    def f():
        // entry
        while a:
            x()
            if b:
                if c: y()
                else z()
                # p
            else:
                 v()
                 w()
            # q
        # exit: r

---

title: Grafo di flusso
figure: images/dev/flow-graph.png
class: large-figure

- Piccola astrazione rispetto a diagramma di flusso
- **Complessit√† ciclomatica**, dalla teoria dei grafi:
    - Numero di possibili cammini indipendenti, o...
    - Numero di regioni del grafo di flusso, o...
    - Numero di nodi predicato + 1 <br> &nbsp;
- `A, r`
- `A, X, B, C, Y, p, q, A, r`
- `A, X, B, C, Z, p, q, A, r`
- `A, X, B, V, W, q, A, r`

---

title: Black box testing
class: segue dark

---

title: Black box testing

- Sistema = scatola nera; si verificano le corrispondenze di input e output
    - White-box testing: impossibile per grandi sistemi
    - Test case scelti in base alle specifiche dei requisiti
- Desiderata: trovare errori...
    - Funzionali: otteniamo i risultati attesi per dati input di un metodo?
    - Interfaccia: dati passati correttamente tra i metodi?
    - Efficienza: il metodo √® abbastanza veloce?

---

title: Partizioni d‚Äôequivalenza

- Partizionamento ingressi in **classi di equivalenza**
    - Irrealistico testare tutti i possibili ingressi (es. `sqrt`)
    - Ipotesi: sufficiente testare un solo caso per classe
    - Si includono casi limite e valori non validi
    - Precondizioni: riducono il numero di casi di test

code: Python

    def swap_elements(v: list, i: int, j: int):
        '''
        Exchange element i and j in list v
        v: empty, one element, more elements
        i, j: one or both indexes out of range... or both in range: i < j, i > j, i = j
        '''
        # ...

---

title: Regression testing

- Scopo: trovare errori di regressione
    - Errori in un programma che prima era corretto, ed √® stato modificato di recente
    - Un errore di regressione √® un errore che prima non c‚Äôera
- Dopo la modifica di una parte `P` nel programma `Q`
    - Testare che la parte `P` funzioni correttamente
    - Testare che l‚Äôintero programma `Q` non sia stato danneggiato dalla modifica

---

title: Collaudo in Python
class: segue dark

---

title: Come collaudare il codice?

- Usare un *debugger* per valutare espressioni in fase di esecuzione
    - Si pu√≤ decidere cosa valutare a seconda del flusso di esecuzione e dei valori generati, senza ricompilare
- Istruzioni di *stampa* all'interno del programma
    - Valore di espressioni scritto a console o su file di log
- Entrambi gli stili, scarsamente *automatizzati*
    - Necessit√† di intervento attivo durante i test
    - Giudizio dei risultati da parte dell'utente
    - Quali valori analizzare? Sono coerenti?
- Scarsamente *componibili*
    - Difficile controllare molte espressioni nel debugger
    - "*Scroll blindness*": troppe istruzioni di stampa ‚áí codice poco leggibile

---

title: Libreria unittest

- I test `unittest` non richiedono continuo intervento o giudizio da parte dell'utente
- Facile eseguire molti test assieme, su un certo progetto
- Come definire un test?
    - Creare una sottoclasse di `unittest.TestCase`
    - Scrivere metodi di test, denominati con prefisso `test`
    - Per controllare la validit√† di una espressione, usare `assertTrue(bool)`

---

title: Esempio di test

- Controllare che una pallina rimbalzi correttamente contro il bordo inferiore

code: Python

    import unittest

    class SimpleBallTest(unittest.TestCase):

        def test_bounce_down(self):
            b = Ball(300, 220)  # dx = 5, dy = 5
            b.move()
            self.assertTrue(b.rect() == (295, 215, 20, 20))

    if __name__ == '__main__':
        unittest.main()

---

title: Esecuzione dei test

- Meccanismi per definire i test da eseguire e organizzare i risultati
- Esecuzione di test dalla linea di comando
    - Inclusione dei test di un modulo, di una classe, o metodi di test specifici
    - Implementata anche una semplice forma di *test discovery*

code: cmd

    python -m unittest test_module1 test_module2
    python -m unittest test_module.TestClass
    python -m unittest test_module.TestClass.test_method
    python -m unittest discover

- Annotazione `@unittest.skip("reason for skipping")`
    - Indica al framework di ignorare un certo metodo di test
    - Messaggio per documentare la decisione

---

title: Test parametrizzati

- Ripetere un test con diversi parametri
    - Un test case per ogni gruppo di parametri?
    - In alcune applicazioni, enorme quantit√† di test!
- Soluzione semplicistica: test contente un ciclo
    - Ad ogni iterazione, preparato un gruppo di parametri diversi
    - Eseguite le istruzioni da testare sui nuovi parametri
    - Problema: il test si blocca al primo errore

---

title: Test parametrizzato, semplicistico

code: Python

    class ParamBallTest(unittest.TestCase):

        def test_move(self):
            test_values = ( (40, 80, 45, 85),
                            (40, 215, 45, 220),
                            (40, 220, 45, 215),
                            (295, 80, 300, 85),
                            (300, 80, 295, 85) )
            for param in test_values:
                x0, y0, x1, y1 = param
                b = Ball(x0, y0)
                b.move()
                self.assertTrue(b.rect() == (x1, y1, 20, 20))


---

title: Sotto-test, Python 3.4

- Eseguiti tutti i sottotest, anche se uno fallisce

code: Python

    class ParamBallTest(unittest.TestCase):

        def test_move(self):
            test_values = ()  # same values...

            for param in test_values:
                with self.subTest(param=param):
                    x0, y0, x1, y1 = param
                    b = Ball(x0, y0)
                    b.move()
                    self.assertTrue(b.rect() == (x1, y1, 20, 20))

---

title: Controllare le eccezioni ü§î

- Mestiere del programmatore
    - Codice che completa correttamente l'esecuzione nei casi normali...
    - Ma che anche in situazioni eccezionali mostra il comportamento atteso
- Come verificare che una eccezione attesa sia effettivamente sollevata?
    - Usare il metodo `assertRaises` direttamente, passando una funzione ed i parametri
    - Oppure creare un *contesto* con `with`
- Esempio: `Ball` solleva effettivamente una eccezione attesa?

code: Python

    def test_out_of_arena(self):
        with self.assertRaises(ValueError):
            b = Ball(-1, -1)

---

title: Fixture ü§î

- Due o pi√π test operano su insiemi di oggetti uguali o simili
    - Questa configurazione iniziale comune si definisce *fixture*
- Se ci sono diversi test con una fixture comune...
    - Aggiungere dei campi per le varie parti della fixture
    - Inizializzare questi campi, nel metodo `setUp`
    - Liberare evenutali risorse allocate, nel metodo `tearDown`
- Una volta creata la fixture, pu√≤ essere usata da tutti i test case
    - Aggiungere metodi di test alla classe
    - `setUp` e `tearDown` eseguiti prima e dopo ogni test

---

title: Esempio di fixture ü§î

- Numerosi metodi di test che operano su stessi dati iniziali
    - Esempio, una combinazione di palline in posizioni predefinite

code: Python

    class SimpleBallTest(unittest.TestCase):

        def setUp(self):
            self.b1 = Ball(80, 40)
            self.b2 = Ball(40, 80)
            self.b3 = Ball(120, 20)


---

title: Test suite ü§î

- Meccanismo per *raggruppare* logicamente dei test ed *eseguirli assieme*
- La classe `TestSuite` rappresenta una test suite
    - Lista di classi di test aggiunte con il metodo `addTest`
- La classe `TestRunner` rappresenta un esecutore di test
    - Per la console, si usa `TextTestRunner`, gi√† inclusa nel framework

code: Python

    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(SimpleBallTest))
    runner = unittest.TextTestRunner()
    runner.run(suit)


