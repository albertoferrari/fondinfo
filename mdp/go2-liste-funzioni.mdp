title: Liste e funzioni
subtitle: Introduzione alla programmazione
figure: images/fun/shopping-list.jpg

---

title: Slice
figure: images/fun/shopping-list.jpg

- Sequenza di elementi, dello stesso **tipo**
    - L'intera lista (*slice*) pu√≤ essere assegnata ad una variabile, cos√¨ diamo un **nome** alla lista
- I singoli elementi sono **numerati**
    - Gli indici partono da 0!
      
code: go

    toBuy := []string{"spam", "eggs", "beans"}
    
code: go

    rainfallData := []int{13, 24, 18, 15}
    
code: go

    resultsByMonth := make([]int, 12)  // 12 times 0

---

title: Accesso agli elementi
figure: images/fun/wile-coyote.png

- **Attenzione ad usare indici validi!**
    - *Lunghezza* attuale di una lista `s`: `len(s)`
    - Elementi *numerati* da `0` a `len(s)-1`

code: go

    toBuy := []string{"spam", "eggs", "beans", "bacon"}    
    n := len(toBuy)        // 4

    Println(toBuy[0])      // "spam"
    Println(toBuy[1])      // "eggs"
    Println(toBuy[n-1])    // "bacon"

    toBuy[1] = "ketchup"   // replace a value
    Println(toBuy[1])      // "ketchup"

---

title: Porzioni di lista
figure: images/fun/month-list.svg

- Selezione degli elementi tra...
    - il primo indice (*compreso*)...
    - ed il secondo indice (*escluso*)

code: go

    months := []string{"Jan", "Feb", "Mar",
                       "Apr", "May", "Jun", 
                       "Jul", "Aug", "Sep", 
                       "Oct", "Nov", "Dec"}    

    spring := months[2:5]       // [Mar Apr May]
    quart1 := months[:3]        // [Jan Feb Mar]
    quart4 := months[9:]        // [Oct Nov Dec]
    wholeYear := months[:]      // The whole list

---

title: Concatenazione, rimozione

code: go

    toBuy := []string{"spam", "eggs", "beans"}
    Println(toBuy)

    toBuy = append(toBuy, "bacon")          // add to the end
    Println(toBuy)

    moreStuff := []string{"sausage", "mushrooms"}
    toBuy = append(toBuy, moreStuff...)     // concatenation
    Println(toBuy)

    toBuy = append(toBuy[:2], toBuy[3:]...)  // remove val @ 2
    Println(toBuy)

>

<https://github.com/golang/go/wiki/SliceTricks>

---

title: Stringhe e liste

- **`Join`** e **`Split`**, da lista a stringa e viceversa
    - Nel package *`strings`*

code: go

    someDays := []string{"tue", "thu", "sat"}
    someTxt := strings.Join(someDays, "|")
    // a single string: "tue|thu|sat"

    otherTxt := "mon|wed|fri|sun"
    otherDays := strings.Split(otherTxt, "|")
    // a list of strings: {"mon", "wed", "fri", "sun"}

---

title: Cicli su liste: for

code: go

    shoppingList := []string{"spam", "eggs", "bacon", "ketchup"}
        
    Println("Your shopping list contains:")

    for _, value := range shoppingList {
        fmt.Println(value)
    }
    // for index, value := range shoppingList {
    //    fmt.Println(index, value)
    // }

- Ad ogni iterazione, a `value` √® assegnato un diverso elemento della lista `shoppingList`
- `index` e/o `value` possono essere omessi (sostituiti con `_`)

---

title: Cicli su stringhe: for

- Si pu√≤ usare un ciclo `for` su qualsiasi sequenza
- Anche su *stringa*: sequenza *immutabile* di caratteri (UTF-8)

code: go

    for index, value := range "Hello, üåê!" {
        fmt.Println(index, value)
    }

    for _, x := range "Hello, üåê!" {
        fmt.Printf("%c  ", x)  // in package fmt
        fmt.Printf("%d\n", x)  // https://golang.org/pkg/fmt/
    }

---

title: Cicli su intervalli
figure: images/algo/sum10.svg

code: go

    // Add up numbers from 1 to 10
       
    total := 0
    for i := 1; i < 11; i++ {
        total += i
    }
    
    // total := 0
    // i := 1
    // for i < 11 {
    //     total = total + i
    //     i = i + 1
    // }
    
---

title: Sequenza di quadrati
figure: images/misc/red-squares.png

code: go

    InitCanvas(Size{300, 300})

    for i := 0; i < 5; i++ {
        x := i * 40
        y := x
        red := i * 60
        DrawRect(Color{red, 0, 0}, Rect{x, y, 140, 140})
    }

---

title: Formattazione di stampa

- `fmt.Printf`, in package `fmt`
    - Primo parametro: stringa di formato
    - Segnaposto (`%`) per incorporare i parametri successivi
    - Usare `\n` per andare a capo

code: go

    fmt.Printf("%2d", 3)     // " 3", int, width 2
    fmt.Printf("%6.2f", 7.3) // "  7.30", float, width 6, precision 2
    fmt.Printf("%d", 'üåê')   // "127760", code
    fmt.Printf("%c", 'üåê')   // "üåê", char
    fmt.Printf("%s", "hi!")   // "hi!", string

---

title: Cicli e annidamento
figure: images/fun/multiplication-table.jpg

code: go

    max := 10
    y := ParseInt(Prompt("Insert a value: "))
    for x := 1; x <= max; x++ {
        Println(x * y)
        // fmt.Printf("%4d", x * y)
    }

code: go

    max := 10
    for y := 1; y <= max; y++ {
        for x := 1; x <= max; x++ {
            fmt.Printf("%4d", x * y)
        }
        Println()
    }
    
---

title: Funzioni
class: segue dark

---

title: Definizione di funzioni
figure: images/fun/function.png

- Operatore, applicato a operandi, per ottenere un risultato
    - **`func`** per definire una funzione
    - **`return`** per terminare la funzione e restituire un risultato
- Esecuzione di una f.: nuovo *spazio di nomi*
    - Param. e var. hanno **ambito locale**
    - Non visibili nel resto del programma
    - Nomi uguali, definiti altrove, restano distinti

code: go

    func Hypotenuse(a, b float64) float64 {
        c := math.Sqrt(a * a + b * b)
        return c
    }

---

title: Chiamata di funzioni

- **`func`** definisce una funzione, ma non la esegue!
- Bisogna *chiamarla*
    - **Parametri formali**: nomi usati nella *definizione*
    - **Parametri effettivi**: oggetti passati alla funz.
- Parametri passati ‚Äú*per valore*‚Äù
    - Variabili all'esterno: non vengono modificate
    
code: go

    func main() {
        side1 := ParseFloat(Prompt("1st side? "))
        side2 := ParseFloat(Prompt("2st side? "))
        side3 := Hypotenuse(side1, side2)
        Println("3rd side: ", side3)
    }
    
---

title: Effetti collaterali

- Modifica di oggetti passati come parametri o variabili globali, operazioni di lettura/scrittura...
- Annullano la **trasparenza referenziale**
    - Impossibile semplificare, sostituendo una chiamata a funzione col suo valore di ritorno (es. presenti operazioni di I/O)
- Rendono la funzione **non idempotente**
    - Chiamata pi√π volte, con gli stessi parametri, restituisce risultati diversi
- ‚Üí Difficile fare verifiche matematiche
    - `z := f(Sqrt(2), Sqrt(2))`
    - `s := Sqrt(2)` <br> `z := f(s, s)`

---

title: Funzioni non idempotenti

- Esempio di semplificazione
    - `p := rq(x) + rq(y) * (rq(x) ‚Äì rq(x))`
    - `p := rq(x) + rq(y) * (0)`
    - `p := rq(x) + 0`
    - `p := rq(x)`
- Ma se `rq` ha effetti collaterali, non si pu√≤!

code: go

    var baseValue = 0  // global variable

    func rq(x int) int {
        baseValue++
        return x + baseValue
    }

>

Se `x, y = 3, 4`, ad esempio, i due risultati sono `-2` e `4`

---

title: Animazione

code: go

    var image = LoadImage("ball.png")
    var x = 50

    func update() {
        FillCanvas(Color{255, 255, 255})  // Draw background        
        DrawImage(image, Point{x, 50})    // Draw foreground
        x = (x + 5) % 320                 // Update ball's position
    }

    func main() {
        InitCanvas(Size{320, 240})
        MainLoop(update, 1000 / 30)    // Call update 30 times/second
    }

---

title: Eventi della tastiera

code: go

    func keydown(code string) {
        Println("Key pressed: ", code)
    }
    func keyup(code string) {
        Println("Key released: ", code)
    }
    func main() {
        HandleKeyboard(keydown, keyup)
    }

>

<https://developer.mozilla.org/es/docs/Web/API/KeyboardEvent/code>

---

title: Esercizi
class: segue dark

---

title: 2.1 Conteggio cifre
figure: images/misc/numbers.jpg

- Chiedere una riga di testo all'utente
- Contare il numero complessivo di cifre presenti (da `'0'` a `'9'`)
- Valutare anche la somma di tutte le singole cifre trovate

>

Usare un ciclo `for` sulla stringa (sequenza di caratteri)

---

title: 2.2 Array, precalcolo
figure: images/misc/sin-cos.png

- Riempire una lista con i valori di `sin`
    - 360 elementi, indice `x` tra 0 e 359
- Poi, ciclicamente...
	- Chiedere un angolo all'utente
	- Visualizzare il corrispondente valore precalcolato del seno

>

`math.Sin` opera su radianti

Calcolare `math.Sin(x * math.Pi / 180)`, anzich√® `math.Sin(x)`

---

title: 2.3 Area di un'ellisse
figure: images/misc/ellipse.svg

- Definire una *funzione* `EllipseArea` che:
    - Riceve come *parametri* i semiassi di una ellisse: `a`, `b`
    - Restituisce come risultato l'area dell'ellisse: `œÄ‚ãÖa‚ãÖb`
- Definire una *funzione* `main` che:
    - Chiede all'utente due valori
    - Invoca la funzione `EllipseArea` con questi parametri
    - Stampa il risultato ottenuto

---

title: 2.4 Cerchi concentrici
figure: images/misc/red-circles.png

- Chiedere all'utente il numero di cerchi da disegnare
- Disegnare i cerchi con raggio decrescente, ma tutti con lo stesso centro
- Far variare il colore dei cerchi
	  - Dal rosso del livello pi√π esterno
	  - Fino al nero del livello pi√π interno

>

Cominciare a disegnare un grosso cerchio rosso

Poi, inserire l'operazione di disegno un ciclo, togliendo ad ogni passo `10` (p.es.) al raggio e al livello di rosso

Infine, determinare automaticamente, prima del ciclo, le variazioni migliori per raggio e colore

---

title: 2.5 Movimento orizzontale
figure: images/misc/street-fighter.jpg

- Mostrare una pallina che si muove in orizzontale
- La pallina rimbalza sui bordi
    - Memorizzare in una variabile `dx` lo spostamento orizzontale da effettuare ad ogni ciclo
    - Cambiare segno a `dx` quando `x < 0` oppure `x + w > screenWidth`

---

title: 2.6 Movimento a serpentina
figure: images/misc/science-of-spaceships.jpg

- Mostrare una pallina che si muove a serpentina
- Partire dall'esercizio precedente
    - Al momento del rimbalzo, imporre un spostamento verticale
    - Fare in modo che, in ogni frame, lo spostamento sia solo orizzontale, o solo verticale, ma *non* diagonale

---

title: 2.7 Griglia di colori (*)
figure: images/misc/color-grid.png images/oop/raster-tile.png

- Chiedere all'utente dei valori per `rows` e `cols`
- Mostrare una griglia di rettangoli di dimensione `rows√ócols`
- Partire da un rettangolo nero in alto a sinistra
- In orizzontale, aumentare gradatamente la componente di blu
- In verticale, aumentare gradatamente la componente di verde

>

Cominciare a creare una griglia di riquadri tutti neri, con due cicli `for` annidati

Lasciare tra i riquadri un piccolo margine

---

title: 2.8 Istogramma con barre orizzontali
figure: images/misc/histogram-rot.png

- Chiedere all'utente una lista di valori positivi
    - La lista termina quando l'utente inserisce il valore `0`
- Mostrare un istogramma
    - Larghezza di ciascuna barra proporzionale al valore corrispondente
    - La barra pi√π lunga occupa tutto lo spazio disponibile
    
---

title: 2.9 Spirale (*)
figure: images/misc/spiral-circles.png

- Mostrare l'*animazione* di un cerchio lungo una spirale
- Ruotare attorno ad un centro fisso `(xc, yc)`
- Amentare dist. `r` dal centro ad ogni passo
- Cancellare lo sfondo ad ogni passo
- Disegnare un cerchio sempre pi√π grande
- Dopo `n` passi, ricominciare daccapo

