title: Oggetti e grafica
subtitle: Introduzione alla programmazione
figure: images/oop/modules.png images/oop/pygame-logo.png

---

title: Oggetto
figure: images/oop/basic-object.svg

- Rappresenta un *oggetto fisico* o un *concetto* del dominio
- Memorizza il suo **stato** interno in *campi privati*
    - *Incapsulamento (black box)*
- Offre un insieme di **servizi**, come *metodi pubblici*
    - Realizza un *tipo di dato astratto (ADT)*

---

title: Classi ed oggetti
figure: images/oop/cookie-cutter.png

- Ogni *oggetto* ha una **classe** di origine
    - La classe dà la stessa forma iniziale (campi e metodi) a tutti i suoi oggetti
- Ma ogni *oggetto* ha la sua **identità** 
    - Stato e locazione in memoria distinti da quelli di altri oggetti
    - Sia instanze di classi diverse che della stessa classe

---

title: Definizione della classe
figure: images/oop/ball-object.svg images/oop/ball-uml.svg
figcaption: Class diagram UML

- **Incapsulamento** dei dati: *convenzione* sui nomi
    - Prefisso `_` per i nomi dei *campi privati*

> Siamo tutti adulti consenzienti. *(GvR)*
      
code: python

    class Ball:

        def __init__(self, x: int, y: int):
            self._x = x
            self._y = y
            self._dx = 5
            self._dy = 5
            self._w = 20
            self._h = 20
        # ...

---

title: Costruzione oggetti
figure: images/oop/bob-builder.jpg

- **`__init__`**: metodo *inizializzatore*
    - Eseguito automaticamente alla creazione di un oggetto
    - *Instantiation is initialization*
- **`self`**: primo parametro di tutti i metodi
    - Non bisogna passare un valore esplicito
    - Assegnato l'oggetto di cui si chiama il metodo
    - Permette ai metodi di accedere ai campi

code: python

    ball = Ball(40, 80)  # Allocation and initialization

---

title: Metodi

- Espongono *servizi* ad altri oggetti

code: python

    ARENA_W, ARENA_H = 320, 240

    class Ball:
        # ...
        def move(self):
            if not (0 <= self._x + self._dx <= ARENA_W - self._w):
                self._dx = -self._dx
            if not (0 <= self._y + self._dy <= ARENA_H - self._h):
                self._dy = -self._dy
            self._x += self._dx
            self._y += self._dy

        def position(self) -> (int, int, int, int):
            return self._x, self._y, self._w, self._h

---

title: Applicazione

code: python

    from p3_ball import Ball  # Ball is defined in p3_ball.py

    # Create two objects, instances of the Ball class
    b1 = Ball(40, 80)
    b2 = Ball(80, 40)

    for i in range(25):
        print('Ball 1 @', b1.position())
        print('Ball 2 @', b2.position())
        b1.move()
        b2.move()

---

title: Il primo parametro, self

- Il primo parametro di ogni metodo si chiama `self` (per convenzione)
- L'oggetto, di cui viene invocato il metodo, viene assegnato come valore di `self`
- In Python, una chiamata a metodo è interpretata così:

code: python

    b1 = Ball(40, 80)
    b1.move()
    
code: python

    b1 = Ball(40, 80)  # also, automatically call
                       # Ball.__init__(b1, 40, 80)
    Ball.move(b1)

**Nota.** Meglio usare la prima notazione, che evidenzia l'*oggetto* anzichè la classe!

---

title: Animazione di due palline

code: python

    import game2d as g2d
    from p3_ball import Ball, ARENA_W, ARENA_H

    def update():
        g2d.fill_canvas((255, 255, 255))  # BG
        b1.move()
        b2.move()
        g2d.draw_rect((127, 127, 127), b1.position())  # FG
        g2d.draw_rect((127, 127, 127), b2.position())  # FG

    b1 = Ball(40, 80)
    b2 = Ball(80, 40)
    g2d.init_canvas((ARENA_W, ARENA_H))
    g2d.main_loop(update, 1000 // 30)  # Millis

---

title: Animazione lista di palline

code: python

    import game2d as g2d
    from p3_ball import Ball, ARENA_W, ARENA_H

    def update():
        g2d.fill_canvas((255, 255, 255))  # BG
        for b in balls:
            b.move()
            g2d.draw_rect((127, 127, 127), b.position())  # FG

    balls = [Ball(40, 80), Ball(80, 40), Ball(120, 120)]
    g2d.init_canvas((ARENA_W, ARENA_H))
    g2d.main_loop(update, 1000 // 30)  # Millis

---

title: Composizione
figure: images/oop/ball-arena.svg

- Associazione di tipo **has-a**, **part-of** tra oggetti
    - Una *arena* può *contenere* diverse *palline*

code: python

    class BallArena:  # ...
        def __init__(self):
            self._balls = []
        def add(self, b: Ball):
            self._balls.append(b)
        def move_all(self):
            for b in self._balls:
                b.move()

code: python

    arena = BallArena()
    arena.add(Ball(40, 80)); arena.add(Ball(80, 40)) # ...
    arena.move_all()

---

title: Livelli di astrazione
class: segue dark backdrop

---

title: Livelli di astrazione
figure: images/oop/inheritance.png

- Relazione **is-a** tra classi
    - Specializzazione, sotto-insieme
- Es. classificazioni in biologia
    - I *vertebrati* sono una sottoclasse degli *animali*
    - I *mammiferi* sono una sottoclasse dei *vertebrati*
    - I *felini* sono una sottoclasse dei *mammiferi*
    - I *gatti* sono una sottoclasse dei *felini*
- Ogni sottoclasse...
    - Eredita le caratteristiche della classe base
    - Ma introduce delle specializzazioni

---

title: Livelli di astrazione
figure: images/oop/actors.svg

- `Actor`: *classe base*
    - Dichiara un metodo `move` ecc.
- Vari attori: *classi derivate*
    - Ereditano caratteristiche di `Actor`
    - Definiscono comportamenti specifici

code: python

    class Actor:
        def move(self):
            raise NotImplementedError("Abstract method")

---

title: Generalizzazione e riuso

code: python

    class Arena:  # ...
        def __init__(self, w, h):
            self._w, self._h = w, h
            self._actors = []
        def add(self, a: Actor):
            self._actors.append(a)
        def move_all(self):
            for a in self._actors:
                a.move()
        def size(self):
            return self._w, self._h

- Codice dipendente dalle classi più astratte, più in alto nella gerarchia
    - `Arena` riutilizzabile creando nuove classi derivate di `Actor`

---

title: Sostituzione
figure: images/oop/actor.svg

code: python

    arena.add(Ball(40, 80))
    arena.add(Ghost(120, 40)) # ...
    arena.move_all()

- Principio di **sostituzione** di Liskov
    - Si può sempre usare un oggetto di una *classe derivata*, al posto di uno della *classe base*
- Relazione *has-a* tra un oggetto `Arena` e gli oggetti `Actor` che contiene
- Relazione *is-a* tra classi derivate (`Ball` e `Ghost`) e classe base (`Actor`)

---

title: Ereditarietà e polimorfismo

- **Classe derivata**
    - Eredita le caratteristiche della classe base
    - Può definire nuove caratteristiche specifiche
- **Metodo polimorfo**
    - Ridefinito nelle classi derivate
    - Attori diversi possono muoversi in modo diverso

code: python

    class Ghost(Actor):  # ...
        def move(self):
            dx = random.choice([-5, 0, 5])
            dy = random.choice([-5, 0, 5])
            self._x = (self._x + dx) % ARENA_W
            self._y = (self._y + dy) % ARENA_H

---

title: Attori e arena

code: python

    class Ghost(Actor):
    
        def __init__(self, arena, x, y):
            self._x, self._y = x, y
            self._arena = arena  # save a ref to the arena
            arena.add(self)      # register yourself into the arena
            
        def move(self):
            dx = random.choice([-5, 0, 5])
            dy = random.choice([-5, 0, 5])
            arena_w, arena_h = self._arena.size()  # self._arena!
            self._x = (self._x + dx) % arena_w
            self._y = (self._y + dy) % arena_h

---

title: Animazione dei personaggi
class: segue dark

---

title:  Rimbalzi nel browser
figure: images/oop/bounce.png

code: python

    import game2d as g2d
    from p3_bounce import Arena, Ball, Ghost, Turtle

    def update():
        arena.move_all()  # Game logic
        g2d.fill_canvas((255, 255, 255))  # Background
        for a in arena.actors():
            # Foreground; cut an area from a larger image
            g2d.draw_image_clip(sprites, a.position(), a.symbol())

    arena = Arena(320, 240)
    Ball(arena, 40, 80);  Ball(arena, 80, 40);  Ghost(arena, 120, 80)
    turtle = Turtle(arena, 80, 80)  # each actor knows the arena
    g2d.init_canvas(arena.size())
    sprites = g2d.load_image("sprites.png")
    g2d.main_loop(update, 1000 // 30)  # Millis

---

title:  Controllo da tastiera
figure: images/oop/bounce.png

code: python

    def keydown(code):
        # print(code)
        if code == "ArrowUp":
            turtle.go_up()
        elif code == "ArrowDown":
            turtle.go_down()
        elif code == "ArrowLeft":
            turtle.go_left()
        elif code == "ArrowRight":
            turtle.go_right()

    def keyup(code):
        turtle.stay()

    g2d.handle_keyboard(keydown, keyup)

---

title: Collisioni
figure: images/oop/collision.svg images/oop/reflection.png

- Molti algoritmi di *collision detection*
    - Casi semplici: intersezione di rettangoli
- In caso di collisione, `Arena`...
    - Invoca il metodo `collide` di entrambi gli oggetti
    - Collisione tra personaggio `self` e personaggio `other` (secondo parametro)
- Possibili errori nel calcolo del rimbalzo
    - Di solito accettabili
    - Altrimenti, applicare correzioni
    
---

title: Urti delle palline

code: python

    class Ball(Actor):
        # ...
        def collide(self, other):
            if not isinstance(other, Ghost):
                x, y, w, h = other.position()
                if x < self._x:
                    self._dx = self.SPEED
                else:
                    self._dx = -self.SPEED
                # ... same for y

- `isinstance(obj, cls)`
    - Controlla se l'oggetto `obj` è istanza della classe `cls`
    - ... o di una sua sottoclasse
    - Restituisce un `bool`

---

title: Proprietà (++)

- Permettono un accesso controllato allo stato

code: python

    class Ball:

        @property  # a getter for the pos property
        def pos(self) -> (int, int):
            return self._x, self._y

        # @pos.setter  # if you also really need a setter
        # def pos(self, val: (int, int)):
        #     self._x, self._y = val

code: python

    ball = Ball(40, 80)
    print('ball @', ball.pos)
    # ball.pos = (60, 20)   # with the setter, you could change the pos

---

title: Ciclo di vita di un oggetto (++)
figure: images/dev/garbage-truck.jpg

- Creazione di un oggetto: allocata memoria per tenere lo stato dell’oggetto
- In Python: variabile = riferimento ad un oggetto
    - *Oggetti*: *allocazione dinamica*, in memoria *heap*
    - *Variabili*: *allocazione automatica*, in memoria *stack*
- Oggetto non più associato a nessuna variabile: necessario liberare memoria
- **Garbage collection**: gestione automatica della restituzione di memoria

---

title: Garbage collection (++)

- Vantaggi
    - Non è possibile dimenticare di liberare la memoria (*memory leak*)
    - Non è possibile liberare della memoria che dovrà essere utilizzata in seguito (*dangling pointer*)
- Svantaggi
    - Decide autonomamente quando liberare la memoria
    - Liberare e compattare la memoria richiede del calcolo
- Diversi algoritmi
    - *Reference counting*: idea di base, ma cicli…
    - *Mark & sweep*: parte da riferimenti locali/globali, marca oggetti raggiungibili
    - *Generational garbage collection*: controlla spesso oggetti recenti

---

title: PyGame
class: segue dark

---

title: Grafica con PyGame (++)
figure: images/oop/pygame-logo.png images/oop/pygame-loop.png

- Libreria per giochi 2D
- Grafica e suoni
- Su *SDL* - Simple DirectMedia Layer
- Semplice e veloce
- Open-source
- Multi-piattaforma

>

[pygame.org](http://www.pygame.org/)

---

title:  Disegno con PyGame (++)
figure: images/oop/pygame-logo.png images/oop/raster-coord.png
figcaption: → pygame.org/docs

code: python

    import pygame
    pygame.init()                     # Prepare pygame
    screen = pygame.display.set_mode((640, 480)) # (w, h)
    screen.fill((255, 255, 255))      # BG (Red, Green Blue)

    # Yellow rectangle, left=50, top=75, w=90, h=50
    pygame.draw.rect(screen, (255, 255, 0), (50, 75, 90, 50))

    # Blue circle, center=(300, 50), radius=20
    pygame.draw.circle(screen, (0, 0, 255), (300, 50), 20)

    pygame.display.flip()             # Update the screen
    while pygame.event.wait().type != pygame.QUIT:
        pass
    pygame.quit()

---

title: Animazione con PyGame (++)

code: python

    import pygame
    pygame.init()                     # Prepare pygame
    screen = pygame.display.set_mode((320, 240))
    clock = pygame.time.Clock()       # To set game speed
    image = pygame.image.load('ball.png')

    x = 50; playing = True
    while playing:
        for e in pygame.event.get():  # Handle events: mouse, keyb etc.
            if e.type == pygame.QUIT: playing = False
        screen.fill((255, 255, 255))  # Draw background        
        screen.blit(image, (x, 50))   # Draw foreground
        x = (x + 5) % 320             # Update ball's position
        pygame.display.flip()         # Surface ready, show it!
        clock.tick(30)                # Wait 1/30 seconds
    pygame.quit()                     # Close the window

---

title: Ciclo di animazione (++)

code: python

    import pygame
    pygame.init()                     # Prepare pygame
    screen = pygame.display.set_mode((320, 240))
    clock = pygame.time.Clock()       # To set game speed
    image = pygame.image.load('ball.png')

    x = 50; playing = True
    while playing:
        for e in pygame.event.get():  # Handle events: mouse, keyb etc.
            if e.type == pygame.QUIT: playing = False
        screen.fill((255, 255, 255))  # Draw background        
        screen.blit(image, (x, 50))   # Draw foreground
        x = (x + 5) % 320             # Update ball's position
        pygame.display.flip()         # Surface ready, show it!
        clock.tick(30)                # Wait 1/30 seconds
    pygame.quit()                     # Close the window

---

title:  Rimbalzi in PyGame (++)
figure: images/oop/bounce.png

code: python

    arena = Arena(320, 240)
    Ball(arena, 40, 80); Ball(arena, 80, 40); 
    Ghost(arena, 120, 80) # ...
    # a map from an actor type to an image
    images = {Ball: pygame.image.load('ball.png'),
              Ghost: pygame.image.load('ghost.png')}
    screen = pygame.display.set_mode(arena.size())
    playing = True
    while playing:
        # Handle events here!

        arena.move_all()             # Game logic
        screen.fill((255, 255, 255)) # Background
        for a in arena.actors():
            x, y, w, h = a.position()
            img = images[type(a)]
            screen.blit(img, (x, y)) # Foreground [...]

---

title:  Tastiera e mouse (++)

code: python

    from pygame.locals import (KEYDOWN, KEYUP, K_RIGHT, K_d,
        MOUSEBUTTONDOWN, MOUSEBUTTONUP, MOUSEMOTION)
    # ...
    for e in pygame.event.get():
        # print(e)
        if e.type == KEYDOWN and e.key in (K_RIGHT, K_d):
            print('Right arrow (or D) pressed')
        elif e.type == KEYUP and e.key in (K_RIGHT, K_d):
            print('Right arrow (or D) released')
        elif e.type == MOUSEBUTTONDOWN and e.button == 1:
            print('Left mouse button pressed')
        elif e.type == MOUSEBUTTONUP and e.button == 1:
            print('Left mouse button released')
        elif e.type == MOUSEMOTION:
            print 'Mouse at (%d, %d)' % e.pos

---

title: Testo e suoni (++)

code: python

    # Red (anti-aliased) text, centered, rotated 30° ccw
    font = pygame.font.SysFont('arial', 48)
    surface = font.render('Game over!', True, (255, 0, 0))
    surface = pygame.transform.rotate(surface, 30)
    x = (screen.get_width() - surface.get_width()) // 2
    y = (screen.get_height() - surface.get_height()) // 2
    screen.blit(surface, (x, y))  # surface ~ image

code: python

    # Some sound
    pick_up_sound = pygame.mixer.Sound('pickup.wav')
    pick_up_sound.play()  # play(-1) to loop, then stop()

---

title: Esercizi
class: segue dark

---

title: 3.1 Ellisse
figure: images/misc/ellipse.svg

- Classe che modella un'ellisse
- Campi privati (parametri del costruttore)
    - Semiassi: `a, b`
- Metodi pubblici per ottenere...
    - Area: `π⋅a⋅b`
    - Distanza focale: `2⋅√|a^^2^^ - b^^2^^|`
- Nel corpo principale del programma...
    - Creare un oggetto con dati forniti dall'utente
    - Visualizzare area e distanza focale dell'ellisse

---

title: 3.2 Animazione di una pallina
figure: images/misc/street-fighter.jpg

- Partire dalla classe `Ball` vista a lezione
- Eseguire l'animazione
    - Per ogni frame, chiamare il metodo `move` della pallina
    - Rappresentare un rettangolo o un cerchio nella posizione aggiornata della pallina
- Modificare però il metodo `move`
    - La pallina si sposta sempre di pochi pixel in orizzontale
    - La pallina non si sposta verticalmente
    - Se esce dal bordo destro, ricompare al bordo sinistro e viceversa

---

title: 3.3 Classe degli invasori spaziali
figure: images/misc/invaders-path.jpg

- Creare una classe `Invader`, che contenga i dati ed il comportamento dell'alieno
    - Campi privati: `x`, `y`, `dx`
    - Metodo `move` per avanzare
    - Metodo `position` per ottenere la posizione attuale
- Istanziare un oggetto `Invader` e farlo muovere sullo schermo
    - Chiamare il metodo `move` ad ogni ciclo
    - Visualizzare un rettangolo nella posizione corrispondente

>

Definire nella classe delle opportune costanti

---

title: 3.4 Lista di invasori
figure: images/misc/invaders-path.jpg

- Riusare la classe `Invader` (es. 3.3)
- Creare inizialmente una lista di alieni, con posizioni di partenza diverse
    - Memorizzare la posizione di partenza di ciascun alieno in opportuni campi privati
    - Lasciare a ciascun alieno uno spazio orizzontale di movimento di 150 pixel, a destra della posizione di partenza
- Farli avanzare tutti ad ogni ciclo, chiamando il metodo `move` di ciascuno di essi

