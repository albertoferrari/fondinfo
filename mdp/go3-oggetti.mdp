title: Oggetti e grafica
subtitle: Introduzione alla programmazione
figure: images/oop/modules.png

---

title: Puntatori
figure: images/oop/pointer.png

- Ogni dato in memoria ha un indirizzo
- Variabile puntatore per memorizzarlo
- *Referenziazione*: `&` per indirizzo di un dato
- *Dereferenziazione*: `*` per accesso a dato puntato

code: go

    var i int8 = 56  // a byte
    var p *int8      // a ptr to some byte (uninitialized)
    p = &i           // now p points to i
    *p = *p + 1      // i++
    Println(*p, i)
    p = nil          // ptr to nothing

>

Come in *C*, ma *senza* “aritmetica”

---

title: Oggetto
figure: images/oop/basic-object.svg

- Rappresenta un *oggetto fisico* o un *concetto* del dominio
- Memorizza il suo **stato** interno in *campi privati*
    - *Incapsulamento (black box)*
- Offre un insieme di **servizi**, come *metodi pubblici*
    - Realizza un *tipo di dato astratto (ADT)*

---

title: Classi ed oggetti
figure: images/oop/cookie-cutter.png

- Ogni *oggetto* ha una **classe** di origine
    - La classe dà la stessa forma iniziale (campi e metodi) a tutti i suoi oggetti
- Ma ogni *oggetto* ha la sua **identità** 
    - Stato e locazione in memoria distinti da quelli di altri oggetti
    - Sia instanze di classi diverse che della stessa classe

---

title: Definizione della classe
figure: images/oop/ball-object.svg images/oop/ball-uml.svg
figcaption: Class diagram UML

- **Incapsulamento** dei dati
    - Campi in minuscolo: visibilità limitata al modulo
    - Funzione costruttore in maiuscolo: esportata
      
code: go

    type Ball struct {
	    x, y    int
	    w, h    int
	    dx, dy  int
    }

    func NewBall(x, y int) *Ball {
        b := &Ball{x, y, 20, 20, 5, 5}
        return b
    }

---

title: Costruzione oggetti
figure: images/oop/bob-builder.jpg

- **`NewBall`**: funzione *costruttore*
    - Invocata per creare un oggetto
    - *Instantiation is initialization*
    - Restituisce un puntatore all'oggetto

code: go

    ball := NewBall(40, 80)  // Allocation and initialization

---

title: Metodi

- Espongono *servizi* ad altri oggetti
- Bisogna indicare l'*oggetto ricevitore*, come puntatore

code: go

    var ArenaW, ArenaH = 160, 120

    func (b *Ball) Move() {
	    if !(0 <= b.x+b.dx && b.x+b.dx <= ArenaW-b.w) {
		    b.dx = -b.dx
	    }
	    if !(0 <= b.y+b.dy && b.y+b.dy <= ArenaH-b.h) {
		    b.dy = -b.dy
	    }
	    b.x += b.dx
	    b.y += b.dy
    }

---

title: Applicazione

code: go

    func (b *Ball) Position() Rect {
        return Rect{b.x, b.y, b.w, b.h}
    }

    func main() {
        // Create two objects, instances of the Ball class
        b1 := NewBall(40, 80)
        b2 := NewBall(80, 40)

        for i := 0; i < 25; i++ {
            Println("Ball 1 @", b1.Position())
            Println("Ball 2 @", b2.Position())
            b1.Move()
            b2.Move()
        }
    }

---

title: Animazione di due palline

code: go

    var b1 = NewBall(40, 80)
    var b2 = NewBall(80, 40)
    
    func update() {
        FillCanvas(Color{255, 255, 255})  // BG
        b1.Move()
        b2.Move()
        DrawPosition(Color{200, 100, 100}, b1.Position())  // FG
        DrawPosition(Color{100, 100, 200}, b2.Position())  // FG
    }
    
    func main() {
        InitCanvas(Size{ArenaW, ArenaH})
        MainLoop(update, 1000 / 30)
    }

---

title: Animazione lista di palline

code: go

    var balls = []*Ball{NewBall(40, 80), NewBall(80, 40)}

    func update() {
	    FillCanvas(Color{255, 255, 255}) // BG
	    for _, b := range balls {
		    b.Move()
		    DrawPosition(Color{100, 100, 100}, b.Position()) // FG
	    }
    }

    func main() {
	    InitCanvas(Size{ArenaW, ArenaH})
	    MainLoop(update, 1000/30) // Millis
    }

---

title: Composizione
figure: images/oop/ball-arena.svg

- Associazione **has-a**, **part-of** tra oggetti
    - Una arena *contiene* diverse palline

code: python

    type BallArena struct { balls []*Ball }
    func (a *BallArena) Add(b *Ball) {
        a.balls = append(a.balls, b)
    }
    func (a *BallArena) MoveAll() {
        for i, b := range a.balls {
            b.Move(); Println("Ball", i, b.Position())
        }
    }
    func main() {
        var arena = &BallArena{}
        arena.Add(NewBall(40, 80)); arena.Add(NewBall(80, 40))
        arena.MoveAll() // ...
    }

---

title: Interfacce
class: segue dark

---

title: Livelli di astrazione
figure: images/oop/inheritance.png

- Relazione **is-a** tra classi
    - Specializzazione, sotto-insieme
- Es. classificazioni in biologia
    - I *vertebrati* sono una sottoclasse degli *animali*
    - I *mammiferi* sono una sottoclasse dei *vertebrati*
    - I *felini* sono una sottoclasse dei *mammiferi*
    - I *gatti* sono una sottoclasse dei *felini*
- Ogni sottoclasse...
    - Eredita le caratteristiche della classe base
    - Ma introduce delle specializzazioni

---

title: Interfacce
figure: images/oop/actors.svg

- `Actor`: *interfaccia*
    - Dichiara un metodo `move` ecc.
- Vari attori: *classi implementazione*
    - Implementano caratteristiche di `Actor`
    - Definiscono comportamenti specifici

code: go

    type Actor interface {
        Move()
    }

---

title: Generalizzazione e riuso

code: python

    type Arena struct { actors []*Actor }
    func (a *Arena) Add(c *Actor) {
        a.actors = append(a.actors, c)
    }
    func (a *Arena) MoveAll() {
        for i, c := range a.actors {
            c.Move(); Println("Ball", i, c.Position())
        }
    }

- Codice dipendente dalle classi più astratte, più in alto nella gerarchia
    - `Arena` riutilizzabile creando nuove classi derivate di `Actor`

---

title: Sostituzione
figure: images/oop/actor.svg

code: python

    arena.Add(NewBall(40, 80))
    arena.Add(NewGhost(120, 40)) // ...
    arena.MoveAll()

- Principio di **sostituzione** di Liskov
    - Si può sempre usare un oggetto di una *classe implementazione*, al posto di uno della *interfaccia*
- Relazione *has-a* tra un oggetto `Arena` e gli oggetti `Actor` che contiene
- Relazione *is-a* tra classi implementazione (`Ball` e `Ghost`) e interfaccia (`Actor`)

---

title: Ereditarietà e polimorfismo

- **Classe implementazione**
    - Implementa le caratteristiche della interfaccia
    - Può definire nuove caratteristiche specifiche
- **Metodo polimorfo**
    - Definito in modo diverso nelle classi implementazione
    - Attori diversi possono muoversi in modo diverso

code: go

    type Ghost struct { x, y int }  // ...
    func (g *Ghost) Move() {
        dx := 5 * RandInt(-1, 1)
        dy := 5 * RandInt(-1, 1)
        g.x = (g.x + dx + ArenaW) % ArenaW
        g.y = (g.y + dy + ArenaH) % ArenaH
    }

---

title: Attori e arena

code: go

    type Ghost struct {
        arena *Arena
        x, y  int
    }
    func NewGhost(arena *Arena, x, y int) *Ghost {
        g := &Ghost{arena, x, y}  // save a ref to the arena
        arena.Add(g)              // register yourself into the arena
        return g
    }
    func (g *Ghost) Move() {
        dx := 5 * RandInt(-1, 1)
        dy := 5 * RandInt(-1, 1)
        as := g.arena.Size()      // ref to arena
        g.x = (g.x + dx + as.W) % as.W
        g.y = (g.y + dy + as.H) % as.H
    }

---

title: Animazione dei personaggi
class: segue dark

---

title:  Rimbalzi nel browser

code: go

    var sprites = LoadImage("sprites.png")
    var arena = NewArena(320, 240)
    var turtle = NewTurtle(arena, 80, 80)  // actor knows the arena
    func update() {
        arena.MoveAll()  // Game logic
        FillCanvas(Color{255, 255, 255})
        for _, a in arena.Actors() {
            // Cut an area from a larger image
            DrawImageClip(sprites, a.Position(), a.Symbol())
        }
    }
    func main() {
        NewGhost(arena, 120, 80); NewBall(arena, 40, 80) // ...
        InitCanvas(arena.Size())
        MainLoop(update, 1000 / 30)
    }
    
---

title:  Controllo da tastiera
figure: images/oop/bounce.png

code: python

    func keydown(code) {
        if code == "ArrowUp" { turtle.GoUp() }
        else if code == "ArrowDown" { turtle.GoDown() }
        else if code == "ArrowLeft" { turtle.GoLeft() }
        else if code == "ArrowRight" { turtle.GoRight() }
    }
    func keyup(code) {
        turtle.Stay()
    }
    func main() {
        // ...
        HandleKeyboard(keydown, keyup)
    }

---

title: Collisioni
figure: images/oop/collision.svg images/oop/reflection.png

- Molti algoritmi di *collision detection*
    - Casi semplici: intersezione di rettangoli
- In caso di collisione, `Arena`...
    - Invoca il metodo `collide` di entrambi gli oggetti
    - Collisione tra personaggio `self` e personaggio `other` (secondo parametro)
- Possibili errori nel calcolo del rimbalzo
    - Di solito accettabili
    - Altrimenti, applicare correzioni
    
---

title: Urti delle palline

code: python

    func (b *Ball) Collide(other Actor) {
	    _, ok := other.(*Ghost)
	    if !ok {
		    op := other.Position()
		    if op.X < b.x { b.dx = b.speed }
		    else { b.dx = -b.speed }
		    if op.Y < b.y { b.dy = b.speed } 
		    else { b.dy = -b.speed }
	    }
    }

- *Downcast*: `other.(*Ghost)`
    - Converte l'oggetto `other` come istanza di `Ghost`
    - Restituisce un riferimento a `Ghost` ed un `bool`

