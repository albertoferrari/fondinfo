title: Linguaggi formali
subtitle: Introduzione all'informatica
figure: images/comp/attack.jpg

---

title: Linguaggi formali
figure: images/comp/tangible.jpg

- Presenti in tutte le applicazioni
    - Linguaggi di programmazione
    - Linguaggi di marcatura (es. HTML, Latex)
    - Interazione uomo macchina (es. Google, Zork)
- Fondamentali in sw di sistema
    - Compilatori
    - Interpreti ‚Ä¶
- Paradigmatici nella teoria
    - Molti problemi riconducibili a quello dell'*appartenenza*: una stringa appartiene ad un linguaggio?

---

title: Alfabeti e stringhe

- Alfabeto `Œ£`: insieme di simboli
- Stringa `s`: sequenza di simboli di `Œ£`
    - `s ‚àà Œ£*`, insieme di tutte le stringhe
    - `Œµ`: stringa vuota
    - `|s|`: lunghezza della stringa `s`
- Linguaggio `L ‚äÜ Œ£*`
    - Sottoinsieme di tutte le stringhe possibili
    - Grammatica: regole formali per definire le ‚Äú*stringhe ben formate*‚Äù di L
- Esempio: numeri romani da 1 a 1000
    - Alfabeto `{I, V, X, L, C, D, M}` + regole...

---

title: Concatenazione di stringhe

- Operazione di concatenazione `‚Ä¢`
    - Propr. associativa: `(x ‚Ä¢ y) ‚Ä¢ z = x ‚Ä¢ (y ‚Ä¢ z)`
    - Non commutativa: `x ‚Ä¢ y ‚â† y ‚Ä¢ x`
    - `Œ£*` chiuso rispetto a `‚Ä¢: Œ£* x Œ£* ‚Üí Œ£*`
- Potenza
    - `x^^n^^ = x ‚Ä¢ x ‚Ä¢ x ‚Ä¢ x ‚Ä¶ (n volte)`
- Elemento neutro `Œµ`
    - Stringa vuota, `‚àÄ x ‚àà Œ£*, Œµ ‚Ä¢ x = x ‚Ä¢ Œµ = x`

>

`<Œ£*, ‚Ä¢, Œµ>`: monoide

---

title: Definizione di linguaggi

- Approccio **algebrico**: linguaggio costruito a partire da linguaggi pi√π elementari, con operazioni su linguaggi
- Approccio **generativo**: grammatica, regole per la generazione di stringhe appartenenti al linguaggio
- Approccio **riconoscitivo**: macchina astratta o algoritmo di riconoscimento, per decidere se una stringa appartiene o no al linguaggio

---

title: Espressioni regolari
class: segue dark

---

title: Operazioni su linguaggi

- `L~~1~~` ed `L~~2~~` linguaggi su `Œ£*` (due insiemi di stringhe)
- Unione: `L~~1~~ ‚à™ L~~2~~ = {x ‚àà Œ£* : x ‚àà L~~1~~ ‚à® x ‚àà L~~2~~}`
- Intersezione: `L~~1~~ ‚à© L~~2~~ = {x ‚àà Œ£* : x ‚àà L~~1~~ ‚àß x ‚àà L~~2~~}`
- Complementazione: `ÃÖL~~1~~ = {x ‚àà Œ£* : x ‚àâ L~~1~~}`

---

title: Concatenazione di linguaggi


- Concatenazione o prodotto:
    - `L~~1~~‚Ä¢L~~2~~ = {x ‚àà Œ£* : x = x~~1~~‚Ä¢x~~2~~, x~~1~~ ‚àà L~~1~~, x~~2~~ ‚àà L~~2~~}`
    - Es. `L~~1~~ = {ab, bb}; L~~2~~ = {aa, ab};` <br> `L~~1~~ ‚Ä¢ L~~2~~ = {abaa, abab, bbaa, bbab}`
- Potenza: `L^^n^^ = L ‚Ä¢ L^^n-1^^, n‚â•1; L^^0^^ = {Œµ}` per convenzione
    - Concatenazione di‚Äå `n` stringhe qualsiasi di `L`
    - Es. `L = {ab, bb}; L^^2^^ = {abab, abbb, bbab, bbbb}`
- Stella di Kleene: `L* = ‚à™ L^^n^^, n = 0..‚àû`
    - Concatenazione arbitraria di‚Äå stringhe di `L`

>

`L*`: chiusura riflessiva e transitiva di `L` rispetto a `‚Ä¢`

---

title: Espressioni regolari

- Dato un alfabeto `Œ£`, chiamiamo *espressione regolare* una stringa `r` sull'alfabeto `Œ£ ‚à™ {+, *, (, ), ‚Ä¢, √ò}` t.c.:
    - `r = √ò`: linguaggio vuoto; oppure
    - `r ‚àà Œ£`: linguaggio con un solo simbolo; oppure
    - `r = s + t`: unione dei linguaggi `L(s)`, `L(t)`; oppure
    - `r = s ‚Ä¢ t`: concatenazione dei linguaggi `L(s)`, `L(t)`; oppure
    - `r = s*`: chiusura del linguaggio `L(s)`
    - (con `s` e `t` espressioni regolari; simbolo `‚Ä¢` spesso implicito)
- *Linguaggi regolari*: rappresentabili con espressioni regolari (*‚Äúregex‚Äù*)

>

Esempio, con `Œ£ = {a, b}`: <br> `a ‚Ä¢ (a + b)* ‚Ä¢ b`

---

title: Save the day with regex

![](images/comp/regex-xkcd.png)

---

title: Regex nelle applicazioni

- Concatenazione di caratteri: `goal`
- Unione tra espressioni (opzione): `one|two|three`
- Un car. da un insieme (o no): `[a-z]`, `[^a-z0-9]`
- Un carattere qualsiasi: `defin.tely`
- Ripetizioni (0+, 1+, 0-1): `goo*al`, `go+al`, `goo?al`
- Sottoespressione: `(left right )*halt`

![](images/comp/perl-problems.png)

---

title: Regex, classi di caratteri

- `[...]` per includere uno qualsiasi dei caratteri in parentesi
    - Singoli caratteri o intervalli di caratteri adiacenti
    - `[A-Z]` = qualsiasi lettera maiuscola
    - `[a-zABC]` = qualsiasi lettera minuscola oppure `A`, `B`, o `C`
- `[^...]` per escludere uno qualsiasi dei caratteri in parentesi
    - `[^0-9]` = qualsiasi carattere non numerico
- Simboli speciali per identificare classi di caratteri
    - `\d` = numerico, ossia `[0-9]`
    - `\s` = `[ \t\r\n\f]`
    - `\w` = `[0-9a-zA-Z_]`
    - `\D` = non numerico, ossia `[^0-9]` (ecc.)

---

title: Regex, caratteri speciali

- `.` per un carattere qualsiasi
    - `A.B` riconosce la stringa `AoB`, `AwB`, `AOB` ecc.
- `\` escape, per segnalare sequenze speciali o considerare caratteri speciali come normali
    - `\?` cerca il `?`
- `^` corrisponde all'inizio del testo
- `$` corrisponde alla fine del testo
- `|` per alternativa tra due espressioni (unione)
    - `A|B` = carattere `A` o carattere `B`
- `(...)` per raggruppare sotto-espressioni
    - `ga(zz|tt)a` trova sia `gazza` che `gatta`

---

title: Regex, ripetizioni

- `{...}` per specificare il numero di ripetizioni
    - `\d{3,5}` sequenze di almeno tre cifre, al massimo cinque
- `*` zero o pi√π occorrenze di un‚Äôespressione
    - `(ab)*` riconosce `ab`, `abab`, la stringa vuota, ma non riconosce `abba`
- `+` una o pi√π occorrenze
    - `(ab)+` non riconosce la stringa vuota
- `?` zero o al pi√π una occorrenza (parte opzionale)
    - `(ab)?` riconosce `ab` ma non `abab`

>

<http://www.zytrax.com/tech/web/regex.htm>

---

title: Regex, esempi

![](images/comp/codice-fiscale.png)

- Codice fiscale: <br> `^[a-z]{6}[0-9]{2}[a-z][0-9]{2}[a-z][0-9]{3}[a-z]$`
- Dominio: <br> `^[\w\-]+\.(it|com|org|net|eu|mobi)$`
- E-mail: <br> `^[\w\-\.]+@[\w\-\.]+\.[a-z]+$`
- File: `^.+\.zip$`
- Data: `^\d{2}/\d{2}/\d{4}$`

---

title: Regex, validazione form

code: html

    <script>
    function validate(val) {
        var expr = /^\d{2}\/\d{2}\/\d{4}$/;
        if (! expr.test(val)) {
            window.alert("Wrong date format");
            return false;
        }
        return true;
    }
    </script>

    <form>
        Date (dd/mm/yyyy): <input name="usrdate">
        <input type="submit" onclick="return validate(usrdate.value)">
    </form>

---

title: Regex in Python

code: python

    >>> import re
    >>> text = 'Though not quickly, he run the 5th lap steadily.'
    >>> re.findall(r'[a-z]+ly', text)
    ['quickly', 'steadily']
    >>> re.sub(r'([0-9])([a-z]+)', r'\1<sup>\2</sup>', text)
    Though not quickly, he run the 5<sup>th</sup> lap steadily.

<http://docs.python.org/3/library/re.html>

---

title: Grammatiche di Chomsky
class: segue dark

---

title: Grammatiche di Chomsky

- Grammatica `G = < V~~T~~, V~~N~~, P, S >`
    - `V~~T~~`: alfabeto finito di simboli **terminali**
    - `V~~N~~`: ... **non terminali** (variabili, categorie sintattiche)
    - `V = V~~T~~ ‚à™ V~~N~~`
    - `P`: insieme di **produzioni**, relaz. binarie `V* ‚Ä¢ V~~N~~ ‚Ä¢ V* x V*` <br> `<Œ±, Œ≤> ‚àà P` si indica con `Œ± ‚Üí Œ≤`
    - `S ‚àà V~~N~~`: **assioma**
- `L(G)`: insieme delle stringhe di terminali ottenibili con finite operazioni di riscrittura
    - Applicazione delle regole di produzione, in vario modo

---

title: Linguaggio generato da G

- *Derivazione diretta* `‚áí`: riscrittura di una stringa tramite applicazione di una regola di produzione
- *Derivazione* `‚áí*`: chiusura riflessiva e transitiva della derivazione diretta
- *Forma di frase*: stringa `x t.c. x ‚àà V*, S ‚áí* x`
- *Linguaggio generato* da `G`: forme di frase con soli simboli terminali
    - `L(G) = {x : x ‚àà V~~T~~*, S ‚áí* x}`
- *Equivalenza* tra `G~~1~~` e `G~~2~~`: `L(G~~1~~) = L(G~~2~~)`

---

title: Grammatiche equivalenti

- `G~~1~~ = <{a,b}, {S, A}, P, S>`, con produzioni:
    - `S ‚Üí b` <br> `S ‚Üí aA` <br> `A ‚Üí aS`
    - ‚Ä¶ genera il linguaggio `{a^^n^^b : n pari}`
- Anche `G~~2~~`, con produzioni:
    - `S ‚Üí Ab | b` <br> `A ‚Üí aAa | aa`
- Ed anche `G3`:
    - `S ‚Üí Ab` <br> `A ‚Üí Aaa | Œµ`

>

`|` per raggruppare diverse produzioni di uno stesso non-terminale

---

title: Esempio di generazione

- `G = <{a, b, c}, {S, B, C}, P, S>`
    - (1) `S ‚Üí aSBC`
    - (2) `S ‚Üí aBC`
    - (3) `CB ‚Üí BC`
    - (4) `aB ‚Üí ab`
    - (5) `bB ‚Üí bb`
    - (6) `bC ‚Üí bc`
    - (7) `cC ‚Üí cc`
    - ‚Ä¶ genera il linguaggio `{a^^n^^b^^n^^c^^n^^ : n‚â•1}`
- Esercizio: provare a generare `aaabbbccc`
    - Soluzione: applicare 1-1-2-3-3-3-4-5-5-6-7-7

---

title: Alberi di derivazione (sintattici)

- Esempio di grammatica **ambigua**: due interpretazioni valide per `a + a * a`
    - `V~~T~~ = {a, +, *, (, )};  V~~N~~ = {E};`
    - `E ‚Üí E+E | E*E | (E) | a`

![](images/comp/ambiguity.svg)

- Grammatica non ambigua (con precedenza tra operatori)
    - `E ‚Üí E+T | T` <br> `T ‚Üí T‚àóF | F` <br> `F ‚Üí (E) | a`

---

title: Classificazione di Chomsky
figure: images/comp/hierarchy.svg

- *Tipo 0*: grammatiche **ricorsivam. enumerabili** (RE)
    - `Œ±AŒ≤ ‚Üí Œ≥` (*non limitate*)
- *Tipo 1*: grammatiche **contestuali** (CS)
    - `Œ±AŒ≤ ‚Üí Œ±Œ≥Œ≤`
- *Tipo 2*: grammatiche **non contestuali** (CF)
    - `A ‚Üí Œ≥`
- *Tipo 3*: grammatiche **regolari** (REG)
    - `A ‚Üí aB`, oppure `A ‚Üí b`, oppure `A ‚Üí Œµ`
    - Coincide con classe dei linguaggi definiti da *regex*

>

`A, B ‚àà V~~N~~; a, b ‚àà V~~T~~; Œ±, Œ≤, Œ≥ ‚àà V*`

---

title: Linguaggi non contestuali
class: segue dark

---

title: Linguaggi non contestuali

- Controllo di *palindromi*, *bilanciamento di parentesi* e varie *simmetrie*
    - Es.: `{a^^n^^b^^n^^ : n‚â•1}` gen. da `S ‚Üí aSb | ab` (CF)
    - Es.: L. parentesi bilanciate gen. da `S ‚Üí SS | (S) | Œµ`
    - Ma non: `{a^^n^^b^^n^^c^^n^^ : n‚â•1}` (CS) (*)
- **Linguaggi di programmazione** comuni: grammatiche CF
    - Parentesi bilanciate: `S ‚Üí SS | (S) | Œµ`
- Definizione con notazione Extended **Backus-Naur Form** (EBNF)
    - `{...}`: parte ripetibile (0+), `[...]`: parte opzionale,
    - `(...)`: raggruppamento, `|`: scelta
    - Terminali tra virgolette

>

(*) Nell'es. visto, sostituire (3) con: (3a) `CB ‚Üí HB`; (3b) `HB ‚Üí HC`; (3c) `HC ‚Üí BC`

---

title: Esempio di EBNF

code: EBNF

    V~~T~~ = {"il", "gatto", "topo", "sasso", "mangia", "beve"}
    P = {
        frase = soggetto verbo complemento
        soggetto = articolo nome
        complemento = articolo nome
        articolo = "il"
        nome = "gatto" | "topo" | "sasso"
        verbo = "mangia" | "beve"
    }

- *‚Äúil gatto mangia il topo‚Äù* √® una frase del linguaggio

---

title: Espressioni infisse e prefisse

- *Notazione infissa*, con precedenza tra operatori
    - Es.: `2 + 3 * 3`

code: ebnf

    expr = term {( "+" | "-" ) term}
    term = factor {( "*" | "/" ) factor}
    factor = number | "(" expr ")" | "-" term

- *Notazione prefissa, o polacca*
    - Es.: `* + 1 2 - 3 2` <br> ‚áí In forma infissa: `(1 + 2) * (3 - 2)`

code: ebnf

    expr = number | "+" expr expr | "-" expr expr |
                    "*" expr expr | "/" expr expr
    number = digit {digit}
    digit = "0" | "1" | "2" | "3" | "4" |
            "5" | "6" | "7" | "8" | "9"

---

title: Linguaggi LL(1) ü§î

- Sottoclasse dei linguaggi CF
- Ogni produzione relativa a stesso non-terminale (a sx)... <br> genera come primo simbolo un terminale diverso
    - No prefissi comuni, no ricorsione sinistra
- **Recursive descent parser**: analisi sintattica molto semplice ed efficiente
    - Basta ‚Äúspiare‚Äù il simbolo di input successivo, per capire con certezza quale produzione applicare

---

title: Pumping lemma REG ü§î
figure: images/comp/pumping-lemma-3.svg

- Formalmente, `‚àÄ L` regolare...
    * `‚àÉ k t.c. ‚àÄ z ‚àà L, |z| ‚â• k`
    * `‚àÉ u, v, w, |uv| ‚â§ k, |v| ‚â• 1 t.c.`
    * `z = uvw, uv^^i^^w ‚àà L, ‚àÄ i ‚â• 0`
- In ogni stringa abbastanza lunga,
    * c'√® una parte che si pu√≤ ripetere,
    * generando un'altra stringa di `L`
- Uno stesso non-terminale, per un input abbastanza lungo, deve comparire pi√π volte nell'albero sintattico ‚Ä¶
    * Un Automa a Stati Finiti (*), per un input abbastanza lungo, torna in uno stato gi√† visitato ‚Ä¶

>

Esempio con `G~~1~~`: `S ‚Üí b | aA; A ‚Üí aS`

---

title: Pumping lemma CF ü§î
figure: images/comp/pumping-lemma-2.svg

- Formalmente, `‚àÄ L` non contestuale...
    * `‚àÉ k t.c. ‚àÄ z ‚àà L, |z| ‚â• k`
    * `‚àÉ u, v, w, x, y, |vwx| ‚â§ k, |vx| ‚â• 1 t.c.`
    * `z = uvwxy, uv^^i^^wx^^i^^y ‚àà L, ‚àÄ i ‚â• 0`
- In ogni stringa abbastanza lunga,
    * ci sono due parti che si possono
    * ripetere assieme, restando in `L`
- Uno stesso non-terminale, per un input abbastanza lungo, deve comparire pi√π volte nell'albero sintattico ‚Ä¶

---

title: Corollari dei due lemmi ü§î

- ‚áí `L = {a^^n^^b^^n^^ : n ‚â• 0}` non √® REG
    * Si prende `a^^m^^b^^m^^, con m > k ‚áí |uv| < m`, sono tutte `a`‚Ä¶
- ‚áí `L = {a^^n^^b^^n^^c^^n^^ : n ‚â• 0}` non √® CF
    * Si prende `a^^m^^b^^m^^c^^m^^, con m > k ‚áí |vwx| < m`
    * Se `v` ed `x` con pi√π simboli diversi, `uv^^2^^wx^^2^^y` con simboli mescolati
    * Se `v` ed `x` con un solo simbolo, `uv^^2^^wx^^2^^y` con numero diverso di `a`, `b`, `c`
    * In entrambi i casi la nuova stringa `z' ‚àâ L`

---

title: Linguaggi di programmazione
class: segue dark

---

title: Linguaggi di programmazione

- Notazione formale per definire algoritmi
    - *Algoritmo*: sequenza di istruzioni per risolvere un dato problema in un tempo finito
- Ogni linguaggio √® caratterizzato da:
    - **Sintassi**
    - **Semantica**

---

title: Sintassi
figure: images/dev/syntax-diagrams.png
class: large-figure

- Insieme di regole formali per scrivere *frasi* ben formate (programmi) in un certo linguaggio
    - *Lessico*: parole riservate, operatori, variabili, costanti ecc. (*token*)
- Grammatiche non contestuali (...) espresse con notazioni formali:
    - Backus-Naur Form
    - Extended BNF
    - Diagrammi sintattici

---

title: Semantica

- Attribuisce un **significato** alle frasi (sintatticamente corrette) costruite nel linguaggio
- Una frase pu√≤ essere sintatticamente corretta e tuttavia non aver alcun significato
    - Soggetto ‚Äì predicato ‚Äì complemento
    - *‚ÄúLa mela mangia il bambino‚Äù*
    - *‚ÄúIl bambino mangia la mela‚Äù*
- Oppure avere un significato diverso da quello previsto...
    - *GREEK_PI = 345*

---

title: Semantica

- **Correttezza sui tipi**
    - Quali tipi di dato possono essere elaborati?
    - Quali operatori applicabili ad ogni dato?
    - Quali regole per definire nuovi tipi e operatori?
- **Semantica operazionale**
    - Qual √® l'effetto di ogni azione elementare?
    - Qual √® l‚Äôeffetto dell‚Äôaggregazione delle azioni?
    - Cio√®, qual √® l‚Äôeffetto dell‚Äôesecuzione di un certo programma?

---

title: Linguaggi di basso livello
figure: images/dev/assembly.png
class: large-figure

- Pi√π orientati alla macchina che ai problemi da trattare
- **Linguaggi macchina**: solo operazioni eseguibili direttamente dall'elaboratore
    - Op. molto elementari, diverse per ogni processore, in formato binario
- **Linguaggi assembly**: prima evoluzione, codici binari ‚Üí mnemonici

---

title: Linguaggi di alto livello

- Introdotti per facilitare la scrittura dei programmi
- Definizione della soluzione in modo intuitivo
- Con una certa **astrazione** rispetto al calcolatore su cui verranno eseguiti
- Devono essere tradotti in linguaggio macchina

---

title: Storia dei linguaggi
class: large-image

![](images/dev/languages-timeline.svg)

>

[O‚ÄôReilly Language Poster](http://www.oreilly.com/go/languageposter)

[Poster aggiornato](http://www.levenez.com/lang/history.html)

[History of Computer Programming Languages, by A. Ferguson](https://pdfs.semanticscholar.org/ecd5/25de6acd1d72e336ef43c6c76e7a7d9c88f9.pdf)

---

title: The Top 10 (IEEE Spectrum, 2017)
class: large-image

![](images/dev/languages-spectrum-2017.jpg)

>

<http://spectrum.ieee.org/static/interactive-the-top-programming-languages-2017>

---

title: Paradigmi di sviluppo

- Forniscono la filosofia e la metodologia con cui si scrivono i programmi
- Definiscono il concetto (astratto) di computazione
- Ogni linguaggio consente (o spinge verso) l'adozione di un particolare paradigma
    - Imperativo / procedurale
    - Orientato agli oggetti
    - Scripting (tipizzazione dinamica, principio DRY - Don't Repeat Yourself)
    - Funzionale (funzioni come ‚Äúcittadini di prima classe‚Äù)
    - Logico (base di conoscenza + regole di inferenza)

---

title: Linguaggi e paradigmi

- **Imperativi / procedurali**
    - Cobol, Fortran, Algol, C, Pascal
- **Orientati agli oggetti**
    - Simula, Smalltalk, Eiffel, C++, Delphi, Java, C#, VB.NET
- **Scripting**
    - Basic, Perl, PHP, Javascript, Python, Shell
- **Funzionali**
    - Lisp, Scheme, ML, Haskell, Erlang
- **Logici**
    - Prolog...

---

title: Esecuzione dei programmi

- Linguaggio ad alto livello ‚Üí passi necessari:
    - **Compilazione**, traduzione in linguaggio macchina
    - **Collegamento** con librerie di supporto
    - **Caricamento** in memoria
- Programmi **compilati**: applicati i 3 passi...
    - A tutto il codice; prima dell'esecuzione
- Programmi **interpretati**: applicati i 3 passi...
    - In sequenza, su ogni istruzione; a tempo di esecuzione

![](images/dev/build.svg)

---

title: Compilazione
figure: images/dev/compiler.svg
class: large-figure

- Traduzione da ling. alto livello a ling. macchina
    - Analisi: lessicale, grammaticale, contestuale
    - *Rappresentazione intermedia*: albero sintattico annotato (**AST**)
    - Generazione codice oggetto
- Codice oggetto: non ancora eseguibile
    - Linker, loader

---

title: Albero sintattico
figure: images/dev/ast-euclid.svg
class: large-figure

code: Python

    while b != 0:
        if a > b:
            a = a ‚àí b
        else:
            b = b ‚àí a
    return a

Algoritmo di Euclide per MCD

---

title: Collegamento

- Il **linker** collega diversi moduli oggetto
    - Simboli irrisolti ‚Üí riferimenti esterni
    - Il collegamento pu√≤ essere statico o dinamico
- **Collegamento statico**
    - Libreria inclusa nel file oggetto, eseguibile stand-alone
    - Dimensioni maggiori, ma possibile includere solo funzionalit√† utilizzate
- **Collegamento dinamico**
    - Librerie condivise da diverse applicazioni
    - Installazione ed aggiornamento unici
    - Caricate in memoria una sola volta

---

title: Caricamento
figure: images/dev/relocation.png

- Il **loader** carica in memoria un programma
    - Risolve indirizzi logici (variabili, salti ecc.)
    - Carica eventuali programmi di supporto (DLL ecc.)
- **Rilocazione statica**: indirizzi logici trasformati in indirizzi assoluti
- **Rilocazione dinamica**: indirizzi logici mantenuti, relativi alla posizione del programma in memoria
    - *Registri base* della CPU (reg. CS, DS e SS su x86): <br> locazione base di codice, dati e stack
    - *Memory Management Unit* in S.O.

---

title: Codice gestito

- Compilazione in **codice intermedio**
    - Bytecode (Java), Common Intermediate Lang. (.NET), ‚Ä¶
    - Python: compilato per una macchina virtuale (file .pyc), ma in modo trasparente
- Esecuzione su una **macchina virtuale**
    - Java Virtual Machine, Common Language Runtime, ‚Ä¶
    - Emulazione di un certo elaboratore
    - ‚áí Indipendenza da piattaforma fisica
    - Compilazione ‚Äúal volo‚Äù (*Just In Time*) in codice nativo
    - Gestione memoria con *garbage collection*

---

title: Sistemi di garbage collection
figure: images/dev/garbage-truck.jpg

- Restituzione automatica della memoria
    - Per oggetti/dati che non servono pi√π
- Possibile anche per codice nativo
    - Linguaggio *Go*
    - Estensioni e *‚Äúsmart pointers‚Äù* in C++
- Diversi algoritmi
    - *Reference counting*: idea di base, ma cicli‚Ä¶
    - *Mark & sweep*: parte da riferimenti locali/globali, marca oggetti raggiungibili
    - *Generational garbage collection*: controlla spesso oggetti recenti

---

title: Uso della garbage collection

- Vantaggi
    - Si libera sistematicamente la memoria (*memory leak*)
    - Non si rimuovono dati ancora utili (*dangling pointer*)
    - Dati rilocati per *compattare* la memoria
- Svantaggi
    - Maggiore occupazione del *processore* (~1.3x)
    - Maggiore occupazione di *memoria* (~2x)
    - GC decide autonomamente *quando* operare (problema per *real time*)

>

<https://golang.org/src/runtime/mgc.go>

<https://golang.org/s/go15gcpacing>

---

class: break

- Grammatica equiv. LL(1), ma senza precedenza tra operatori
- Provare a generare `2 + 3 * 3`

code: ebnf

    expr = term {( "+" | "-" | "*" | "/" ) term}
    term = number | "(" expr ")" | "-" term


