title: Python for data analysis
subtitle: NumPy, Pandas, PyPlotLib
figure: images/oop/modules.png

---

title: Python applications

![](images/algo/python-cases.jpg)

- Web, data analysis, scripting, teaching, games, hardware, multiplatform...

---

title: Readability counts
figure: images/algo/perfect-square.svg

code: python

    n = 0
    while n <= 0:
        n = int(input("Positive val? "))

    ans = 1
    while ans * ans < n:
        ans += 1

    if ans * ans == n:
        print("Square root:", ans)
    else:
        print("Not a perfect square")

>

<http://www.ce.unipr.it/brython/?p1_perfect_square.py>

---

title: Functions
figure: images/fun/function.png

- **`def`**, to define a function
- **`return`**, to (optionally) return the result
- Then, you **call** a function to execute it
- Type *annotations* for params and return value are optional and not verified

code: python

    def hypotenuse(leg1: float, leg2: float) -> float:
        hyp = (leg1 ** 2 + leg2 ** 2) ** 0.5
        return hyp

    result = hypotenuse(3, 4)  # 5.0

---

title: List
figure: images/fun/month-list.svg

- **Mutable** sequence of elements
- *Usually* of the same *type*
- Current *length* of a list `x`: `len(x)`
- Elements *enumerated* from `0` to `len(x)-1`

code: python

    months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun",
              "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]

code: python

    num_days = [31, 28, 31, 30, 31, 30,
                31, 31, 30, 31, 30, 31]

code: python

    results_by_month = [0] * 12  # List repetition

---

title: Elements and slices
figure: images/fun/wile-coyote.png

- **Attention: use valid indices!**
    - But *negative* indices counts from the end

code: python

    n = len(months)            # 12
    months[3]                  # "Apr"
    months[-2]                 # "Nov", same as n - 2

    spring = months[2:5]       # ["Mar", "Apr", "May"]
    quart1 = months[:3]        # ["Jan", "Feb", "Mar"]
    quart4 = months[-3:]       # ["Oct", "Nov", "Dec"]
    whole_year = months[:]     # Copy of the whole list

---

title: Insertion and removal
figure: images/fun/shopping-list.png

code: python

    grocery = ["spam", "egg", "beans"]

    grocery[0] = "sausage"      # replace an element

    grocery.append("bacon")     # add an element to the end
    grocery.pop()               # remove (and return) last element

    grocery.insert(1, "bacon")  # other elements shift
    removed = grocery.pop(1)    # remove (and return) element at index

    if "egg" in grocery:       # True, grocery contains "egg"
        grocery.remove("egg")  # remove an element by value

---

title: Equality and identity

code: python

    a = ["spam", "egg", "beans"]
    b = a[:]         # new list!
    b == a           # True, they contain the same values
    b is a           # False, they are two objects in memory
                     # (try and modify one of them...)
    c = a
    c is a           # True, same object in memory
                     # (try and modify one of them...)

    d = ["sausage", "mushrooms"]
    grocery = c + d  # list concatenation --> new list!

---

title: Strings and lists

- **String**: *immutable* sequence of chars
- **`join`** and **`split`**: from list to string and viceversa

code: python

    txt = "Monty Python's Flying Circus"
    txt[3]    # 't'
    txt[-2]   # 'u'
    txt[6:12] # "Python"
    txt[-6:]  # "Circus"

    days = ["tue", "thu", "sat"]
    txt = "|".join(days)  # "tue|thu|sat"

    days = "mon|wed|fri".split("|")
    # ["mon", "wed", "fri"]

---

title: Tuple

- **Immutable** sequence of values, even of *different type*

code: python

    # Tuple packing
    pt = 5, 6, "red"
    pt[0]  # 5
    pt[1]  # 6
    pt[2]  # "red"

    # multiple assignments, from a tuple
    x, y, colour = pt  # sequence unpacking
    a, b = 3, 4
    a, b = b, a

---

title: Cycles on sequences: for

code: python

    grocery = ["spam", "egg", "bacon", "sausage"]
    for product in grocery:
        print(product)

code: python

    for val in range(0, 5):
        print(val * val, end=" ")  # 0 1 4 9 16

- At each iteration, a different element of `grocery` is assigned to `product`
- A `for` cycle can be used on any kind of sequence: list, string, tuple, range...
- **`range`**: range of consecutive values
    - Lower end *included* (defaults to 0)
    - Upper end *excluded*

---

title: Functions on lists

code: python

    def limit_values(values, max_val):
        # procedure: process data, no direct result
        for i in range(len(values)):
            if values[i] > max_val:
                values[i] = max_val

        # the pythonic way: for i, val in enumerate(values): ...

    def main ():
        data = [5, 4, 2]
        limit_values(data, 4)
        print(data)

    main()

---

title: List comprehension
figure: images/dev/computer-ninja.png

- Terse way to create a list
- Each element: result of an operation on a member of another iterable
- Condition on elements, optional

code: python

    squares = [x ** 2 for x in range(12)]
    # squares = []
    # for x in range(12):
    #    squares.append(x ** 2)

code: python

    even_nums = [str(x) for x in range(12) if (x % 2) == 0]

---

title: Enumerate
figure: images/repr/child-fingers.png

- To couple each value of a sequence to an increasing index
- It generates a sequence of tuples (pairs)
- In `for` cycles, using both value and index

code: python

    >>> grocery = ["spam", "egg", "bacon", "sausage"]
    >>> list(enumerate(grocery))
    [(0, "spam"), (1, "egg"), (2, "bacon"), (3, "sausage")]

code: python

    grocery = ["spam", "egg", "bacon", "sausage"]
    for i, val in enumerate(grocery):
        print(i, val)

>

Results in a list: only (!) to visualize them <br>
Otherwise, Python doesn't generate results immediately (*lazy*)

---

title: Zip
figure: images/fun/zip.png

- Couples elements of two sequences
- It generates a sequence of tuples (pairs)
- The result has the len of the shortest sequence

code: python

    >>> grocery = ["spam", "egg", "bacon", "sausage"]
    >>> quantities = ["100 g", "6 pc", "200 g", "500 g", "too much"]
    >>> list(zip(grocery, quantities))
    [("spam", "100 g"), ("egg", "6 pc"), ("bacon", "200 g"),
    ("sausage", "500 g")]

>

Results in a list: only (!) to visualize them

---

title: Map
figure: images/fun/legomap.png

- Takes a function and a sequence as params
- *Higher order function*
- Applies the function to each value
- Returns the sequence of results

code: python

    >>> from math import sqrt
    >>> values = [0, 1, 2, 3, 4]
    >>> list(map(sqrt, values))
    [0.0, 1.0, 1.4142, 1.7320, 2.0]

code: python

    >>> from math import sqrt
    >>> list(map(sqrt, range(5)))
    [0.0, 1.0, 1.4142, 1.7320, 2.0]

>

Results in a list: only (!) to visualize them

---

title: Sort and reverse

code: python

    >>> grocery = ["spam", "egg", "bacon", "sausage"]
    >>> sorted(grocery)
    ['bacon', 'egg', 'sausage', 'spam']
    >>> sorted(grocery, reverse=True)
    ['spam', 'sausage', 'egg', 'bacon']
    >>> sorted(grocery, key=len)  # lengths of elements are compared
    ['egg', 'spam', 'bacon', 'sausage']

code: python

    >>> list(reversed(grocery))
    ['sausage', 'bacon', 'egg', 'spam']

code: python

    >>> grocery.sort()     # in-place
    >>> grocery.reverse()  # in-place
    >>> grocery
    ['spam', 'sausage', 'egg', 'bacon']

---

title: Dictionary
figure: images/fun/dictionary.png

- Sometimes called *map* or *associative array*
- Unordered set of key / value pairs
    - Keys are *unique*: like *indices* for lists, to access the associated value
    - They can be `int` or **`str`** (or any other immutable type)

code: python

    >>> tel = {"john": 4098, "terry": 4139}
    >>> tel["john"]
    4098
    >>> tel["graham"] = 4127
    >>> tel
    {"graham": 4127, "terry": 4139, "john": 4098}

>

Try also `list(tel)` and `list(tel.items())`

---

title: Multidim lists
- Lists of lists of ...
    - Access to elements: two or more indices (or *dimensions*)
    - If bidimensional, called *matrices*

code: python

    a = [['A', 'B', 'C', 'D'],
         ['E', 'F', 'G', 'H'],
         ['I', 'L', 'M', 'N']]          # 2D

    b = ['A', 'B', 'C', 'D',
         'E', 'F', 'G', 'H',
         'I', 'L', 'M', 'N']            # 1D

    i = y * cols + x                    # 2D -> 1D

    y = i // cols
    x = i % cols                        # 1D -> 2D

---

title: Sum of columns: matrix

code: python

    matrix = [[2, 4, 3, 8],
              [9, 3, 2, 7],
              [5, 6, 9, 1]]
    rows = len(matrix)
    cols = len(matrix[0])

    for x in range(cols):
        total = 0
        for y in range(rows):
            val = matrix[y][x]
            total += val
        print("Col #", x, "sums to", total)

---

title: List as pseudo-matrix

code: python

    matrix = [2, 4, 3, 8,
              9, 3, 2, 7,
              5, 6, 9, 1]
    rows = 3  # Cannot be guessed from matrix alone
    cols = len(matrix) // rows

    for x in range(cols):
        total = 0
        for y in range(rows):
            val = matrix[y * cols + x]   # 2D -> 1D
            total += val
        print("Col #", x, "sums to", total)

---

title: Matrix with known size

code: python

    matrix = [[' ' for x in range(cols)] for y in range(rows)]
    # all elements are inited as ' ' -- your need may vary

code: python

    matrix = []
    for y in range(rows):
        new_row = []
        for x in range(cols):
            new_row.append(' ')
        matrix.append(new_row)

---

title: Data streams
figure: images/fun/magnetic-tape.png

- **Stream**: abstraction for information stream
    - Reading and writing information on *any* I/O device (*file, and more*)
- **Text file**
    - Various encodings (*UTF-8*, or other)
    - Automatic conversions, e.g. `"\n"` → `"\r\n"`
- **Binary file**
    - Precise I/O, bytes are not converted
    - Any file... also a text file!

---

title: Writing on file

- `open` function to access a file (text, by default)
    - Write or read mode: `"w"`, o `"r"` (def.)
- Writing to file: `print` funtion, or `write` method
- `with` section: at the end the file is closed (also in case of error)

code: python

    with open("some_file.txt", "w") as f1:
        f1.write("First line\n")   # explicit newline
        f1.write("Second line\n")  # continue writing here...

    with open("other_file.txt", "w") as f2:
        for x in range(10):
            print(x, x ** 2, file=f2)

---

title: Reading from file

code: python

    with open("some_file.txt", "r") as f1:
        first_line = f1.readline()
        second_line = f1.readline()
        # both strings contain '\n' at the end
        # at end of file, an empty string is read

    with open("other_file.txt", "r") as f2:
        whole_text = f2.read()
        # do stg with whole_text

    with open("last_file.txt", "r") as f3:
        for line in f3:
            # line contains '\n' at the end
            # strip() removes withespaces at both ends
            print(line.strip(), ':', len(line))

---

title: Basic CSV files

code: Python

    matrix = []
    cols, rows = 0, 0

    with open('matrix.csv', 'r') as file1:
        for line in file1:
            splitted = line.split(',')
            vals = [int(i) for i in splitted]
            matrix.append(vals)
            ## matrix += vals  # for a simple list (ex. 4.5)

            if cols == 0:
                cols = len(vals)
            rows += 1

---

title: CSV module

code: Python

    import csv
    matrix = []
    with open('some.csv', newline='') as f:
        reader = csv.reader(f)
        for row in reader:
            matrix.append(row)
    print(matrix)

    with open('some.csv', 'w', newline='') as f:
        writer = csv.writer(f)
        for row in matrix
            writer.writerow(row)

---

title: I/O for strings and console

- Strings as streams: `io.StringIO`
- Console as stream: `sys.stdin`, `sys.stdout`, `sys.stderr`

code: python

    import io, sys

    with io.StringIO() as output:
        output.write("First line.\n")
        print("Second line.", file=output)
        # Retrieve stream contents, i.e. "First line.\nSecond line.\n"
        contents = output.getvalue()
        sys.stdout.write(contents)

code: python

    for line in sys.stdin:  # CTRL-D (Lin) or CTRL-Z (Win) to end the input
        print(len(line))    # notice '\n' at the end

---

title: Errors on file
figure: images/fun/garbled-tape.png

- **Exceptions**: to handle unexpected cases separately
    - Error inside `try`: esecution is interrupted immediately
    - `except` section is executed, to handle the specific type of error (multiple `except` sections are allowed)
    - A `with` section assures the file is closed

code: python

    try:
        with open("other_file.txt", "r") as f:
            whole_text = f.read()
            # do stg with whole_text
    except IOError as err:
        print("Oh, my!")

---

title: Scientific Python
class: segue dark

---

title: Lists in memory
class: large-image

![](images/scipy/python-list-list.svg)

---

title: Number crunching in Python

- Inefficient **memory** layout
    - Multiple *dereferencing* steps
    - Each value is a “*fat*” object, an `int` takes dozens of bytes
    - Values are *not contiguous*, not cache friendly
- `a + b` executed as:
    - `a.__add__(b)`, or...
    - `b.__radd__(a)`, if `__add__` not found
- Python is **dynamic**
    - *Monkey patching*
    - Any method, special or not, can be changed or *decorated* at any time
    - Lookup at each call

---

title: Method lookup

- In general, methods are handled as attributes
    - Complex lookup in multiple dictionaries
    - Starts with `a.__getattribute__("something")`
    - An *instance* has its own methods
    - A *class* has its own methods
    - A *base class* has its own methods
    - A *metaclass* may also alter the lookup
- “Special methods” are... *special*
    - Cannot be set for a single instance
    - Faster lookup
    - Still possibly going through multiple dictionaries

---

title: Anaconda
figure: images/dev/jupyter-notebook.png
class: large-figure

- Popular open-source distribution of Python: <http://anaconda.com>
- Based on the Scipy.org ecosystem
- Modules for *data analysis* and *machine learning*
- Conda: package management
- Numba: JIT compiler, code vectorization
- Jupyter Notebook: browser-based REPL
    - `$ jupyter notebook`

---

title: Virtual environments

- Standard Python provides *virtual environments*
- To install different modules for different projects
- Ex.: *create* `myenv` env., *activate* it, *install* some modules

code: Shell

    $ python3 -m venv myenv
    $ source myenv/bin/activate
    $ pip install numpy

- First command creates new folder, with a copy of CPython
- To change to another env, *deactivate* the current one
    - To delete an env, delete its folder
- On Windows, scripts are in the `Script` folder
    - `sci-env\Scripts\activate.bat`

---

title: Anaconda environments

code: Shell

    $ conda create --name myenv
    $ conda install -n myenv numpy
    $ conda activate myenv
    ...
    $ conda deactivate myenv
    $ conda remove --name myenv --all

- It is also possible to specify a Python version
    - `conda create -n myenv python=3.4`

---

title: NumPy
class: segue dark

---

title: Modulo NumPy
figure: images/scipy/numpy-mem.png
class: large-figure

- Numeric, 1995; NumPy, 2006
- **N-dimensional array**
    - Homogeneously typed
    - Efficient memory layout (~ C)
- Efficient **algorithms**
    - Impl. Fortran, C/C++, Cython
    - Functionality comparable to basic *MATLAB*
- Base of *SciPy* ecosystem
    - MatPlotLib, SymPy, Pandas, Scikit-learn, Scikit-image
- Also used for *images*
    - In PyGame, Python bindings of OpenCV, etc.

---

title: NumPy arrays

code: Python

    >>> import numpy as np
    >>> a = np.array([2, 3, 4])
    >>> a
    array([2, 3, 4])
    >>> a.dtype
    dtype('int64')

code: Python

    >>> b = np.array([1.2, 3.5, 5.1])
    >>> b.dtype
    dtype('float64')

code: Python

    c = np.array([[1, 2], [3, 4]], dtype=np.float64)
    >>> c
    array([[1., 2.],
           [3., 4.]])

---

title: Zeros and ones

code: Python

    >>> np.zeros(4)
    array([0., 0., 0., 0.])

    >>> np.ones((2, 3), dtype=np.int16)  # dtype can also be specified
    array([[[ 1, 1, 1],
            [ 1, 1, 1]], dtype=int16)

    >>> np.empty((2, 3))  # uninitialized, output may vary
    array([[3.73603959e-262, 6.02658058e-154, 6.55490914e-260],
           [5.30498948e-313, 3.14673309e-307, 1.00000000e+000]])

    >>> np.random.random((2, 3))
    array([[ 0.1528439 ,  0.00263175,  0.21967677],
           [ 0.66804669,  0.84067279,  0.23624629]])

---

title: Range and shape

code: Python

    >>> np.arange(10, 30, 5)  # from 10, to 30, step 5
    array([10, 15, 20, 25])

code: Python

    >>> np.linspace(0, 2, 5)  # 5 numbers from 0 to 2
    array([0., 0.5, 1., 1.5, 2.])

code: Python

    >>> a = np.arange(15).reshape(3, 5)
    >>> a
    array([[ 0,  1,  2,  3,  4],
           [ 5,  6,  7,  8,  9],
           [10, 11, 12, 13, 14]])
    >>> a.shape
    (3, 5)

- *Shape*: the number of elements along each axis

---

title: Exercise - Memory game
figure: images/misc/memory.png

- `np.tile(a, reps)` repeats the whole `a`
- `np.repeat(a, reps)` repeats each element of `a`
    - There's also a method of `ndarray`
- `np.random.shuffle(a)` shuffles `a`
- *Exercise*: create a matrix with couples
    - Given `n = rows * cols`
    - `n / 2` different values, each repeated twice
    - But random positions

---

title: Elementwise operations

- Most operators apply elementwise
- A new array holds the result
- Some ops act *in place*: `+=`, `*=`, ...

code: Python

    >>> a = np.array([20, 30, 40, 50])
    >>> a < 35
    array([True, True, False, False])

    >>> b = np.arange(4)
    >>> b ** 2
    array([0, 1, 4, 9])
    >>> a - b
    array([20, 29, 38, 47])

---

title: Matrix multiplication
figure: images/scipy/matrix-mult.svg

code: Python

    >>> A = np.array([[1, 1],
    ...               [0, 1]])
    >>> B = np.array([[2, 0],
    ...               [3, 4]])
    >>> A * B                 # elementwise product
    array([[2, 0],
           [0, 4]])
    >>> A @ B                 # matrix product (Py3.5)
    array([[5, 4],
           [3, 4]])
    >>> A.dot(B)              # another matrix product
    array([[5, 4],
           [3, 4]])

---

title: Aggregate functions

- By default, array handled as a list of numbers, regardless of shape

code: Python

    >>> b = np.arange(12).reshape(3, 4)
    >>> b
    array([[ 0,  1,  2,  3],
           [ 4,  5,  6,  7],
           [ 8,  9, 10, 11]])
    >>> b.sum()              # guess also min and max
    66
    >>> b.sum(axis=1)        # sum of each row
    array([ 6, 22, 38])
    >>> b / b.max(axis=0)    # morm each column
    array([[0.  , 0.11, 0.2 , 0.27],
           [0.5 , 0.55, 0.6 , 0.63],
           [1.  , 1.  , 1.  , 1.  ]])

---

title: Universal functions

- Math funcs provided as “*universal functions*” (*ufunc*)
    - Operate elementwise and return an array
    - `sin`, `cos`, `exp` etc.

code: Python

    >>> A = np.linspace(0, np.pi/2, 4)
    >>> np.sin(A)
    array([0., 0.5, 0.8660254, 1.])

code: Python

    >>> B = np.arange(3)
    >>> B
    array([0, 1, 2])
    >>> np.exp(B)
    array([1., 2.71828183, 7.3890561])
    >>> np.sqrt(B)
    array([0., 1., 1.41421356])

---

title: Indexing and slicing

- Multidimensional arrays: one index per axis
    - Indices are given in a tuple separated by commas

code: Python

    >>> def f(y, x): return 10 * y + x
    >>> b = np.fromfunction(f, (3, 4), dtype=int)
    >>> b
    array([[ 0,  1,  2,  3],
           [10, 11, 12, 13],
           [20, 21, 22, 23]])
    >>> b[2, 3]
    23
    >>> b[:, 1]  # each row in the second column of b
    array([1, 11, 21])
    >>> b[1:3, 0:2]
    array([[10, 11],
           [20, 21]])

---

title: Dots

- Dots (`...`) represent as many colons as needed
    - ... to produce a complete indexing tuple

code: Python

    >>> c = np.array( [[[  0,  1,  2],    # a 3D array
                        [ 10, 12, 13]],
                       [[100,101,102],
                        [110,112,113]]])
    >>> c.shape
    (2, 2, 3)
    >>> c[1,...]  # same as c[1,:,:] or c[1]
    array([[100, 101, 102],
           [110, 112, 113]])
    >>> c[...,2]  # same as c[:,:,2]
    array([[  2,  13],
           [102, 113]])

---

title: Iterating

- Iterating over a multidim. array: wrt the first axis
- The `flat` attribute is an iterator over all the elements

code: Python

    >>> b
    array([[ 0,  1,  2,  3],
           [10, 11, 12, 13],
           [20, 21, 22, 23]])
    >>> for row in b: print(row)
    [0 1 2 3]
    [10 11 12 13]
    [20 21 22 23]
    >>> for val in b.flat: print(val, end=" ")
    0 1 2 3 10 11 12 13 20 21 22 23

---

title: Shape manipulation

code: Python

    >>> a = np.random.randint(10, size=(3, 4))
    >>> a
    array([[ 2.,  8.,  0.,  6.],
           [ 4.,  5.,  1.,  1.],
           [ 8.,  9.,  3.,  6.]])
    >>> a.ravel()  # returns a new view, flattened
    array([ 2.,  8.,  0.,  6.,  4.,  5.,  1.,  1.,  8.,  9.,  3.,  6.])
    >>> a.reshape(2, 6)  # new view, different shape
    array([[ 2.,  8.,  0.,  6.,  4.,  5.],
           [ 1.,  1.,  8.,  9.,  3.,  6.]])
    >>> a.resize(2, 6)  # modifies the array itself
    >>> a
    array([[ 2.,  8.,  0.,  6.,  4.,  5.],
           [ 1.,  1.,  8.,  9.,  3.,  6.]])

---

title: Transposition

code: Python

    >>> a = np.array([[ 2.,  8.,  0.],
                      [ 4.,  5.,  1.]])
    >>> a.shape
    (2, 3)
    >>> a.strides
    (24, 8)
    >>> a.T  # returns a transposed view, same as a.transpose()
    array([[ 2.,  4.],
           [ 8.,  5.],
           [ 0.,  1.]])
    >>> a.T.shape
    (3, 2)
    >>> a.T.strides
    (8, 24)

---

title: Stacking

code: Python

    >>> a = np. array([[ 8.,  8.],
                       [ 0.,  0.]])
    >>> b = np.array([[ 1.,  8.],
                      [ 0.,  4.]])
    >>> np.vstack((a, b))
    array([[ 8.,  8.],
           [ 0.,  0.],
           [ 1.,  8.],
           [ 0.,  4.]])
    >>> np.hstack((a, b))
    array([[ 8.,  8.,  1.,  8.],
           [ 0.,  0.,  0.,  4.]])

---

title: Splitting into several arrays

- `hsplit` splits an array along its horizontal axis
    - Specify num of equally shaped arrays to return, or...
    - Specifying columns where division should occur
- `vsplit` works on the vertical axis

code: Python

    >>> a = np.array([[9., 5., 6., 3., 6., 8., 0., 7., 9.],
                      [1., 4., 9., 2., 2., 1., 0., 6., 2.]])
    >>> np.hsplit(a, 3)   # Split a into 3
    [array([[ 9.,  5.,  6.], [ 1.,  4.,  9.]]),
     array([[ 3.,  6.,  8.], [ 2.,  2.,  1.]]),
     array([[ 0.,  7.,  9.], [ 0.,  6.,  2.]])]
    >>> np.hsplit(a, (3, 4))   # Split after 3rd and 4th column
    [array([[ 9.,  5.,  6.], [ 1.,  4.,  9.]]),
     array([[ 3.], [ 2.]]),
     array([[ 6.,  8.,  0.,  7.,  9.], [ 2.,  1.,  0.,  6.,  2.]])]

---

title: Linear algebra

    >>> a = np.array([[1.0, 2.0],
                      [3.0, 4.0]])
    >>> b = np.linalg.inv(a)
    >>> b
    array([[-2. ,  1. ],
           [ 1.5, -0.5]])
    >>> a @ b
    array([[ 1.,  0. ],
           [ 0.,  1. ]])
    >>> u = np.eye(2)  # unit 2x2 matrix; "eye" represents "I"
    >>> u
    array([[ 1.,  0.],
           [ 0.,  1.]])

---

title: Exercise - Fair tickets
figure: images/misc/fair-tickets.jpg
class: large-figure

- Cost of a ticket for a fair
    - 4.00€ for adults
    - 1,50€ for children
- At the end of the day
    - 2200 visitors have entered (*b1*)
    - 5050€ have been collected (*b2*)
- How many adults (*x1*) and how many children (*x2*) have entered?
    - Linear system (`a @ x = b`)
    - Solve with matrix operations

---

title: Determinant and autovectors

code: Python

    >>> a = np.array([[1.0, 2.0],
                      [3.0, 4.0]])
    >>> np.linalg.det(a)
    -2.0
    >>> w, v = np.linalg.eig(a)
    >>> w  # eigenvalues
    array([-0.37228132,  5.37228132])
    >>> np.linalg.det(w[0] * np.eye(2) - a)  # det(λI − A) = 0
    0.0
    >>> v.T  # eigenvectors, normalized but transposed (!)
    array([[-0.82456484,  0.56576746],
           [-0.41597356, -0.90937671]])
    >>> sum(v.T[0] ** 2)  # magnitude = 1
    1.0
    >>> (w[0] * np.eye(2) - a) @ v.T[0]  # (λI − A)v = 0	
    array([ 0.,  0.])

---

title: Solve a linear system

code: Python

    >>> a = np.array([[1, 1],
                      [4, 1.5]])
    >>> b = np.array([2200, 5050])
    >>> np.linalg.inv(a) @ b
    array([  700.,  1500.])
    >>> np.linalg.solve(a, b)	
    array([  700.,  1500.])

---

title: Pandas
class: segue dark

---

title: Pandas

- Library of data *structures* and data *analysis tools*
    - High-performance, easy-to-use
    - Use cases are similar to R-lang
- Often used with *Jupyter Notebook*, Web app to create and share documents
    - Fragments of code in various languages
    - Can be executed and modified
    - Equations, visualizations, text
    - Useful for data cleaning and transformation, numerical simulation, statistical modeling, data visualization, machine learning, etc.

---

title: Creating a DataFrame

code: Python

    >>> import pandas as pd
    >>> dates = pd.date_range('20130101', periods=6)
    >>> dates
    DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03',
                   '2013-01-04', '2013-01-05', '2013-01-06'],
                  dtype='datetime64[ns]', freq='D')
    >>> df = pd.DataFrame(np.random.randn(6,4), index=dates,
                          columns=list('ABCD'))
    >>> df
                       A         B         C         D
    2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
    2013-01-02  1.212112 -0.173215  0.119209 -1.044236
    2013-01-03 -0.861849 -2.104569 -0.494929  1.071804
    2013-01-04  0.721555 -0.706771 -1.039575  0.271860
    2013-01-05 -0.424972  0.567020  0.276232 -1.087401
    2013-01-06 -0.673690  0.113648 -1.478427  0.524988

---

title: DataFrame from a dict

code: Python

    >>> df2 = pd.DataFrame({
            'A' : 1.,
            'B' : pd.Timestamp('20130102'),
            'C' : pd.Series(1,index=list(range(4)),dtype='float32'),
            'D' : np.array([3] * 4,dtype='int32'),
            'E' : pd.Categorical(["test","train","test","train"]),
            'F' : 'foo' })
    >>> df2
         A          B    C  D      E    F
    0  1.0 2013-01-02  1.0  3   test  foo
    1  1.0 2013-01-02  1.0  3  train  foo
    2  1.0 2013-01-02  1.0  3   test  foo
    3  1.0 2013-01-02  1.0  3  train  foo

---

title: Data summary

- View top or bottom rows: `df.head()`, `df.tail()`
- Access index, columns, data: `df.index`, `df.columns`, `df.values`
- Transpose: `df.T`
- Show static summary

code: Python

    >>> df.describe()
                  A         B         C         D
    count  6.000000  6.000000  6.000000  6.000000
    mean   0.073711 -0.431125 -0.687758 -0.233103
    std    0.843157  0.922818  0.779887  0.973118
    min   -0.861849 -2.104569 -1.509059 -1.135632
    25%   -0.611510 -0.600794 -1.368714 -1.076610
    50%    0.022070 -0.228039 -0.767252 -0.386188
    75%    0.658444  0.041933 -0.034326  0.461706
    max    1.212112  0.567020  0.276232  1.071804

---

title: Sorting by values or index

code: Python

    >>> df.sort_values(by='B')  # asc values of B
                       A         B         C         D
    2013-01-03 -0.861849 -2.104569 -0.494929  1.071804
    2013-01-04  0.721555 -0.706771 -1.039575  0.271860
    2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
    2013-01-02  1.212112 -0.173215  0.119209 -1.044236
    2013-01-06 -0.673690  0.113648 -1.478427  0.524988
    2013-01-05 -0.424972  0.567020  0.276232 -1.087401

    >>> df.sort_index(axis=1, ascending=False)  # desc column names
                       D         C         B         A
    2013-01-01 -1.135632 -1.509059 -0.282863  0.469112
    2013-01-02 -1.044236  0.119209 -0.173215  1.212112
    2013-01-03  1.071804 -0.494929 -2.104569 -0.861849
    2013-01-04  0.271860 -1.039575 -0.706771  0.721555
    2013-01-05 -1.087401  0.276232  0.567020 -0.424972
    2013-01-06  0.524988 -1.478427  0.113648 -0.673690

---

title: Projection of columns

code: Python

    >>> df['A']
    2013-01-01    0.469112
    2013-01-02    1.212112
    2013-01-03   -0.861849
    2013-01-04    0.721555
    2013-01-05   -0.424972
    2013-01-06   -0.673690

---

title: Selection of rows

code: Python

    >>> df[0:3]
                       A         B         C         D
    2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
    2013-01-02  1.212112 -0.173215  0.119209 -1.044236
    2013-01-03 -0.861849 -2.104569 -0.494929  1.071804

    >>> df['20130102':'20130104']
                       A         B         C         D
    2013-01-02  1.212112 -0.173215  0.119209 -1.044236
    2013-01-03 -0.861849 -2.104569 -0.494929  1.071804
    2013-01-04  0.721555 -0.706771 -1.039575  0.271860

---

title: Slicing in both axis

code: Python

    >>> df.loc['20130102':'20130104',['A','B']]
                       A         B
    2013-01-02  1.212112 -0.173215
    2013-01-03 -0.861849 -2.104569
    2013-01-04  0.721555 -0.706771

    >>> df.iloc[3:5,0:2]
                       A         B
    2013-01-04  0.721555 -0.706771
    2013-01-05 -0.424972  0.567020

---

title: Boolean filtering

code: Python

    >>> df[df.A > 0]
                       A         B         C         D
    2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
    2013-01-02  1.212112 -0.173215  0.119209 -1.044236
    2013-01-04  0.721555 -0.706771 -1.039575  0.271860

    >>> df[df > 0]
                       A         B         C         D
    2013-01-01  0.469112       NaN       NaN       NaN
    2013-01-02  1.212112       NaN  0.119209       NaN
    2013-01-03       NaN       NaN       NaN  1.071804
    2013-01-04  0.721555       NaN       NaN  0.271860
    2013-01-05       NaN  0.567020  0.276232       NaN
    2013-01-06       NaN  0.113648       NaN  0.524988

---

title: Setting

code: Python

    >>> df2 = df.copy()
    >>> df2[df2 > 0] = -df2
    >>> df2
                       A         B         C  D    F
    2013-01-01  0.000000  0.000000 -1.509059 -5  NaN
    2013-01-02 -1.212112 -0.173215 -0.119209 -5 -1.0
    2013-01-03 -0.861849 -2.104569 -0.494929 -5 -2.0
    2013-01-04 -0.721555 -0.706771 -1.039575 -5 -3.0
    2013-01-05 -0.424972 -0.567020 -0.276232 -5 -4.0
    2013-01-06 -0.673690 -0.113648 -1.478427 -5 -5.0

---

title: Is-in

code: Python

    >>> df2 = df.copy()
    >>> df2['E'] = ['one', 'one','two','three','four','three']
    >>> df2
                       A         B         C         D      E
    2013-01-01  0.469112 -0.282863 -1.509059 -1.135632    one
    2013-01-02  1.212112 -0.173215  0.119209 -1.044236    one
    2013-01-03 -0.861849 -2.104569 -0.494929  1.071804    two
    2013-01-04  0.721555 -0.706771 -1.039575  0.271860  three
    2013-01-05 -0.424972  0.567020  0.276232 -1.087401   four
    2013-01-06 -0.673690  0.113648 -1.478427  0.524988  three

    >>> df2[df2['E'].isin(['two','four'])]
                       A         B         C         D     E
    2013-01-03 -0.861849 -2.104569 -0.494929  1.071804   two
    2013-01-05 -0.424972  0.567020  0.276232 -1.087401  four

---

title: Histogramming

code: Python

    >>> s = pd.Series(np.random.randint(7, size=10))
    >>> s
    0    4
    1    2
    2    1
    3    2
    ...
    dtype: int64
    >>> s.value_counts()
    4    5
    6    2
    2    2
    1    1
    dtype: int64

---

title: Concat and merge

- Take multiple pandas and put them together
- `concat()`: one piece below the other
- `merge()`: rows are joined when they have the same `key`

code: Python

    >>> left = pd.DataFrame({'key': ['foo', 'bar'], 'lval': [1, 2]})
    >>> right = pd.DataFrame({'key': ['foo', 'bar'], 'rval': [4, 5]})
    >>> pd.merge(left, right, on='key')
       key  lval  rval
    0  foo     1     4
    1  bar     2     5

---

title: Group-by

- Split data into groups based on some criteria
- Apply a function to each group independently
- Combine the results into a data structure

code: Python

    >>> df = pd.DataFrame({'A' : ['foo', 'bar', 'foo', 'bar',
                                  'foo', 'bar', 'foo', 'foo'],
                           'B' : ['one', 'one', 'two', 'three',
                                  'two', 'two', 'one', 'three'],
                           'C' : np.random.randn(8),
                           'D' : np.random.randn(8)})
    >>> df.groupby('A').sum()
                C        D
    A
    bar -2.802588  2.42611
    foo  3.146492 -0.63958

---

title: Pivot table

- Reshape the dataframe
	- Using values as new rows and columns titles
	- Cells contain averages, i.e., `aggfunc=np.mean`

code: Python

    >>> df = pd.DataFrame({
            'A' : ['one', 'one', 'two', 'three'] * 3,
            'B' : ['A', 'B', 'C'] * 4,
            'C' : ['foo', 'foo', 'foo', 'bar', 'bar', 'bar'] * 2,
            'D' : np.random.randn(12),
            'E' : np.random.randn(12)})
    >>> pd.pivot_table(df, values='D', index='A', columns='C')
    C           bar       foo
    A
    one    0.463952  0.419066
    three -0.660418  0.991739
    two    0.091446  0.236650

---

title: MatPlotLib
class: segue dark

---

title: Basic plots
figure: images/scipy/pyplot-1.png images/scipy/pyplot-2.png

code: Python

    import matplotlib.pyplot as plt
    plt.plot([1, 2, 3, 4])
    plt.ylabel('some numbers')
    plt.show()

code: Python

    # plot x versus y
    plt.plot([1, 2, 3, 4], [1, 4, 9, 16])
    plt.show()

>

[matplotlib.org](https://matplotlib.org/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib.pyplot.plot)

---

title: Formatting the plot
figure: images/scipy/pyplot-3.png

code: Python

    plt.plot([1, 2, 3, 4], [1, 4, 9, 16], 'ro')
    plt.axis([0, 6, 0, 20])  # xmin, xmax, ymin, ymax
    plt.show()

code: Python

    # example format strings
    'b'    # blue markers with default shape
    'ro'   # red circles
    'g-'   # green solid line
    '--'   # dashed line with default color
    'k^:'  # black triangle_up markers connected by a dotted line

>

<https://www.mathworks.com/help/matlab/ref/linespec.html>

---

title: Plotting NumPy arrays
figure: images/scipy/pyplot-4.png

code: Python

    # evenly sampled time at 200ms intervals
    t = np.arange(0., 5., 0.2)

    # red dashes, blue squares and green triangles
    plt.plot(t, t, 'r--',
             t, t**2, 'bs',
             t, t**3, 'g^')
    plt.show()

---

title: Plotting data from dict
figure: images/scipy/pyplot-5.png

code: Python

    data = {'a': np.arange(50),
            'c': np.random.randint(0, 20, 50),
            'd': np.abs(np.random.randn(50)) * 100}
    data['b'] = data['a'] + 10 * np.random.randn(50)

    plt.scatter('a', 'b', c='c', s='d', data=data)
    plt.xlabel('entry a')
    plt.ylabel('entry b')
    plt.show()

    # s for size, c for color
    # 'c': one int out of 20 (index for a color-map)

---

title: Plotting with categorical variables
figure: images/scipy/pyplot-6.png
class: large-figure

code: Python

    names = ['group_a', 'group_b', 'group_c']
    values = [1, 10, 100]

    plt.figure(1, figsize=(9, 3))  # inches

    plt.subplot(131)  # rows, cols, index
    plt.bar(names, values)
    plt.subplot(132)  # rows, cols, index
    plt.scatter(names, values)
    plt.subplot(133)  # rows, cols, index
    plt.plot(names, values)
    plt.suptitle('Categorical Plotting')
    plt.show()

---

title: Subplots in column
figure: images/scipy/pyplot-7.png

code: Python

    def f(t):
        return np.exp(-t) * np.cos(2*np.pi*t)

    t1 = np.arange(0.0, 5.0, 0.1)
    t2 = np.arange(0.0, 5.0, 0.02)

    plt.subplot(211)  # rows, cols, index
    plt.plot(t1, f(t1), 'bo', t2, f(t2), 'k')

    plt.subplot(212)  # rows, cols, index
    plt.plot(t2, np.cos(2*np.pi*t2), 'r--')
    plt.show()

---

title: Histogram and text
figure: images/scipy/pyplot-8.png

code: Python

    mu, sigma = 100, 15
    x = mu + sigma * np.random.randn(10000)

    # histogram of data, with 50 “bins”
    plt.hist(x, 50, facecolor='g')

    plt.xlabel('Smarts')
    plt.ylabel('Probability')
    plt.title('Histogram of IQ')
    plt.text(60, .025, r'$\mu=100,\ \sigma=15$')
    plt.axis([40, 160, 0, 0.03])
    plt.grid(True, alpha=0.75)
    plt.show()

---

title: Nonlinear axes


code: Python

    # make up some data in the interval ]0, 1[
    mu, sigma = 0.5, 0.4
    y = mu + sigma * np.random.randn(1000)
    y = y[(y > 0) & (y < 1)]
    y.sort()
    x = np.arange(len(y))

    # log
    plt.plot(x, y)
    plt.yscale('log')
    plt.title('log')
    plt.grid(True)
    plt.show()

---

title: Example: students' questionnaires
figure: images/dii/quiz.png

- Students' answers to questionnaires about courses
- Data transformation to evaluate marks
- Distribution of marks and density plots
- Use of multiple figures

>

<https://github.com/tomamic/paradigmi/tree/master/questionari>

