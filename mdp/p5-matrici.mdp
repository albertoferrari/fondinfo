title: Dati e matrici
subtitle: Introduzione alla programmazione
figure: images/misc/tic-tac-toe.svg

---

title: Flussi di dati
figure: images/fun/magnetic-tape.png

- **Stream**: astrazione per flussi di informazione
    - Lettura o scrittura di informazioni su *qualunque* dispositivo I/O (*file, ma non solo*)
- **File di testo**
    - Varie codifiche (*UTF-8* o altro)
    - Conversioni automatiche, es. `"\n"` → `"\r\n"`
- **File binari**
    - I/O preciso byte a byte, senza nessuna conversione
    - Qualsiasi file... anche di testo!

---

title: Scrittura su file

- Funzione `open` per accedere ad un file (di testo)
    - Modalità scrittura o lettura: `"w"`, o `"r"`
- Scrittura su file: funzione `print`, o metodo `write`
- Blocco `with`: chiude il file al termine delle operazioni (anche in caso di errore)

code: python

    with open("some_file.txt", "w") as f1:
        f1.write("First line\n")   # explicit newline
        f1.write("Second line\n")  # continue writing here...

    with open("other_file.txt", "w") as f2:
        for x in range(10):
            print(x, x ** 2, file=f2)

---

title: Lettura da file

code: python

    with open("some_file.txt", "r") as f1:
        first_line = f1.readline()
        second_line = f1.readline()
        # both strings contain '\n' at the end
        # at end of file, an empty string is read

    with open("other_file.txt", "r") as f2:
        whole_text = f2.read()
        # do stg with whole_text

    with open("last_file.txt", "r") as f3:
        for line in f3:
            # line contains '\n' at the end
            # strip() removes withespaces at both ends
            print(line.strip(), ':', len(line))

---

title: I/O su stringhe e console (⨳)

- Stringhe come stream: `io.StringIO`
- Console come stream: `sys.stdin`, `sys.stdout`, `sys.stderr`

code: python

    import io, sys

    with io.StringIO() as output:
        output.write("First line.\n")
        print("Second line.", file=output)
        # Retrieve stream contents, i.e. "First line.\nSecond line.\n"
        contents = output.getvalue()
        sys.stdout.write(contents)

code: python

    for line in sys.stdin:  # CTRL-D (Lin) or CTRL-Z (Win) to end the input
        print(len(line))    # notice '\n' at the end

---

title: Errori da file (⨳)
figure: images/fun/garbled-tape.png

- **Eccezioni**: per gestire separatamente i casi inattesi
    - Errore all'interno di `try`: esecuzione interrotta subito
    - Eseguito il blocco `except` che gestisce il tipo di errore verificatosi (possibile avere diversi blocchi `except`)
    - Il blocco `with` assicura la chiusura del file

code: python

    try:
        with open("other_file.txt", "r") as f:
            whole_text = f.read()
            # do stg with whole_text
    except IOError as err:
        print("Oh, my!")

---

title: Funzioni su sequenze
class: segue dark

---

title: List comprehension (⨳)
figure: images/dev/computer-ninja.png

- Modo conciso per creare una lista
- Ogni elemento: risultato di una operazione su un membro di altro iterabile
- Condizione sugli elementi, opzionale

code: python

    squares = [x ** 2 for x in range(12)]
    # squares = []
    # for x in range(12):
    #    squares.append(x ** 2)

code: python

    even_nums = [str(x) for x in range(12) if (x % 2) == 0]

---

title: Enumerate (⨳)
figure: images/repr/child-fingers.png
/home/mic/Documents/didattica/fondinfo/images/misc/finger-counting.png

- Accoppia ciascun valore di una sequenza ad un indice crescente
- Genera una sequenza di tuple (coppie)
- Spesso si usa nei cicli `for`, quando serve sia il valore che l'indice

code: python

    >>> grocery = ["spam", "eggs", "bacon", "ketchup"]
    >>> list(enumerate(grocery))
    [(0, "spam"), (1, "eggs"), (2, "bacon"), (3, "ketchup")]

code: python

    grocery = ["spam", "eggs", "bacon", "ketchup"]
    for i, val in enumerate(grocery):
        print(i, val)

>

Risultati in lista, solo (!) per visualizzarli <br>
Altrimenti, Python non genera immediatamente i risultati (*lazy*)

---

title: Zip (⨳)
figure: images/fun/zip.jpg

- Accoppia gli elementi di due sequenze
- Genera una sequenza di tuple (coppie)
- Il risultato ha la lunghezza della sequenza più breve

code: python

    >>> grocery = ["spam", "eggs", "bacon", "ketchup"]
    >>> quantities = ["100 g", "6 pc", "200 g", "1 bottle", "too much"]
    >>> list(zip(grocery, quantities))
    [("spam", "100 g"), ("eggs", "6 pc"), ("bacon", "200 g"),
    ("ketchup", "1 bottle")]

>

Risultati in lista, solo (!) per visualizzarli

---

title: Map (⨳)
figure: images/fun/legomap.png

- Prende come parametri una funzione ed una sequenza
- *Funzione di ordine superiore*
- Applica la funzione a ciascuno dei valori
- Restituisce la sequenza di risultati

code: python

    >>> from math import sqrt
    >>> values = [0, 1, 2, 3, 4]
    >>> list(map(sqrt, values))
    [0.0, 1.0, 1.4142, 1.7320, 2.0]

code: python

    >>> from math import sqrt
    >>> list(map(sqrt, range(5)))
    [0.0, 1.0, 1.4142, 1.7320, 2.0]

>

Risultati in lista, solo (!) per visualizzarli

---

title: Liste ordinate o rovesciate (⨳)

code: python

    >>> grocery = ["spam", "egg", "bacon", "sausage"]
    >>> sorted(grocery)
    ['bacon', 'egg', 'sausage', 'spam']
    >>> sorted(grocery, reverse=True)
    ['spam', 'sausage', 'egg', 'bacon']
    >>> sorted(grocery, key=len)  # lengths of elements are compared
    ['egg', 'spam', 'bacon', 'sausage']

code: python

    >>> list(reversed(grocery))
    ['sausage', 'bacon', 'egg', 'spam']

code: python

    >>> grocery.sort()     # in-place
    >>> grocery.reverse()  # in-place
    >>> grocery
    ['spam', 'sausage', 'egg', 'bacon']

---

title: Dizionario (⨳)
figure: images/fun/dictionary.png

- A volte chiamato *mappa* o *array associativo*
- Insieme non ordinato di coppie chiave / valore
    - Le chiavi sono *uniche*: come nelle liste fanno da *indice* per accedere al valore corrispondente
    - Ma possono essere `int` o **`str`** (o altro tipo immutabile)

code: python

    >>> tel = {"john": 4098, "terry": 4139}
    >>> tel["john"]
    4098
    >>> tel["graham"] = 4127
    >>> tel
    {"graham": 4127, "terry": 4139, "john": 4098}

>

Provare anche `list(tel)` e `list(tel.items())`

---

title: Matrici
class: segue dark

---

title: Liste multidimensionali
- Liste di liste di ...
    - Accesso agli elementi: due o più indici (o *dimensioni*)
    - Se bidimensionali, denominate *matrici*

code: python

    a = [['A', 'B', 'C', 'D'],
         ['E', 'F', 'G', 'H'],
         ['I', 'L', 'M', 'N']]          # 2D

    b = ['A', 'B', 'C', 'D',
         'E', 'F', 'G', 'H',
         'I', 'L', 'M', 'N']            # 1D

    i = y * cols + x                    # 2D -> 1D

    y = i // cols
    x = i % cols                        # 1D -> 2D

---

title: Somma colonne: matrice

code: python

    matrix = [[2, 4, 3, 8],
              [9, 3, 2, 7],
              [5, 6, 9, 1]]
    rows = len(matrix)
    cols = len(matrix[0])

    for x in range(cols):
        total = 0
        for y in range(rows):
            val = matrix[y][x]
            total += val
        print("Col #", x, "sums to", total)

---

title: Lista come pseudo-matrice

code: python

    matrix = [2, 4, 3, 8,
              9, 3, 2, 7,
              5, 6, 9, 1]
    rows = 3  # Cannot be guessed from matrix alone
    cols = len(matrix) // rows

    for x in range(cols):
        total = 0
        for y in range(rows):
            val = matrix[y * cols + x]   # 2D -> 1D
            total += val
        print("Col #", x, "sums to", total)

---

title: Matrici di dimensioni note

code: python

    matrix = [[' ' for x in range(cols)] for y in range(rows)]
    # all elements are inited as ' ' -- your need may vary

code: python

    matrix = []
    for y in range(rows):
        new_row = []
        for x in range(cols):
            new_row.append(' ')
        matrix.append(new_row)

---

title: Fifteen – Gioco astratto
figure: images/qt/fifteen-puzzle.jpg

code: Python

    def abstract():
        raise NotImplementedError("Abstract method")

    class BoardGame:
        def play_at(self, x: int, y: int): abstract()
        def flag_at(self, x: int, y: int): abstract()
        def get_val(self, x: int, y: int) -> str: abstract()
        def cols(self) -> int: abstract()
        def rows(self) -> int: abstract()
        def finished(self) -> bool: abstract()
        def message(self) -> str: abstract()

>

*Gui*: <http://www.ce.unipr.it/brython/?p5_fifteen.py>

---

title: Ciclo di gioco

code: Python

    def print_game(game: BoardGame):
        for y in range(game.rows()):
            for x in range(game.cols()):
                print('{:3}'.format(game.get_val(x, y)), end='')
            print()

    def console_play(game: BoardGame):
        print_game(game)
        while not game.finished():
            x, y = input().split()
            game.play_at(int(x), int(y))
            print_game(game)
        print(game.message())

>

*Gui*: <http://www.ce.unipr.it/brython/?boardgame_g2d.py>

---

title: Backtracking
class: segue dark

---

title: N regine, backtracking
class: large-image

![](images/fun/queens.svg)

---

title: N regine, verifica
figure: images/fun/queens-sol.svg

code: python

    def print_board(board: list):
        for y in range(len(board)):
            for x in range(len(board)):
                if x == board[y]: print('|Q', end='')
                else: print('| ', end='')
            print('|')

    def under_attack(board: list, x: int, y: int) -> bool:
        for d in range(1, y + 1):  # for all rows above y
            # directions: ↖↑↗ (no queens below)
            if board[y - d] in (x - d, x, x + d):
                return True
        return False

>

`board` è una lista di `int`: per ogni riga della scacchiera, memorizza la posizione `x` della regina

---

title: N regine, ricorsione

code: python

    def place_queens(board: list, y=0) -> bool:
        if y == len(board):
            return True  # all queens already placed
        for x in range(len(board)):
            if not under_attack(board, x, y):
                board[y] = x  # (x, y) is safe: place a queen

                # try and place queens in the following rows
                if place_queens(board, y + 1):
                    return True

                board[y] = None  # no luck, backtrack
        return False

>

<http://www.ce.unipr.it/brython/?p5_solve_queens.py>

---

title: Esercizi
class: segue dark

---

title: Sequenza di valori
figure: images/misc/data-sequence.png

- Funzione che:
    - Riceve come parametro il nome di un file
    - Restituisce una tupla con il valore massimo e quello minimo trovati nel file
    - (Ciascuna riga del file contiene un valore `float`)
- Invocare la funzione con un nome di file inserito dall'utente
- Visualizzare il risultato

>

<http://www.ce.unipr.it/brython/?p5_data_maxmin.py>

---

title: Fusione
figure: images/misc/merge-sign.png

- Due file di testo contengono sequenze di numeri
    - Un valore per ogni riga
    - In ciascun file, i valori sono già ordinati
- Scrivere in output i valori di entrambi i file
    - Sequenza di output tutta in ordine

>

Ciclicamente, confrontare la coppia dei primi valori (ciascuno proveniente da uno dei due stream) <br>
Scrivere il minore dei due sul file di uscita <br>
Non estrarre un nuovo valore da uno stream, se quello precedente non è ancora stato scritto in output 

<http://www.ce.unipr.it/brython/?p5_data_merge.py>

---

title: File CSV

- Leggere una matrice di interi da un file testuale CSV
    - *Comma Sep. Values*: valori riga per riga, separati da virgola

code: File

    5,7,2,11
    1,3,12,9
    4,6,10,8

- Memorizzare i dati in una lista semplice (pseudo-matrice)
- Inferire le dimensioni della matrice (`rows×cols`) in base a:
    - Numero di righe del file
    - Numero di valori in una riga
- Da angolo in basso a destra, sommare sulla diagonale

>

Nell'esempio, sommare: `8 + 12 + 7` (celle dove `cols - x == rows - y`)

<http://www.ce.unipr.it/brython/?p5_data_csv.py>

---

title: Incolonnamento dati

- Visualizzare due tabelle con i caratteri ASCII
    - 4 righe x 24 colonne, codici da 32 a 126
- Tabella 1: mostrare in ordine i caratteri, colonna per colonna
- Tabella 2: mostrare in ordine i caratteri, riga per riga

code: Tabella 1

     $(,048<@DHLPTX\`dhlptx|
    !%)-159=AEIMQUY]aeimquy}
    "&*.26:>BFJNRVZ^bfjnrvz~
    #'+/37;?CGKOSW[_cgkosw{

>

Usare sempre due cicli `for` annidati: esterno su `y`, interno su `x` <br>
In ogni posizione, calcolare il carattere da visualizzare: `x * ROWS + y`...

<http://www.ce.unipr.it/brython/?p5_mat_ascii.py>

---

title: Scitala spartana
figure: images/hist/scytale.png

- Leggere un intero file di testo
- Inserire in una matrice i primi W×H caratteri
    - W colonne × H righe, valori prefissati
    - Riempire una riga della matrice dopo l'altra
    - Da destra a sinistra, una riga alla volta (→, ↓)
- Scrivere il contenuto della matrice su console
    - Scrivere una colonna della matrice dopo l'altra
    - Prima riga su console = prima colonna della matrice...
    - Dall'alto verso il basso, una colonna alla volta (↓, →)

>

Usare una lista di liste (con dimensioni predefinite)

<http://www.ce.unipr.it/brython/?p5_mat_scytale.py>

---

title: Funzione di smooth
figure: images/fun/neighborhood4.png

- Scrivere una funzione `smooth`
    - Parametro: matrice iniziale, di float
    - Risultato: nuova matrice con *smooth*
    - Matrici rappresentate come liste di liste
- **Smooth**: per ogni cella in matrice iniziale
    - Il risultato è la *media* dell'intorno
    - 5 valori: cella stessa e 4 adiacenti
- Attenzione alle celle esterne
    - Sommare e contare solo i valori disponibili
    - 4 valori ai bordi, 3 valori agli angoli
- Verificare la funzione con alcune matrici di test

>

<http://www.ce.unipr.it/brython/?p5_mat_smooth.py>

---

title: Spirale
figure: images/misc/spiral.png

- Scrivere una funzione per riempire di numeri crescenti una matrice quadrata (o rettangolare)
- Seguire il percorso a spirale suggerito nella figura a fianco
- Dimensioni della matrice indicate dall'utente a runtime

>

Tenere traccia della direzione attuale (∆y, ∆x) <br>
Avanzare fino al bordo o ad una cella già visitata, <br>
poi cambiare la direzione in senso orario

Coordinate raster, rotazione oraria di 90°: `(x', y') = (-y, x)` <br>
In generale: `(x', y') = (x⋅cos(θ) - y⋅sin(θ), x⋅sin(θ) + y⋅cos(θ))` <br>

>

<http://www.ce.unipr.it/brython/?p5_mat_spiral.py>

---

title: Puzzle di Cindy
figure: images/misc/cindy1.png images/misc/cindy2.png

- Piano di gioco: `2n+1` celle allineate
    - Si parte con `n` pedine rosse tutte a sinistra, `n` pedine verdi tutte a destra, ed una cella libera in mezzo
    - Le pedine rosse si possono spostare solo a destra, quelle verdi solo a sinistra (senza poter tornare indietro)
- Ad ogni mossa, una qualsiasi pedina può:
    - Avanzare di una posizione, se davanti ha una cella libera
    - Oppure scavalcare esattamente una pedina dell'altro colore, se c'è una cella libera subito dopo
- L'applicazione deve trovare *automaticamente* le mosse per invertire la posizione di tutte le pedine

>

<http://www.cis.upenn.edu/~matuszek/cit594-2012/Pages/backtracking.html>

<http://www.ce.unipr.it/brython/?p5_solve_cindy.py>

