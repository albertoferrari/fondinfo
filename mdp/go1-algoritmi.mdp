title: Algoritmi in Go
subtitle: Introduzione alla programmazione
figure: images/algo/rubik-cube.png

---

title: Less is exponentially more

- Progetto avviato nel ~2007 presso Google, partendo dal C
    - Pionieri di Unix: Rob *Pike* e Ken *Thompson*, con Robert Griesemer
    - Libro: ‚ÄúThe Go Programming Language‚Äù by Brian W. *Kernighan*, Alan Donovan
- Pochi concetti, tra loro ortogonali
    - Senza *eccezioni*, n√© *template*, n√© *ereditariet√†*
    - *Interfacce* e *duck typing*, *Type inference*
    - *Garbage collection*, ma codice *nativo* (senza macchina virtuale)
    - *Communicating sequential processes*

>

Dopo una presentazione di 35 nuove caratteristiche del C++11, durante le pause per compilare codice C++...
<https://commandcenter.blogspot.it/2012/06/less-is-exponentially-more.html>

---

title: Hello, World!
figure: images/algo/helloworld.png

- Il programma parte dalla funzione **`main`** nel modulo `main`
- Modulo **`fmt`** per operazioni di I/O

code: go

    package main

    import "fmt"

    func main() {
        fmt.Println("Hello, World!")
    }

code: shell

    go run hello.go

---

title: Hello, browser!

- Modulo speciale **`g2d`**
    - Supporto per browser
    - Disegno su canvas

code: go

    package main

    import "g2d"

    func main() {
        g2d.Println("Hello, browser!")
    }

---

title: Tipi di dati

- Un **tipo di dato** specifica un insieme di *valori* e le *operazioni* ammesse
    - `int, float64, bool, string`
    - Operazioni aritmetiche e logiche, confronti

code: go

    package main

    import . "g2d"  // to skip the prefix

    func main() {
        Println(3.0 / 2)  // 1.5
        Println(3 / 2)    // 1, truncated
        Println(3 % 2)    // 1, reminder
        Println(4 == 5)   // false, do not confuse with assignment!
        Println(2 < 3 || ! true)  // true
    }

---

title: Valori numerici e booleani

- **`int`** o **`float64`**, per numeri interi o reali
    - Operazioni di base: `+, -, *, /, %`
    - Divisione tra interi d√† risultato intero
    - Confronti: `<, <=, >, >=, ==, !=`
-  **`bool`**, per valori booleani: `true, false`
    - Operazioni consentite: `&&, ||, !`
    - I confronti danno un risultato booleano

---

title: Variabile
figure: images/algo/my-shoes.png

- Le comuni variabili sono *contenitori* di dati
- Occorrono **dichiarazioni** di tipo
    - Valore iniziale `0` o `""`, quando non specificato
- Possibile *type inference* (`:=`)
    - *Tipo* inferito dal valore di inizializzazione

code: go

    var i, j int = 1, 2
    k := 3.2
    ans, txt := true, "no!"

    Println(i, j, k, ans, txt)

---

title: Riassegnamento
figure: images/algo/assign.png
class: large-figure

- Riassegnamento, operatore `=`
    - Alla sinistra una variabile *gi√† definita*
    - Alla destra un valore
- *Non confondere* con confronto di uguaglianza `==`

code: go

    pi := 3.14       // definition and initialization
    radius := 2.2
    area := pi * (radius * radius)
    Println(area)    // 15.1976
    radius = radius + 1
    Println(radius)  // guess radius now
    Println(area)    // ... and area!

---

title: Stringhe di testo

- **`string`** per sequenze di caratteri *Unicode*
- Ogni carattere √® di tipo `rune` (`int32`)
- Primi 128 codici *Unicode* == *ASCII*
- Confronto, in ordine *lessicografico*

code: go

    str1 := "Hello,"
    str2 := " üåê"
    result := str1 + str2
    Println(result)              // "Hello, üåê"

    Println("first" < "second")  // true
    Println("Second" < "first")  // true
    Println('üåê' == 127760)      // true

---

title: Tabella ASCII
class: large-image

![](images/repr/ascii.png)

---

title: Leggere e scrivere
figure: images/algo/hello-user.svg

- **`g2d.Prompt`** chiede un *testo* all'utente
    - Mostra un messaggio
    - Poi blocca il programma in attesa
    - Risultato sempre di tipo `string`

code: go

    user := Prompt("What's your name? ")
    Println("Hello, ", user)

---

title: Somma di tre numeri
figure: images/algo/sum3.svg

- `g2d.ParseInt`
    - Conversione da `string` a `int`
- `g2d.ParseFloat`
    - Conversione da `string` a `float64`

code: go

    a := ParseFloat(Prompt("Insert 1st val: "))
    b := ParseFloat(Prompt("Insert 2nd val: "))
    c := ParseFloat(Prompt("Insert 3rd val: "))

    total := a + b + c
    Println("The sum is ", total)

---

title: Strutture di controllo
class: segue dark

---

title: Selezione: if

- Corpo di `if` o `else` tra graffe
    - *Indentazione* per migliore leggibilit√†
- Clausola `else`: opzionale
    - Eseguita sse la condizione non √® verificata

code: go

    age := ParseInt(Prompt("Age?"))

    if age < 14 {
        Println("You're too young for driving a scooter...")
        Println("But not for learning Go!")
    }

---

title: Valore assoluto
figure: images/algo/abs.svg

code: go

    x := ParseFloat(Prompt("insert a value:"))
    y := 0.0

    if x >= 0 {
        y = x
        Println(x, " is positive")
    } else {
        y = -x
        Println(x, " is negative")
    }
    Println("abs = ", y)

- Corpo di `if` o `else`: qualsiasi istruzione
- Anche altri blocchi `if` o `for` annidati!

---

title: Calcolo dell'et√† ü§î

code: go

    birthYear := ParseInt(Prompt("Birth year? "))
    birthMonth := ParseInt(Prompt("Birth month? "))
    birthDay := ParseInt(Prompt("Birth day? "))
    currentYear := ParseInt(Prompt("Current year? "))
    currentMonth := ParseInt(Prompt("Current month? "))
    currentDay := ParseInt(Prompt("Current day? "))

    age := currentYear - birthYear
    if currentMonth < birthMonth
        || (currentMonth == birthMonth && currentDay < birthDay) {
        age = age - 1
    }

    Println("Your age is ", age)

>

Espressione booleana composta con **`and`** e **`or`**

---

title: Confronto tra parole
figure: images/algo/words.svg

code: go

    a := Prompt("First word? ")
    b := Prompt("Second word? ")

    if a < b {
        Println("The words are ordered")
    } else if a > b {
        Println("The words are inverted")
    } else {
        Println("The words are equal")
    }

---

title: Operazioni aritmetiche
figure: images/algo/calc.svg

code: go

    a := ParseFloat(Prompt("a? "))
    b := ParseFloat(Prompt("b? "))
    op := Prompt("op? ")

    if op == "+" {
        Println(a + b)
    } else if op == "-" {
        Println(a - b)
    } else if op == "*" {
        Println(a * b)
    } else if op == "/" && b != 0 {
        Println(a / b)
    } else {
        Println("Operation not allowed")
    }

---

title: Iterazione: for
figure: images/algo/sum1n.svg

- Condizione di *permanenza* nel ciclo
- Controllo *preliminare*
- Possibile che il corpo non sia mai eseguito

code: go

    // Sum of the numbers from 1 to n
    total := 0
    count := 1
    n := ParseInt(Prompt("n? "))

    for count <= n {
        total = total + count
        count = count + 1
    }
    Println("The sum is ", total)

>

<http://it.wikipedia.org/wiki/Gauss#Biografia>

---

title: Somma di N valori dell'utente
figure: images/algo/sumn.svg

code: go

    n := ParseInt(Prompt("How many values? "))
    total := 0
    i := 0

    for i < n {
        val := ParseInt(Prompt("Val? "))

        total += val  // total = total + val
        i += 1        // i = i + 1
    }
    Println("The sum is ", total)

---

title: Ciclo con sentinella
figure: images/algo/average.svg

code: go

    total, count := 0, 0
    val := ParseInt(Prompt("Val? (0 to finish) "))
    for val != 0 {
        total += val
        count += 1
        val = ParseInt(Prompt("Val? (0 to finish) "))
    }
    if count != 0 {
        Println("The average is ",
                float64(total) / float64(count))
    }

- Usare `int(x)` e `float64(x)`...
- Per convertire un numero nel tipo giusto

---

title: Quadrato perfetto ü§î
figure: images/algo/perfect-square.svg

code: go

    for n <= 0 {
        n = ParseInt(Prompt("Positive val? "))
    }
    ans := 1
    for ans * ans < n {
        ans += 1
    }
    if ans * ans == n {
        Println("Square root:", ans)
    } else {
        Println("Not a perfect square")
    }

>

<http://www.ce.unipr.it/gopherjs/?p1_draw.go>

---

title: Moduli

code: go

    package main

    import (
        "g2d"
        "math"
    )

    func main() {
        y := math.Sin(math.Pi / 4.0)
        g2d.Println(y)

        die1 := g2d.RandInt(1, 6)  // like rolling a die
        die2 := g2d.RandInt(1, 6)  // like rolling a die
        g2d.Println(die1, die2)
    }

>

<https://golang.org/pkg/>

---

title: Strutture per grafica

- Strutture definite nel modulo `g2d`
- Esportati da modulo solo nomi con la prima lettera **maiuscola**


code: go

    type Point struct{ X, Y int }
    type Size struct{ W, H int }
    type Rect struct{ X, Y, W, H int }
    type Color struct{ R, G, B int }

code: go

    center := Point{150, 100}
    myBlue := Color{10, 10, 200}  // each component in 0..255
    windowSize := Size{640, 480}
    rectangle := Rect{150, 100, 200, 200}  // square

---

title: Disegno nel browser
figure: images/oop/raster-coord.png

code: go

    package main

    import . "g2d"

    func main() {
        // Create canvas, width=600, height=400
        InitCanvas(Size{600, 400})

        // Yellow rectangle, left=150, top=100, w=250, h=200
        // red=255 (max), green=255 (max), blue=0 (min)
        DrawRect(Color{255, 255, 0}, Rect{150, 100, 250, 200})

        // Blue circle, center=(400, 400), radius=20
        DrawCircle(Color{0, 0, 255}, Point{400, 300}, 20)
    }

---

title: Linee e testi
figure: images/oop/raster-coord.png

code: go

    package main

    import . "g2d"

    func main() {
        InitCanvas(Size{600, 400})

        // Green line from (150, 300) to (400, 100)
        DrawLine(Color{0, 255, 0}, Point{150, 300}, Point{400, 100})

        // Red text, left=150, top=100, size=40
        DrawText("Hello", Color{255, 0, 0}, Point{150, 100}, 40)
    }

>

<http://www.ce.unipr.it/gopherjs/?p1_draw.go>

<http://www.ce.unipr.it/gopherjs/?p1_red_squares.go>

---

title: Esercizi
class: segue dark

---

title: 1.1 Cerchio
figure: images/misc/greek-pi.png

- Chiedere all'utente il valore del raggio `r` di un cerchio
- Mostrare il valore dell'area e della circonferenza
- Se `r` √® negativo, per√≤, mostrare un messaggio d'errore

---

title: 1.2 Minore e maggiore
figure: images/misc/three-brothers.png

- Generare e stampare tre numeri interi casuali: `a`, `b`, `c`
- Ciascuno compreso tra 1 e 6
- Determinare e mostrare qual √® il minore dei tre

>

Controllare prima di tutto se `a` √® minore degli altri due <br>
Altrimenti controllare se `b` √® minore di `c` <br>
Altrimenti ...

---

title: 1.3 Quadrati casuali
figure: images/misc/random-squares.png

- Chiedere all'utente un numero `n`
- Disegnare `n` quadrati
    - Tutti con lato di 100 pixel
    - Ciascuno in posizione casuale
    - Ciascuno con un colore casuale

>

Cominciare a disegnare un solo quadrato grigio, in posizione casuale

---

title: 1.4 Fila di quadrati
figure: images/misc/red-squares.png

- Chiedere all'utente un numero `n`
- Disegnare `n` quadrati
    - Tutti con lato di 100 pixel
    - Tutti sulla diagonale, distanziati uniformemente
    - Ciascuno colorato con una sfumatura di rosso via via pi√π accesa

>

Soluzione bozza: ad ogni passo aggiungere `10` (p.es.) alla posizione e al livello di rosso

Soluzione finale: determinare automaticamente, prima del ciclo, le variazioni migliori per posizione e colore

---

title: 1.5 Numero segreto
figure: images/misc/bingo-balls.png

- Generare all'inizio del programma un numero ‚Äúsegreto‚Äù a caso tra 1 e 90
- Chiedere ripetutamente all'utente di immettere un numero, finch√© non indovina quello generato
- Ad ogni tentativo, dire se il numero immesso √® maggiore o minore del numero segreto

---

title: 1.6 Interesse composto (*)
figure: images/misc/uncle-scrooge.png

- Dati dall'utente: capitale iniziale, tasso d'interesse, durata investimento
- Calcolare il capitale dopo ogni anno
- Es. 100‚Ç¨ al 4.5%: <br><br>

code: output

	Anno 0: 100.00‚Ç¨
	Anno 1: 104.50‚Ç¨
	Anno 2: 109.20‚Ç¨
	Anno 3: 114.12‚Ç¨ ...

>

Non preoccuparsi della formattazione in colonna

---

title: 1.7 Resistenze, ciclo (*)
figure: images/misc/resistors.png

- Leggere, attraverso un ciclo, una sequenza di valori di resistenze elettriche
- La sequenza termina quando l'utente immette il valore 0
- Alla fine, visualizzare la resistenza equivalente, sia nel caso di resistenze disposte in serie, che in parallelo

>

Formule utili:

R~~s~~ = ‚àë R~~i~~

1/R~~p~~ = ‚àë (1/R~~i~~)

---

title: 1.8 Orologio classico (*)
figure: images/misc/classical-watch.jpg

- Disegnare 12 tacche a raggiera, come in un orologio classico
- Miglioramento: disegnare anche le tacche dei minuti, pi√π piccole

>

Usare `math.Sin` e `math.Cos` per determinare le posizioni in cui disegnare

---

title: 1.9 La stanza del mostro (*)
figure: images/misc/monster.png

- Il giocatore si muove su una scacchiera di 5x5 celle, partendo da un angolo
    - Le righe e le colonne sono numerate da 0 a 4
- Un tesoro ed un mostro sono nascosti in due posizioni casuali, all'inizio del gioco
- Ad ogni turno, il giocatore:
    - Sceglie una direzione verso cui spostarsi (alto, basso, sinistra, destra)
    - Se capita sulla cella del tesoro, ha vinto
    - Se capita sulla cella del mostro, ha perso

