<!--
Google IO 2012 HTML5 Slide Template

Authors: Eric Bidelman <ebidel@gmail.com>
         Luke Mahe <lukem@google.com>

URL: https://code.google.com/p/io-2012-slides
-->
<!DOCTYPE html>
<html>
<head>
  <title>Ricorsione e file</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="stylesheet" media="all" href="theme/css/default.css">
  <link rel="stylesheet" media="all" href="theme/css/tomamic.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="theme/css/phone.css">
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
  <script data-main="js/slides" src="js/require-1.0.8.min.js"></script>
</head>
<body style="opacity: 0">

<slides class="layout-widescreen">

<slide class="title-slide segue nobackground">
  <aside class="gdbar"><img src="images/logo.png"></aside>
  <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
  <h1 data-config-title><!-- populated from slide_config.json --></h1>
  <figure><img src="images/fun/matryoshka.png"></figure>
  <hgroup>
    <h2>Introduzione alla programmazione</h2>
    <p>Michele Tomaiuolo<br>Ingegneria dell'Informazione, UniPR</p>
  </hgroup>
</slide>


<slide  >
  
    <hgroup>
      <h2>Programmazione ricorsiva</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Molti linguaggi consentono ad una funzione (o procedura) di chiamare se stessa</li>
<li>Chiamata ricorsiva, diretta o indiretta</li>
</ul>
<p><img alt="" src="images/fun/recursion.svg" /></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Fattoriale, ricorsione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/fun/stack.svg">
        
      </figure><ul>
<li>Ad ogni invocazione di una funzione, viene creato nello <strong>stack</strong> un nuovo record</li>
<li><strong>Contesto locale</strong> alla particolare attivazione della funzione stessa</li>
</ul>
<pre class="prettyprint" data-lang="python"><code>def factorial(n: int) -&gt; int:
    result = 1
    if n &gt; 1:
        result = n * factorial(n - 1)
    return result
</code></pre>
<p>Ai primordi (Fortran 66 ecc.) solo allocazione statica <br> Spazio fisso ed unico per dati locali ad una funzione → no ricorsione</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Stack dell'applicazione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/fun/books-stack.png">
        
      </figure><ul>
<li>Pila: memoria dinamica <em>LIFO (Last In First Out)</em><ul>
<li>Dimensione massima prefissata</li>
</ul>
</li>
<li>Il programma ci memorizza automaticamente:<ul>
<li><strong>Indirizzo di ritorno</strong> per la funzione <br> Inserito alla chiamata, estratto all'uscita</li>
<li><strong>Parametri</strong> della funzione <br> Inseriti alla chiamata, eliminati all'uscita</li>
<li><strong>Variabili locali</strong>, definite nella funzione <br> Eliminate fuori dall'ambito di visibilità</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide class="large-image" >
  
    <hgroup>
      <h2>Vista semplificata dello stack</h2>
      <h3></h3>
    </hgroup>
    <article >
      <p><img alt="" src="images/fun/stack-content.svg" /></p></article>
 
</slide>

<slide class="large-image" >
  
    <hgroup>
      <h2>Record di attivazione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <p><img alt="" src="images/fun/records.svg" /></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Visibilità di una variabile</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Insieme di istruzioni da cui è accessibile<ul>
<li><em>Ciclo di vita</em>: esistenza in memoria della var (etichetta)</li>
<li>I valori (oggetti) in Python sono tutti gestiti dinamicamente</li>
</ul>
</li>
<li>Visibilità <strong>globale</strong><ul>
<li>Variabili fuori da ogni funzione - <em>Meglio evitare!</em></li>
<li>Allocazione <em>statica</em> in alcuni linguaggi</li>
</ul>
</li>
<li>Visibilità <strong>locale</strong> alla funzione<ul>
<li>Variabili locali e parametri</li>
<li>Allocazione <em>automatica</em> di spazio in <em>stack</em> ad ogni attivazione della funzione (possibile la ricorsione)</li>
</ul>
</li>
<li>Visibilità locale al blocco (es. <code>if</code>): non in Python!</li>
</ul></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Esempi di ricorsione</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide class="large-image" >
  
    <hgroup>
      <h2>I conigli di Fibonacci</h2>
      <h3></h3>
    </hgroup>
    <article >
      <p><img alt="" src="images/fun/fib-rabbits.png" /></p>
<blockquote></blockquote>
<p>fib(0) = fib(1) = 1;  fib(n) = fib(n-1) + fib(n-2);</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Fibonacci, ricorsione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="python"><code>def fibonacci(n: int) -&gt; int:
    result = 1
    if n &gt; 1:
        result = fibonacci(n-1) + fibonacci(n-2)
    return result
</code></pre>
<p><img alt="" src="images/fun/fib-calls.svg" /></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Fibonacci, memoization</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="python"><code>_fibonacci_lookup = [1, 1]

def fibonacci(n: int) -&gt; int:
    if n &lt; len(_fibonacci_lookup):
        return _fibonacci_lookup[n]
    result = fibonacci(n - 1) + fibonacci(n - 2)
    _fibonacci_lookup.append(result)
    return result
</code></pre>
<pre class="prettyprint" data-lang="python"><code>from functools import lru_cache

@lru_cache()                   # function decoration
def fibonacci(n: int) -&gt; int:
    result = 1
    if n &gt; 1:
        result = fibonacci(n-1) + fibonacci(n-2)
    return result
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Fibonacci, iterazione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="python"><code>def fibonacci(n: int) -&gt; int:
    value = 1
    previous = 0

    for i in range(n):
        value, previous = value + previous, value

    return value
</code></pre></article>
 
</slide>

<slide class="large-image" >
  
    <hgroup>
      <h2>N regine, backtracking</h2>
      <h3></h3>
    </hgroup>
    <article >
      <p><img alt="" src="images/fun/queens.svg" /></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>N regine, verifica</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/fun/queens-sol.svg">
        
      </figure><pre class="prettyprint" data-lang="python"><code>def print_board(board: list):
    for y in range(len(board)):
        for x in range(len(board)):
            if x == board[y]: print('|Q', end='')
            else: print('| ', end='')
        print('|')

def under_attack(board: list, x: int, y: int) -&gt; bool:
    for i in range(y):  # for all rows above y
        d = y - i
        # directions: ↖↑↗ (no queens below)
        if board[i] in (x - d, x, x + d):
            return True
    return False
</code></pre>
<blockquote></blockquote>
<p><code>board</code> è una lista di <code>int</code>: per ogni riga della scacchiera, memorizza la posizione <code>x</code> della regina</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>N regine, ricorsione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="python"><code>def place_queens(board: list, y=0) -&gt; bool:
    if y == len(board):
        return True  # all queens already placed
    for x in range(len(board)):
        if not under_attack(board, x, y):
            board[y] = x  # (x, y) is safe: place a queen

            # try and place queens in the following rows
            if place_queens(board, y + 1):
                return True

            board[y] = None  # no luck, backtrack
    return False
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Esercizio - Massimo Comun Divisore</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/hist/euclid.jpg">
        
      </figure><ul>
<li>Leggere due numeri</li>
<li>Calcolare in una funzione il loro Massimo Comun Divisore</li>
<li>Visualizzare il risultato della funzione</li>
</ul>
<blockquote></blockquote>
<p>Provare ad usare sia l'iterazione che la ricorsione</p>
<p>Euclide: MCD(a, b) = a, se b = 0; <br>
MCD(a, b) = MCD(b, a mod b), se b &gt; 0</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Esercizio - Torre di Hanoi</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/hanoi-tower.png">
        
      </figure><ul>
<li>Tre paletti + N dischi di diametro decrescente</li>
<li>Portare tutti i dischi dal primo all'ultimo paletto</li>
<li>Si può spostare solo un disco alla volta</li>
<li>Non si può mettere un disco su uno più piccolo</li>
</ul>
<blockquote></blockquote>
<p>Usare la ricorsione. Immediato spostare un solo disco. <br>
N dischi: spostarne N-1 sul piolo né origine né dest., <br>
spostare l'ultimo disco sul piolo giusto, <br>
spostare ancora gli altri N-1 dischi.</p></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Sequenze annidate</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>List comprehension (++)</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/ninjago-green.jpg">
        
      </figure><ul>
<li>Modo conciso per creare una lista</li>
<li>Ogni elemento: risultato di una operazione su un membro di altro iterabile</li>
<li>Condizione sugli elementi, opzionale</li>
</ul>
<pre class="prettyprint" data-lang="python"><code>squares = [x ** 2 for x in range(12)]
# squares = []
# for x in range(12):
#    squares.append(x ** 2)
</code></pre>
<pre class="prettyprint" data-lang="python"><code>even_nums = [str(x) for x in range(12) if (x % 2) == 0]
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Enumerate (++)</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/repr/child-fingers.png">
        
      </figure><ul>
<li>Accoppia ciascun valore di una sequenza ad un indice crescente</li>
<li>Genera una sequenza di tuple (coppie)</li>
<li>Spesso si usa nei cicli <code>for</code>, quando serve sia il valore che l'indice</li>
</ul>
<pre class="prettyprint" data-lang="python"><code>&gt;&gt;&gt; shopping_list = ["spam", "eggs", "bacon", "ketchup"]
&gt;&gt;&gt; list(enumerate(shopping_list))
[(0, "spam"), (1, "eggs"), (2, "bacon"), (3, "ketchup")]
</code></pre>
<pre class="prettyprint" data-lang="python"><code>shopping_list = ["spam", "eggs", "bacon", "ketchup"]
for i, val in enumerate(shopping_list):
    print(i, val)
</code></pre>
<p>Risultati in lista, solo (!) per visualizzarli <br>
Altrimenti, Python non genera immediatamente i risultati (<em>lazy</em>)</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Zip (++)</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/fun/zip.jpg">
        
      </figure><ul>
<li>Accoppia gli elementi di due sequenze</li>
<li>Genera una sequenza di tuple (coppie)</li>
<li>Il risultato ha la lunghezza della sequenza più breve</li>
</ul>
<pre class="prettyprint" data-lang="python"><code>&gt;&gt;&gt; shopping_list = ["spam", "eggs", "bacon", "ketchup"]
&gt;&gt;&gt; quantities = ["100 g", "6 pc", "200 g", "1 bottle", "too much"]
&gt;&gt;&gt; list(zip(shopping_list, quantities))
[("spam", "100 g"), ("eggs", "6 pc"), ("bacon", "200 g"),
("ketchup", "1 bottle")]
</code></pre>
<p>Risultati in lista, solo (!) per visualizzarli</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Map (++)</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/fun/legomap.png">
        
      </figure><ul>
<li>Prende come parametri una funzione ed una sequenza</li>
<li><em>Funzione di ordine superiore</em></li>
<li>Applica la funzione a ciascuno dei valori</li>
<li>Restituisce la sequenza di risultati</li>
</ul>
<pre class="prettyprint" data-lang="python"><code>&gt;&gt;&gt; from math import sqrt
&gt;&gt;&gt; values = [0, 1, 2, 3, 4]
&gt;&gt;&gt; list(map(sqrt, values))
[0.0, 1.0, 1.4142, 1.7320, 2.0]
</code></pre>
<pre class="prettyprint" data-lang="python"><code>&gt;&gt;&gt; from math import sqrt
&gt;&gt;&gt; list(map(sqrt, range(5)))
[0.0, 1.0, 1.4142, 1.7320, 2.0]
</code></pre>
<p>Risultati in lista, solo (!) per visualizzarli</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Dizionario (++)</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/fun/dictionary.png">
        
      </figure><ul>
<li>A volte chiamato <em>mappa</em> o <em>array associativo</em></li>
<li>Insieme non ordinato di coppie chiave / valore<ul>
<li>Le chiavi sono <em>uniche</em>: come nelle liste fanno da <em>indice</em> per accedere al valore corrispondente</li>
<li>Ma possono essere <code>int</code> o <strong><code>str</code></strong> (o altro tipo immutabile)</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="python"><code>&gt;&gt;&gt; tel = {"john": 4098, "terry": 4139}
&gt;&gt;&gt; tel["john"]
4098
&gt;&gt;&gt; tel["graham"] = 4127
&gt;&gt;&gt; tel
{"graham": 4127, "terry": 4139, "john": 4098}
</code></pre>
<p>Provare anche <code>list(tel)</code> e <code>list(tel.items())</code></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Liste multidimensionali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="python"><code>a = [['A', 'B', 'C', 'D'],
     ['E', 'F', 'G', 'H'],
     ['I', 'L', 'M', 'N']]          # 2D

b = ['A', 'B', 'C', 'D',
     'E', 'F', 'G', 'H',
     'I', 'L', 'M', 'N']            # 1D

i = y * cols + x                    # 2D -&gt; 1D

y = i // cols
x = i % cols                        # 1D -&gt; 2D
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Somma colonne: matrice</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="python"><code>matrix = [[2, 4, 3, 8],
          [9, 3, 2, 7],
          [5, 6, 9, 1]]
rows = len(matrix)
cols = len(matrix[0])

for x in range(cols):
    total = 0
    for y in range(rows):
        val = matrix[y][x]
        total += val
    print("Col #", x, "sums to", total)
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Lista come pseudo-matrice</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="python"><code>matrix = [2, 4, 3, 8,
          9, 3, 2, 7,
          5, 6, 9, 1]
rows = 3  # Cannot be guessed from matrix alone
cols = len(matrix) // rows

for x in range(cols):
    total = 0
    for y in range(rows):
        val = matrix[y * cols + x]   # 2D -&gt; 1D
        total += val
    print("Col #", x, "sums to", total)
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Matrici di dimensioni note</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="python"><code>matrix = [[' ' for x in range(cols)] for y in range(rows)]
# all elements are inited as ' ' -- your need may vary
</code></pre>
<pre class="prettyprint" data-lang="python"><code>matrix = []
for y in range(rows):
    new_row = []
    for x in range(cols):
        new_row.append(' ')
    matrix.append(new_row)
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Flussi di dati</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/fun/magnetic-tape.png">
        
      </figure><ul>
<li><strong>Stream</strong>: astrazione per flussi di informazione<ul>
<li>Lettura o scrittura di informazioni su <em>qualunque</em> dispositivo I/O (<em>file, ma non solo</em>)</li>
</ul>
</li>
<li><strong>File di testo</strong><ul>
<li>Varie codifiche (<em>UTF-8</em> o altro)</li>
<li>Conversioni automatiche, es. <code>"\n"</code> → <code>"\r\n"</code></li>
</ul>
</li>
<li><strong>File binari</strong><ul>
<li>I/O preciso byte a byte, senza nessuna conversione</li>
<li>Qualsiasi file... anche di testo!</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Scrittura su file</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Funzione <code>open</code> per accedere ad un file (di testo)<ul>
<li>Modalità scrittura o lettura: <code>"w"</code>, o <code>"r"</code></li>
</ul>
</li>
<li>Scrittura su file: funzione <code>print</code>, o metodo <code>write</code></li>
<li>Blocco <code>with</code>: chiude il file al termine delle operazioni (anche in caso di errore)</li>
</ul>
<pre class="prettyprint" data-lang="python"><code>with open("some_file.txt", "w") as f1:
    f1.write("First line\n")   # explicit newline
    f1.write("Second line\n")  # continue writing here...

with open("other_file.txt", "w") as f2:
    for x in range(10):
        print(x, x ** 2, file=f2)
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Lettura da file</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="python"><code>with open("some_file.txt", "r") as f1:
    first_line = f1.readline()
    second_line = f1.readline()
    # both strings contain '\n' at the end
    # at end of file, an empty string is read

with open("other_file.txt", "r") as f2:
    whole_text = f2.read()
    # do stg with whole_text

with open("last_file.txt", "r") as f3:
    for line in f3:
        # line contains '\n' at the end
        # strip() removes withespaces at both ends
        print(line.strip(), ':', len(line))
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>I/O su stringhe e console (++)</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Stringhe come stream: <code>io.StringIO</code></li>
<li>Console come stream: <code>sys.stdin</code>, <code>sys.stdout</code>, <code>sys.stderr</code></li>
</ul>
<pre class="prettyprint" data-lang="python"><code>import io, sys

with io.StringIO() as output:
    output.write("First line.\n")
    print("Second line.", file=output)
    # Retrieve stream contents, i.e. "First line.\nSecond line.\n"
    contents = output.getvalue()        
    sys.stdout.write(contents)
</code></pre>
<pre class="prettyprint" data-lang="python"><code>for line in sys.stdin:  # CTRL-D (Lin) or CTRL-Z (Win) to end the input
    print(len(line))    # notice '\n' at the end
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Errori da file (++)</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/fun/garbled-tape.png">
        
      </figure><ul>
<li><strong>Eccezioni</strong>: per gestire separatamente i casi inattesi<ul>
<li>Errore all'interno di <code>try</code>: esecuzione interrotta subito</li>
<li>Eseguito il blocco <code>except</code> che gestisce il tipo di errore verificatosi (possibile avere diversi blocchi <code>except</code>)</li>
<li>Il blocco <code>with</code> assicura la chiusura del file</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="python"><code>try:
    with open("other_file.txt", "r") as f:
        whole_text = f.read()
        # do stg with whole_text
except IOError as err:
    print("Oh, my!")
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Esercizio - Memory</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/memory.png">
        
      </figure><ul>
<li>Allocare una lista, di dimensione <code>rows×cols</code><ul>
<li>L'utente sceglie <code>rows</code> e <code>cols</code>, però celle in numero pari</li>
</ul>
</li>
<li>Inserire in ordine le prime lettere dell'alfabeto, ciascuna ripetuta due volte</li>
<li>Mescolare le celle<ul>
<li>Per ciascuna cella, scegliere una posizione a caso e scambiare il contenuto delle celle</li>
</ul>
</li>
<li>Mostrare all'utente la lista risultante, andando a capo per ogni riga</li>
</ul>
<blockquote></blockquote>
<p>Usare una lista semplice, ma nella visualizzazione introdurre dei ritorni a capo</p>
<p>Cella a inizio riga: il suo indice <code>i</code> è multiplo di <code>cols</code>, ossia <code>i % cols == 0</code>
<br>
Cella a fine riga: <code>i % cols == cols - 1</code></p>
<p>Per cominciare, inserire nella lista valori numerici crescenti, anzichè lettere</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Esercizio - Scitala spartana</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/hist/scytale.png">
        
      </figure><ul>
<li>Leggere un intero file di testo</li>
<li>Inserire in una matrice i primi W×H caratteri<ul>
<li>W colonne × H righe, valori prefissati</li>
<li>Riempire una riga della matrice dopo l'altra</li>
<li>Da destra a sinistra, una riga alla volta (→, ↓)</li>
</ul>
</li>
<li>Scrivere il contenuto della matrice su console<ul>
<li>Scrivere una colonna della matrice dopo l'altra</li>
<li>Prima riga su console = prima colonna della matrice...</li>
<li>Dall'alto verso il basso, una colonna alla volta (↓, →)</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Usare una lista di liste (con dimensioni predefinite)</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Esercizio - Spirale</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/spiral.png">
        
      </figure><ul>
<li>Scrivere una funzione per riempire di numeri crescenti una matrice quadrata (o rettangolare)</li>
<li>Seguire il percorso a spirale suggerito nella figura a fianco</li>
<li>Dimensioni della matrice indicate dall'utente a runtime</li>
</ul>
<blockquote></blockquote>
<p>Tenere traccia della direzione attuale (∆y, ∆x) <br>
Avanzare fino al bordo o ad una cella già visitata, <br>
poi cambiare la direzione in senso orario</p>
<p>Coordinate raster, rotazione oraria di 90°: <code>(x', y') = (-y, x)</code> <br>
In generale: <code>(x', y') = (x⋅cos(θ) - y⋅sin(θ), x⋅sin(θ) + y⋅cos(θ))</code> <br></p></article>
 
</slide>


<slide class="thank-you-slide segue nobackground">
  <aside class="gdbar right"><img src="images/logo.png"></aside>
  <article class="flexbox vleft auto-fadein">
    <h2>&lt;Domande?&gt;</h2>
  </article>
  <p class="auto-fadein" data-config-contact>
    Michele Tomaiuolo
    <br>
    Palazzina 1, int. 5708
    <br>
    Ingegneria dell'Informazione, UniPR
    <br>
    <a href="http://www.ce.unipr.it/people/tomamic">www.ce.unipr.it/people/tomamic</a>
  </p>
</slide>

<slide class="backdrop"></slide>

</slides>

</body>
</html>