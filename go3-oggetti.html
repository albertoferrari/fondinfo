<!--
Google IO 2012 HTML5 Slide Template

Authors: Eric Bidelman <ebidel@gmail.com>
         Luke Mahe <lukem@google.com>

URL: https://code.google.com/p/io-2012-slides
-->
<!DOCTYPE html>
<html>
<head>
  <title>Oggetti e grafica</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="stylesheet" media="all" href="theme/css/default.css">
  <link rel="stylesheet" media="all" href="theme/css/tomamic.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="theme/css/phone.css">
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
  <script data-main="js/slides" src="js/require-1.0.8.min.js"></script>
</head>
<body style="opacity: 0">

<slides class="layout-widescreen">

<slide class="title-slide segue nobackground">
  <aside class="gdbar"><img src="images/logo.png"></aside>
  <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
  <h1 data-config-title><!-- populated from slide_config.json --></h1>
  <figure><img src="images/oop/modules.png"></figure>
  <hgroup>
    <h2>Introduzione alla programmazione</h2>
    <p>Michele Tomaiuolo<br>Ingegneria dell'Informazione, UniPR</p>
  </hgroup>
</slide>


<slide  >
  
    <hgroup>
      <h2>Puntatori</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/pointer.png">
        
      </figure><ul>
<li>Ogni dato in memoria ha un indirizzo</li>
<li>Variabile puntatore per memorizzarlo</li>
<li><em>Referenziazione</em>: <code>&amp;</code> per indirizzo di un dato</li>
<li><em>Dereferenziazione</em>: <code>*</code> per accesso a dato puntato</li>
</ul>
<pre class="prettyprint" data-lang="go"><code>var i int8 = 56  // a byte
var p *int8      // a ptr to some byte (uninitialized)
p = &amp;i           // now p points to i
*p = *p + 1      // i++
Println(*p, i)
p = nil          // ptr to nothing
</code></pre>
<blockquote></blockquote>
<p>Come in <em>C</em>, ma <em>senza</em> “aritmetica”</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Oggetto</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/basic-object.svg">
        
      </figure><ul>
<li>Rappresenta un <em>oggetto fisico</em> o un <em>concetto</em> del dominio</li>
<li>Memorizza il suo <strong>stato</strong> interno in <em>campi privati</em><ul>
<li><em>Incapsulamento (black box)</em></li>
</ul>
</li>
<li>Offre un insieme di <strong>servizi</strong>, come <em>metodi pubblici</em><ul>
<li>Realizza un <em>tipo di dato astratto (ADT)</em></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Classi ed oggetti</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/cookie-cutter.png">
        
      </figure><ul>
<li>Ogni <em>oggetto</em> ha una <strong>classe</strong> di origine<ul>
<li>La classe dà la stessa forma iniziale (campi e metodi) a tutti i suoi oggetti</li>
</ul>
</li>
<li>Ma ogni <em>oggetto</em> ha la sua <strong>identità</strong> <ul>
<li>Stato e locazione in memoria distinti da quelli di altri oggetti</li>
<li>Sia instanze di classi diverse che della stessa classe</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Definizione della classe</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/ball-object.svg"><img src="images/oop/ball-uml.svg">
        <figcaption>Class diagram UML</figcaption>
      </figure><ul>
<li><strong>Incapsulamento</strong> dei dati<ul>
<li>Campi in minuscolo: visibilità limitata al modulo</li>
<li>Funzione costruttore in maiuscolo: esportata</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="go"><code>type Ball struct {
    x, y    int
    w, h    int
    dx, dy  int
}

func NewBall(x, y int) *Ball {
    b := &amp;Ball{x, y, 20, 20, 5, 5}
    return b
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Costruzione oggetti</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/bob-builder.jpg">
        
      </figure><ul>
<li><strong><code>NewBall</code></strong>: funzione <em>costruttore</em><ul>
<li>Invocata per creare un oggetto</li>
<li><em>Instantiation is initialization</em></li>
<li>Restituisce un puntatore all'oggetto</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="go"><code>ball := NewBall(40, 80)  // Allocation and initialization
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Metodi</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Espongono <em>servizi</em> ad altri oggetti</li>
<li>Bisogna indicare l'<em>oggetto ricevitore</em>, come puntatore</li>
</ul>
<pre class="prettyprint" data-lang="go"><code>var ArenaW, ArenaH = 160, 120

func (b *Ball) Move() {
    if !(0 &lt;= b.x+b.dx &amp;&amp; b.x+b.dx &lt;= ArenaW-b.w) {
        b.dx = -b.dx
    }
    if !(0 &lt;= b.y+b.dy &amp;&amp; b.y+b.dy &lt;= ArenaH-b.h) {
        b.dy = -b.dy
    }
    b.x += b.dx
    b.y += b.dy
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Applicazione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="go"><code>func (b *Ball) Position() Rect {
    return Rect{b.x, b.y, b.w, b.h}
}

func main() {
    // Create two objects, instances of the Ball class
    b1 := NewBall(40, 80)
    b2 := NewBall(80, 40)

    for i := 0; i &lt; 25; i++ {
        Println("Ball 1 @", b1.Position())
        Println("Ball 2 @", b2.Position())
        b1.Move()
        b2.Move()
    }
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Animazione di due palline</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="go"><code>var b1 = NewBall(40, 80)
var b2 = NewBall(80, 40)

func update() {
    FillCanvas(Color{255, 255, 255})  // BG
    b1.Move()
    b2.Move()
    DrawPosition(Color{200, 100, 100}, b1.Position())  // FG
    DrawPosition(Color{100, 100, 200}, b2.Position())  // FG
}

func main() {
    InitCanvas(Size{ArenaW, ArenaH})
    MainLoop(update, 1000 / 30)
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Animazione lista di palline</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="go"><code>var balls = []*Ball{NewBall(40, 80), NewBall(80, 40)}

func update() {
    FillCanvas(Color{255, 255, 255}) // BG
    for _, b := range balls {
        b.Move()
        DrawPosition(Color{100, 100, 100}, b.Position()) // FG
    }
}

func main() {
    InitCanvas(Size{ArenaW, ArenaH})
    MainLoop(update, 1000/30) // Millis
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Composizione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/ball-arena.svg">
        
      </figure><ul>
<li>Associazione <strong>has-a</strong>, <strong>part-of</strong> tra oggetti<ul>
<li>Una arena <em>contiene</em> diverse palline</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="python"><code>type BallArena struct { balls []*Ball }
func (a *BallArena) Add(b *Ball) {
    a.balls = append(a.balls, b)
}
func (a *BallArena) MoveAll() {
    for i, b := range a.balls {
        b.Move(); Println("Ball", i, b.Position())
    }
}
func main() {
    var arena = &amp;BallArena{}
    arena.Add(NewBall(40, 80)); arena.Add(NewBall(80, 40))
    arena.MoveAll() // ...
}
</code></pre></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Interfacce</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Livelli di astrazione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/inheritance.png">
        
      </figure><ul>
<li>Relazione <strong>is-a</strong> tra classi<ul>
<li>Specializzazione, sotto-insieme</li>
</ul>
</li>
<li>Es. classificazioni in biologia<ul>
<li>I <em>vertebrati</em> sono una sottoclasse degli <em>animali</em></li>
<li>I <em>mammiferi</em> sono una sottoclasse dei <em>vertebrati</em></li>
<li>I <em>felini</em> sono una sottoclasse dei <em>mammiferi</em></li>
<li>I <em>gatti</em> sono una sottoclasse dei <em>felini</em></li>
</ul>
</li>
<li>Ogni sottoclasse...<ul>
<li>Eredita le caratteristiche della classe base</li>
<li>Ma introduce delle specializzazioni</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Interfacce</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/actors.svg">
        
      </figure><ul>
<li><code>Actor</code>: <em>interfaccia</em><ul>
<li>Dichiara un metodo <code>move</code> ecc.</li>
</ul>
</li>
<li>Vari attori: <em>classi implementazione</em><ul>
<li>Implementano caratteristiche di <code>Actor</code></li>
<li>Definiscono comportamenti specifici</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="go"><code>type Actor interface {
    Move()
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Generalizzazione e riuso</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="python"><code>type Arena struct { actors []*Actor }
func (a *Arena) Add(c *Actor) {
    a.actors = append(a.actors, c)
}
func (a *Arena) MoveAll() {
    for i, c := range a.actors {
        c.Move(); Println("Ball", i, c.Position())
    }
}
</code></pre>
<ul>
<li>Codice dipendente dalle classi più astratte, più in alto nella gerarchia<ul>
<li><code>Arena</code> riutilizzabile creando nuove classi derivate di <code>Actor</code></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Sostituzione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/actor.svg">
        
      </figure><pre class="prettyprint" data-lang="python"><code>arena.Add(NewBall(40, 80))
arena.Add(NewGhost(120, 40)) // ...
arena.MoveAll()
</code></pre>
<ul>
<li>Principio di <strong>sostituzione</strong> di Liskov<ul>
<li>Si può sempre usare un oggetto di una <em>classe implementazione</em>, al posto di uno della <em>interfaccia</em></li>
</ul>
</li>
<li>Relazione <em>has-a</em> tra un oggetto <code>Arena</code> e gli oggetti <code>Actor</code> che contiene</li>
<li>Relazione <em>is-a</em> tra classi implementazione (<code>Ball</code> e <code>Ghost</code>) e interfaccia (<code>Actor</code>)</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Ereditarietà e polimorfismo</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><strong>Classe implementazione</strong><ul>
<li>Implementa le caratteristiche della interfaccia</li>
<li>Può definire nuove caratteristiche specifiche</li>
</ul>
</li>
<li><strong>Metodo polimorfo</strong><ul>
<li>Definito in modo diverso nelle classi implementazione</li>
<li>Attori diversi possono muoversi in modo diverso</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="go"><code>type Ghost struct { x, y int }  // ...
func (g *Ghost) Move() {
    dx := 5 * RandInt(-1, 1)
    dy := 5 * RandInt(-1, 1)
    g.x = (g.x + dx + ArenaW) % ArenaW
    g.y = (g.y + dy + ArenaH) % ArenaH
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Attori e arena</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="go"><code>type Ghost struct {
    arena *Arena
    x, y  int
}
func NewGhost(arena *Arena, x, y int) *Ghost {
    g := &amp;Ghost{arena, x, y}  // save a ref to the arena
    arena.Add(g)              // register yourself into the arena
    return g
}
func (g *Ghost) Move() {
    dx := 5 * RandInt(-1, 1)
    dy := 5 * RandInt(-1, 1)
    as := g.arena.Size()      // ref to arena
    g.x = (g.x + dx + as.W) % as.W
    g.y = (g.y + dy + as.H) % as.H
}
</code></pre></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Animazione dei personaggi</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Rimbalzi nel browser</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="go"><code>var sprites = LoadImage("sprites.png")
var arena = NewArena(320, 240)
var turtle = NewTurtle(arena, 80, 80)  // actor knows the arena
func update() {
    arena.MoveAll()  // Game logic
    FillCanvas(Color{255, 255, 255})
    for _, a in arena.Actors() {
        // Cut an area from a larger image
        DrawImageClip(sprites, a.Position(), a.Symbol())
    }
}
func main() {
    NewGhost(arena, 120, 80); NewBall(arena, 40, 80) // ...
    InitCanvas(arena.Size())
    MainLoop(update, 1000 / 30)
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Controllo da tastiera</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/bounce.png">
        
      </figure><pre class="prettyprint" data-lang="python"><code>func keydown(code) {
    if code == "ArrowUp" { turtle.GoUp() }
    else if code == "ArrowDown" { turtle.GoDown() }
    else if code == "ArrowLeft" { turtle.GoLeft() }
    else if code == "ArrowRight" { turtle.GoRight() }
}
func keyup(code) {
    turtle.Stay()
}
func main() {
    // ...
    HandleKeyboard(keydown, keyup)
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Collisioni</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/collision.svg"><img src="images/oop/reflection.png">
        
      </figure><ul>
<li>Molti algoritmi di <em>collision detection</em><ul>
<li>Casi semplici: intersezione di rettangoli</li>
</ul>
</li>
<li>In caso di collisione, <code>Arena</code>...<ul>
<li>Invoca il metodo <code>collide</code> di entrambi gli oggetti</li>
<li>Collisione tra personaggio <code>self</code> e personaggio <code>other</code> (secondo parametro)</li>
</ul>
</li>
<li>Possibili errori nel calcolo del rimbalzo<ul>
<li>Di solito accettabili</li>
<li>Altrimenti, applicare correzioni</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Urti delle palline</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="python"><code>func (b *Ball) Collide(other Actor) {
    _, ok := other.(*Ghost)
    if !ok {
        op := other.Position()
        if op.X &lt; b.x { b.dx = b.speed }
        else { b.dx = -b.speed }
        if op.Y &lt; b.y { b.dy = b.speed } 
        else { b.dy = -b.speed }
    }
}
</code></pre>
<ul>
<li><em>Downcast</em>: <code>other.(*Ghost)</code><ul>
<li>Converte l'oggetto <code>other</code> come istanza di <code>Ghost</code></li>
<li>Restituisce un riferimento a <code>Ghost</code> ed un <code>bool</code></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Esercizi</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>3.1 Ellisse</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/ellipse.svg">
        
      </figure><ul>
<li>Classe che modella un'ellisse</li>
<li>Campi privati (parametri del costruttore)<ul>
<li>Semiassi: <code>a, b</code></li>
</ul>
</li>
<li>Metodi pubblici per ottenere...<ul>
<li>Area: <code>π⋅a⋅b</code></li>
<li>Distanza focale: <code>2⋅√|a<sup>2</sup> - b<sup>2</sup>|</code></li>
</ul>
</li>
<li>Nel corpo principale del programma...<ul>
<li>Creare un oggetto con dati forniti dall'utente</li>
<li>Visualizzare area e distanza focale dell'ellisse</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.2 Animazione di una pallina</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/street-fighter.jpg">
        
      </figure><ul>
<li>Partire dalla classe <code>Ball</code> vista a lezione</li>
<li>Eseguire l'animazione<ul>
<li>Per ogni frame, chiamare il metodo <code>Move</code> della pallina</li>
<li>Rappresentare un rettangolo o un cerchio nella posizione aggiornata della pallina</li>
</ul>
</li>
<li>Modificare però il metodo <code>Move</code><ul>
<li>La pallina si sposta sempre di pochi pixel in orizzontale</li>
<li>La pallina non si sposta verticalmente</li>
<li>Se esce dal bordo destro, ricompare al bordo sinistro e viceversa</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.3 Classe degli invasori spaziali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/invaders-path.jpg">
        
      </figure><ul>
<li>Creare una classe <code>Invader</code>, che contenga i dati ed il comportamento dell'alieno<ul>
<li>Campi privati: <code>x</code>, <code>y</code>, <code>dx</code></li>
<li>Metodo <code>Move</code> per avanzare</li>
<li>Metodo <code>Position</code> per ottenere la posizione attuale</li>
</ul>
</li>
<li>Istanziare un oggetto <code>Invader</code> e farlo muovere sullo schermo<ul>
<li>Chiamare il metodo <code>Move</code> ad ogni ciclo</li>
<li>Visualizzare un rettangolo nella posizione corrispondente</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Definire nella classe delle opportune costanti</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.4 Lista di invasori</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/invaders-path.jpg">
        
      </figure><ul>
<li>Riusare la classe <code>Invader</code> (es. 3.3)</li>
<li>Creare inizialmente una lista di alieni, con posizioni di partenza diverse<ul>
<li>Memorizzare la posizione di partenza di ciascun alieno in opportuni campi privati</li>
<li>Lasciare a ciascun alieno uno spazio orizzontale di movimento di 150 pixel, a destra della posizione di partenza</li>
</ul>
</li>
<li>Farli avanzare tutti ad ogni ciclo, chiamando il metodo <code>Move</code> di ciascuno di essi</li>
</ul></article>
 
</slide>


<slide class="thank-you-slide segue nobackground">
  <aside class="gdbar right"><img src="images/logo.png"></aside>
  <article class="flexbox vleft auto-fadein">
    <h2>&lt;Domande?&gt;</h2>
  </article>
  <p class="auto-fadein" data-config-contact>
    Michele Tomaiuolo
    <br>
    Palazzina 1, int. 5708
    <br>
    Ingegneria dell'Informazione, UniPR
    <br>
    <a href="http://sowide.unipr.it/tomamic">sowide.unipr.it/tomamic</a>
  </p>
</slide>

<slide class="backdrop"></slide>

</slides>

</body>
</html>