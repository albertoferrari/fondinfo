<!--
Google IO 2012 HTML5 Slide Template

Authors: Eric Bidelman <ebidel@gmail.com>
         Luke Mahe <lukem@google.com>

URL: https://code.google.com/p/io-2012-slides
-->
<!DOCTYPE html>
<html>
<head>
  <title>Esercizi 2017</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="stylesheet" media="all" href="theme/css/default.css">
  <link rel="stylesheet" media="all" href="theme/css/tomamic.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="theme/css/phone.css">
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
  <script data-main="js/slides" src="js/require-1.0.8.min.js"></script>
</head>
<body style="opacity: 0">

<slides class="layout-widescreen">

<slide class="title-slide segue nobackground">
  <aside class="gdbar"><img src="images/logo.png"></aside>
  <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
  <h1 data-config-title><!-- populated from slide_config.json --></h1>
  <figure><img src="images/misc/geek-girl.jpg"></figure>
  <hgroup>
    <h2>Introduzione alla programmazione</h2>
    <p>Michele Tomaiuolo<br>Ingegneria dell'Informazione, UniPR</p>
  </hgroup>
</slide>


<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Esercitazione 1</h2>
      <h3>2017-10-02</h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>1.1 Hello, user!</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/handshake.png">
        
      </figure><ul>
<li>Compilare ed eseguire il programma “<code>Hello world</code>”</li>
<li>In una versione successiva del programma...</li>
<li>Chiedere il nome all'utente e aggiungere tale nome al messaggio di saluto</li>
<li>Se il nome dell'utente è “<code>admin</code>”, mostrare inoltre il messaggio speciale “<code>At your command</code>”</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.2 Anni bisestili</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Chiedere all'utente di inserire un anno</li>
<li>Dire se è bisestile oppure no</li>
<li>Ripetere tutto ciclicamente, finchè l'utente non inserisce il valore <code>0</code></li>
</ul>
<blockquote></blockquote>
<p>Un anno è bisestile se il suo numero è divisibile per 4, con l'eccezione degli anni secolari (quelli divisibili per 100) che non sono divisibili per 400</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.3 Cerchi casuali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/random-circles.png">
        
      </figure><ul>
<li>Chiedere all'utente un numero <code>n</code></li>
<li>Disegnare <code>n</code> cerchi<ul>
<li>Tutti con raggio di 50 pixel</li>
<li>Ciascuno in posizione casuale</li>
<li>Ciascuno con un colore casuale</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Cominciare a disegnare un solo cerchio grigio, in posizione casuale</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.4 Cerchi concentrici graduali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/red-circles.png">
        
      </figure><ul>
<li>Chiedere all'utente il numero di cerchi da disegnare</li>
<li>Disegnare i cerchi con raggio gradualmente decrescente, ma tutti con lo stesso centro</li>
<li>Far variare il colore dei cerchi<ul>
<li>Dal rosso del livello più esterno</li>
<li>Fino al nero del livello più interno</li>
</ul>
</li>
<li>Prima del ciclo, determinare di quanto cambiare raggio e colore ad ogni passo</li>
</ul>
<blockquote></blockquote>
<p>Per iniziare, inserire l'operazione di disegno un ciclo, togliendo ad ogni passo <code>10</code> (p.es.) al raggio e al livello di rosso</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.5 Cerchi concentrici casuali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Disegnare un cerchio di raggio 200 e colore casuale</li>
<li>Disegnare dei cerchi concentrici, via via più piccoli</li>
<li>Per ognuno, scegliere casualmente raggio e colore</li>
<li>Fermarsi quando il raggio diventa più piccolo di 10</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.6 Carattere Unicode</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/characters.png">
        
      </figure><ul>
<li>Chiedere all'utente un numero</li>
<li>Visualizzare il carattere Unicode corrispondente</li>
<li>Ripetere le operazioni in un ciclo, finchè l'utente non inserisce il valore <code>0</code></li>
</ul>
<blockquote></blockquote>
<p>Usare la funzione <code>chr</code> per convertire un codice nel char corrispondente</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.7 Tabella ASCII</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Visualizzare la tabella dei codici ASCII</li>
<li>Un carattere per ogni riga<ul>
<li>All'inizio della riga: il carattere</li>
<li>Di fianco: il codice ASCII</li>
</ul>
</li>
<li>Limitare l'intervallo tra 32 a 126 (due costanti)</li>
</ul>
<blockquote></blockquote>
<p>Non c'è input dell'utente</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.8 Massimo e minimo</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/data-sequence.png">
        
      </figure><ul>
<li>Chiedere all'utente, attraverso un ciclo, una sequenza di numeri naturali<ul>
<li>La sequenza termina quando si legge un valore negativo (non valido)</li>
</ul>
</li>
<li>Visualizzare il valore massimo e quello minimo tra i numeri inseriti</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.9 Skyscrapers</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/histogram.png">
        
      </figure><ul>
<li>Chiedere all'utente, attraverso un ciclo, una sequenza di numeri naturali<ul>
<li>La sequenza termina quando si legge un valore negativo (non valido)</li>
</ul>
</li>
<li>Quante volte è cambiato il massimo?<ul>
<li>Per ogni valore inserito, controllare se è il massimo osservato</li>
</ul>
</li>
<li>Al termine, scrivere il risultato</li>
</ul>
<blockquote></blockquote>
<p>Da sinistra a destra, quanti “tetti” si vedono? (Nell'esempio: 6)</p></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Esercitazione 2</h2>
      <h3>2017-10-09</h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>2.1 Percentuale di cifre</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/numbers.jpg">
        
      </figure><ul>
<li>Chiedere una riga di testo all'utente</li>
<li>Mostrare la percentuale di cifre presenti</li>
</ul>
<blockquote></blockquote>
<p>Usare un ciclo <code>for</code> sulla stringa</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.2 Lista di valori</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/data-sequence.png">
        
      </figure><ul>
<li>Chiedere all'utente una sequenza in numeri naturali</li>
<li>La sequenza termina quando l'utente inserisce un valore negativo</li>
<li>Quanti valori sono maggiori dell'ultimo valido inserito?</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.3 Funzione, densità</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/snow-ball.png">
        
      </figure><ul>
<li>Definire una funzione <code>sphere_density</code> per il calcolo della densità di una sfera<ul>
<li>Parametri: raggio in metri e massa in Kg</li>
<li>Risultato: densità (tutti valori <code>float</code>)</li>
</ul>
</li>
<li>Invocare la funzione dalla shell interattiva</li>
<li>Aggiungere poi al programma una funzione <code>main</code><ul>
<li><em>Procedura, senza parametri e senza risultato</em></li>
<li>Chiedere all'utente due valori (chiamando <code>input</code>)</li>
<li>Poi chiamare <code>sphere_density</code> con questi parametri</li>
<li>Infine mostrare all'utente il risultato (chiamando <code>print</code>)</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Formule utili: V = (4/3)πR<sup>3</sup> ; ρ = m / V</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.4 Conteggio di singole cifre</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/numbers.jpg">
        
      </figure><ul>
<li>Chiedere una riga di testo all'utente</li>
<li>Contare separatamente le occorrenze di ciascuna cifra (da <code>'0'</code> a <code>'9'</code>)</li>
</ul>
<blockquote></blockquote>
<p>Creare una lista (array) di 10 elementi, inizialmente tutti posti a <code>0</code></p>
<p>Ciascun elemento è il contatore per una certa cifra</p>
<p>Attenzione alla distinzione tra il tipo <code>str</code> ed il tipo <code>int</code>!</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.5 Skyscrapers, da destra</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/histogram.png">
        
      </figure><ul>
<li>Chiedere all'utente una sequenza in numeri naturali</li>
<li>La sequenza termina quando l'utente inserisce un valore negativo</li>
<li>Quante volte cambia il massimo, osservando la sequenza al contrario?</li>
</ul>
<blockquote></blockquote>
<p>Da destra a sinistra, quanti “tetti” si vedono? (Nell'esempio: 5)</p>
<p>La funzione <code>reversed</code> restituisce una sequenza rovesciata</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.6 Griglia di colori</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/color-grid.png"><img src="images/oop/raster-tile.png">
        
      </figure><ul>
<li>Chidere all'utente dei valori per <code>rows</code> e <code>cols</code></li>
<li>Mostrare una griglia di rettangoli di dimensione <code>rows×cols</code></li>
<li>Partire da un rettangolo nero in alto a sinistra</li>
<li>In orizzontale, aumentare gradatamente la componente di blu</li>
<li>In verticale, aumentare gradatamente la componente di verde</li>
</ul>
<blockquote></blockquote>
<p>Cominciare a creare una griglia di riquadri tutti neri, con due cicli <code>for</code> annidati</p>
<p>Lasciare tra i riquadri un piccolo margine</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.7 Conteggio lettere iniziali uguali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Scrivere una funzione <code>len_common_prefix</code><ul>
<li>Paramteri: <code>a</code> e <code>b</code>, stringhe da confrontare</li>
<li>Risultato: numero di lettere iniziali uguali tra <code>a</code> e <code>b</code></li>
</ul>
</li>
<li>Scrivere una funzione <code>main</code><ul>
<li>Chiedere all'utente due stringhe di testo, <code>s1</code> e <code>s2</code></li>
<li>Invocare <code>len_common_prefix</code> sulle due stringhe</li>
<li>Mostrare all'utente il risultato</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.8 Movimento diagonale</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/border.png">
        
      </figure><ul>
<li>Partire dall'esempio del rettangolo in moto orizzontale<ul>
<li>Spostamento costante denominato <code>dx</code></li>
</ul>
</li>
<li>Fare in modo che il movimento sia in diagonale<ul>
<li>Ad ogni turno, aggiungere ad una variabile <code>y</code>...</li>
<li>Una quantità costante <code>dy</code></li>
</ul>
</li>
<li>Quando la pallina raggiunge il bordo destro, non lo supera<ul>
<li>La <code>x</code> rimane fissa al valore massimo</li>
<li>La <code>y</code> può ancora cambiare</li>
</ul>
</li>
<li>Quando la pallina raggiunge il bordo inferiore, non lo supera<ul>
<li>La <code>y</code> rimane al valore massimo</li>
<li>La <code>x</code> può ancora cambiare</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.9 Controllo da tastiera</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/border.png">
        
      </figure><ul>
<li>Riprendere l'esercizio 2.8</li>
<li>Controllare la pressione dei tasti freccia<ul>
<li>Impostare il solo segno di <code>dx</code>, se premuta una freccia orizzontale</li>
<li>Impostare il solo segno di <code>dy</code>, se premuta una freccia verticale</li>
<li>Nella funzione di gestione tasti, non modificare nè <code>x</code>, nè <code>y</code></li>
</ul>
</li>
<li>Lontano dai bordi, il movimento rimane sempre in una delle quattro <em>direzioni diagonali</em><ul>
<li>Quando la pallina raggiunge uno dei bordi, non lo supera</li>
<li>Ma continua a muoversi sul bordo, fino all'angolo</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Esercitazione 3</h2>
      <h3>2017-10-16 *</h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>3.1 Animazione di una pallina</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/street-fighter.jpg">
        
      </figure><ul>
<li>Partire dalla classe <code>Ball</code> vista a lezione</li>
<li>Eseguire l'animazione<ul>
<li>Per ogni frame, chiamare il metodo <code>move</code> della pallina</li>
<li>Rappresentare un rettangolo o un cerchio nella posizione aggiornata della pallina</li>
</ul>
</li>
<li>Modificare però il metodo <code>move</code><ul>
<li>La pallina si sposta sempre di pochi pixel verso destra</li>
<li>La pallina non si sposta verticalmente</li>
<li>Se esce dal bordo destro, ricompare al bordo sinistro e viceversa</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.2 Ellisse</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/ellipse.svg">
        
      </figure><ul>
<li>Classe che modella un'ellisse</li>
<li>Campi privati (parametri del costruttore)<ul>
<li>Semiassi: <code>a, b</code></li>
</ul>
</li>
<li>Metodi pubblici per ottenere...<ul>
<li>Area: <code>π*a*b</code></li>
<li>Distanza focale: <code>2*√(a<sup>2</sup> - b<sup>2</sup>)</code></li>
</ul>
</li>
<li>Nel corpo principale del programma...<ul>
<li>Creare un oggetto con dati forniti dall'utente</li>
<li>Visualizzare area e distanza focale dell'ellisse</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Opzionalmente, nell'inizializzazione: se <code>a &lt; b</code>, scambiarne i valori</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.3 Maiuscole tra asterischi</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/troll-key.png">
        
      </figure><ul>
<li>Scrivere una funzione che:<ul>
<li>Riceve in input una stringa di testo</li>
<li>Produce in output la stesso testo, ma...</li>
<li>Trasforma in maiuscolo tutto il testo compreso tra asterischi</li>
</ul>
</li>
<li>Es. “<code>I want *this text* to be uppercase</code>” <br>
  → “<code>I want THIS TEXT to be uppercase</code>”</li>
<li>Da una funzione <em>main</em>, applicare la funzione su una stringa inserita dall'utente</li>
</ul>
<blockquote></blockquote>
<p>Segnare in un <code>bool</code> se si è incontrato un asterisco iniziale, ma non ancora un asterisco finale</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.4 Combinazioni di simboli</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/fun/bike-lock.png">
        
      </figure><ul>
<li>Scrivere una funzione per generare tutte le combinazioni di lunghezza 3<ul>
<li>Parametri: <code>str</code> contenente l'insieme dei simboli validi (presenti su ogni ruota)</li>
<li>Risultato: lista di <code>str</code> (combinazioni)</li>
</ul>
</li>
<li>Possibile approccio<ul>
<li>Usare 3 cicli <code>for</code> annidati</li>
<li>Ogni <code>for</code> scorre tutto l'insieme di simboli</li>
<li>Una combinazione è una <code>str</code>, ottenuta concatenando i 3 simboli correnti</li>
</ul>
</li>
<li>Per test, fornire in input le vocali <code>"AEIOU"</code>, per ottenere:<ul>
<li><code>["AAA", "AAE", "AAI", "AAO", "AAU", "AEA", "AEE", "AEI", "AEO", "AEU", "AIA", ...</code></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.5 Oscillazione sinusoidale</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/sin-cos.png">
        
      </figure><ul>
<li>Partire dalla classe dell'esercizio 3.1<ul>
<li>Memorizzare la ordinata iniziale <code>y0</code></li>
</ul>
</li>
<li>Modificare il metodo <code>move</code><ul>
<li>L'ordinata oscilla sinusoidalmente attorno ad <code>y0</code></li>
<li>Sommare ad <code>y0</code> un valore proporzionale a <code>sin(k * x)</code></li>
</ul>
</li>
<li>Visualizzare l'animazione di due palline</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.6 Palline colorate</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Aggiungere ai dati della pallina (es. 3.5) anche un colore<ul>
<li>Generare una tupla <code>RGB</code> casuale, nell'inizializzatore</li>
</ul>
</li>
<li>Aggiungere un corrispondente metodo <em>getter</em><ul>
<li>Per ottenere dall'esterno il colore della pallina</li>
<li>Restituire il colore come una tupla (tripla RGB)</li>
</ul>
</li>
<li>Creare diverse palline ed inserirle in una lista</li>
<li>Rappresentare graficamente il movimento di tutte le palline<ul>
<li>Per ogni frame, in un ciclo <code>for</code>, chiamare il metodo <code>move</code> di ogni pallina</li>
<li>Rappresentare un rettangolo o un cerchio colorato nella posizione aggiornata di ogni pallina</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.7 Rimbalzi con gravità</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/bouncing-ball.jpg">
        
      </figure><ul>
<li>Ripartire dalla classe <code>Ball</code> originale (esempio visto a lezione)</li>
<li>Nel metodo <code>move</code>, aggiungere l'effetto della gravità<ul>
<li>Accelerazione: aggiungere un piccolo valore costante alla velocità verticale</li>
<li><code>g = 0.4</code></li>
<li><code>dy += g</code></li>
<li>Quando si tocca il fondo, cambiare il segno di <code>dy</code></li>
</ul>
</li>
<li>Mostrare l'animazione di una lista di palline, tutte con l'effetto della gravità</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.8 Controllo da tastiera</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/arrow-keys.jpg"><img src="images/oop/wasd-keys.jpg">
        
      </figure><ul>
<li>Aggiungere alla classe dell'es. 3.7 dei metodi di comando<ul>
<li><code>go_left</code>, <code>go_right</code>, <code>stay</code></li>
<li>In questi metodi, modificare solo <code>dx</code></li>
<li>Spostamento avviene sempre in <code>move</code></li>
</ul>
</li>
<li>Mantenere il movimento verticale con gravità e rimbalzo</li>
<li>Mostrare l'animazione di una sola pallina</li>
<li>Controllare eventi della tastiera<ul>
<li>Definire funzioni <code>keydown</code> e <code>keyup</code></li>
<li>Chiamare il metodo corrispondente al tasto premuto</li>
</ul>
</li>
<li>Con tasti diversi, comandare poi una seconda pallina</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.9 Jumper</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/jumper.png">
        
      </figure><ul>
<li>Modificare la classe dell'es. 3.7<ul>
<li>Mantenere i comandi orizzontali e la gravità</li>
<li>Eliminare però il rimbalzo</li>
<li>Quando arriva sul fondo dello schermo, si ferma lì</li>
</ul>
</li>
<li>Aggiungere alla classe un metodo per saltare<ul>
<li><code>jump</code>, imposta <code>dy</code> ad un certo valore, negativo</li>
<li>Poi agirà di nuovo la gravità</li>
<li>Si può saltare solo dal fondo dello schermo</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Esercitazione 4</h2>
      <h3>2017-10-23</h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>4.1 Massimo Comun Divisore</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/hist/euclid.jpg">
        
      </figure><ul>
<li>Leggere due numeri</li>
<li>Calcolare in una funzione il loro Massimo Comun Divisore</li>
<li>Euclide<ul>
<li><em>gcd(a, b) = a, se b = 0</em></li>
<li><em>gcd(a, b) = gcd(b, a mod b), altrimenti</em></li>
</ul>
</li>
<li>Visualizzare il risultato della funzione</li>
</ul>
<blockquote></blockquote>
<p>Saranno accettate esclusivamente le soluzioni ricorsive</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.2 Arena con gravità</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/bouncing-ball.jpg">
        
      </figure><ul>
<li>Partire dall'esempio <code>bounce</code></li>
<li>Inserire in gioco solo delle palline</li>
<li>Aggiungere alle palline l'effetto della gravità<ul>
<li>Come nell'es. 3.6</li>
</ul>
</li>
<li>Quando due palline si <em>urtano</em>, ciascuna cambia solo il segno di <code>dx</code></li>
<li><em>Miglioramento</em>: non considerare urti ripetuti<ul>
<li>Dopo un urto, per ~10 turni non considerarne altri</li>
<li>Creare un campo per contare le chiamate a <code>move</code></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.3 Triangolo di Sierpiski</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/sierpinski-triangle.png">
        
      </figure><ul>
<li>Scrivere una funzione ricorsiva per disegnare un triangolo di Sierpinski</li>
<li>Partire da un riquadro nero<ul>
<li>All'inizio il riquadro nero può corrispondere con la finestra</li>
<li>Ma in generale ragionare su coordinate passate come parametri: <code>x</code>, <code>y</code>, <code>w</code>, <code>h</code></li>
</ul>
</li>
<li>Riempire di bianco il quarto in alto a destra</li>
<li>Ripetere il procedimento per ciascuno dei 3 riquadri rimasti neri</li>
</ul>
<blockquote></blockquote>
<p>Saranno accettate esclusivamente le soluzioni ricorsive</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.4 Combinazioni</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/fun/bike-lock.png">
        
      </figure><ul>
<li>Generare tutte le combinazioni di simboli<ul>
<li>Parametro: numero di ruote</li>
<li>Parametro: <code>str</code> contenente i possibili simboli</li>
<li>Risultato: una lista di stringhe</li>
</ul>
</li>
<li>Algoritmo:<ul>
<li>Una sola ruota: ogni elemento è una stringa di lunghezza 1</li>
<li>Altrimenti: per ogni elemento della prima ruota...</li>
<li>Concatenarlo con tutte le combinazioni sulle ruote rimanenti (ricorsione)</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Saranno accettate esclusivamente le soluzioni ricorsive</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.5 Donkey Kong: Mario</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/donkey-kong.png">
        
      </figure><ul>
<li>Partire dall'esempio <code>bounce</code></li>
<li>Rendere <code>Jumper</code> (es. 3.9) una sottoclasse di <code>Actor</code></li>
<li>Istanziare un oggetto <code>Arena</code></li>
<li>Inserire in gioco solo una istanza di <code>Jumper</code></li>
<li>Permettere all'utente di comandarne i movimenti ed i salti</li>
</ul>
<blockquote></blockquote>
<p><a href="http://www.commodore.ca/arcade/donkeykong.swf">http://www.commodore.ca/arcade/donkeykong.swf</a></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.6 Donkey Kong: piattaforme</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/donkey-kong.png">
        
      </figure><ul>
<li>Partire dall'esercizio 4.5</li>
<li>Creare <code>Platform</code> come sottoclasse di <code>Actor</code><ul>
<li>Personaggio immobile nel gioco</li>
</ul>
</li>
<li>In caso di collisione tra Mario (<code>Jumper</code>) ed una piattaforma<ul>
<li>Posizionare Mario esattamente sopra alla piattaforma</li>
</ul>
</li>
<li><em>Miglioramento</em>: collisione valida solo se...<ul>
<li>Il punto in mezzo ai piedi di Mario è dentro la piattaforma</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.7 Donkey Kong: salti</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/donkey-kong.png">
        
      </figure><ul>
<li>Segnare in un campo se Mario è su una piattaforma<ul>
<li>Può camminare sulle piattaforme</li>
<li>Può saltare, se è su una piattaforma</li>
</ul>
</li>
<li>Mario cade quando esce dalla piattaforma</li>
</ul></article>
 
</slide>


<slide class="thank-you-slide segue nobackground">
  <aside class="gdbar right"><img src="images/logo.png"></aside>
  <article class="flexbox vleft auto-fadein">
    <h2>&lt;Domande?&gt;</h2>
  </article>
  <p class="auto-fadein" data-config-contact>
    Michele Tomaiuolo
    <br>
    Palazzina 1, int. 5708
    <br>
    Ingegneria dell'Informazione, UniPR
    <br>
    <a href="http://www.ce.unipr.it/people/tomamic">www.ce.unipr.it/people/tomamic</a>
  </p>
</slide>

<slide class="backdrop"></slide>

</slides>

</body>
</html>