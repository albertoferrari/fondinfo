<!--
Google IO 2012 HTML5 Slide Template

Authors: Eric Bidelman <ebidel@gmail.com>
         Luke Mahe <lukem@google.com>

URL: https://code.google.com/p/io-2012-slides
-->
<!DOCTYPE html>
<html>
<head>
  <title>C++ internals</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="stylesheet" media="all" href="theme/css/default.css">
  <link rel="stylesheet" media="all" href="theme/css/tomamic.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="theme/css/phone.css">
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
  <script data-main="js/slides" src="js/require-1.0.8.min.js"></script>
</head>
<body style="opacity: 0">

<slides class="layout-widescreen">

<slide class="title-slide segue nobackground">
  <aside class="gdbar"><img src="images/logo.png"></aside>
  <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
  <h1 data-config-title><!-- populated from slide_config.json --></h1>
  <figure><img src="images/misc/cpp-logo.jpg"></figure>
  <hgroup>
    <h2>Object oriented programming in C++</h2>
    <p>Michele Tomaiuolo<br>Ingegneria dell'Informazione, UniPR</p>
  </hgroup>
</slide>


<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Function pointers</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Initializing function pointers</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><strong>Declarating a function pointer.</strong> Write out the declaration of a function, but with <code>(*func_name)</code> where you'd normally just put <code>func_name</code></li>
<li><strong>Initializing.</strong> Give it the address of a function in your program; the syntax is like any other variable</li>
</ul>
<pre class="prettyprint" data-lang="c++"><code>void my_int_func(int x) {
    cout &lt;&lt; x &lt;&lt; endl;
}

int main() {
    void (*foo)(int);
    foo = &amp;my_int_func;
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Using a function pointer</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><strong>Calling the pointed function.</strong> Treat the function pointer as though it were the name of the function<ul>
<li>The act of calling it performs the dereference; there's no need to do it yourself</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="c++"><code>int main() {
    void (*foo)(int);
    foo = &amp;my_int_func;

    /* call my_int_func */
    foo(2);

    /* no need to write (*foo)(2), but you can */
    (*foo)(2);
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Example of a callback</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="c++"><code>void qsort(void *base, size_t nmemb, size_t size,
            int(*compar)(const void *, const void *));
</code></pre>
<ul>
<li><code>compar</code> is a function pointer (<em>callback</em>)<ul>
<li>Negative result if 1st &lt; 2nd arg</li>
<li>Zero if they are equal</li>
<li>Positive result if 1st &lt; 2nd arg</li>
</ul>
</li>
</ul>
<p>code: c++</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>A comparison function</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="C++"><code>int int_sorter(const void * a, const void * b) {
    return *(int*)a - *(int*)b;
}

int main() {
    int array[10];
    for (int i = 0; i &lt; 10; ++i) {
        array[ i ] = 10 - i;
    }
    qsort(array, 10, sizeof(int), int_sorter);
    for (int i = 0; i &lt; 10; ++i) {
        cout &lt;&lt; array[i] &lt;&lt; endl;
    }

}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Function pointers summary</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><strong>Declaring.</strong> As though you were declaring a function, except with a name like <code>*foo</code> instead of just <code>foo</code></li>
</ul>
<pre class="prettyprint" data-lang="c++"><code>void (*foo)(int);
</code></pre>
<ul>
<li><strong>Initializing.</strong> Get the address of a function simply by naming it</li>
</ul>
<pre class="prettyprint" data-lang="c++"><code>void foo();
func_pointer = foo;
</code></pre>
<ul>
<li>Or, <em>optionally</em>, by prefixing the name with an ampersand</li>
</ul>
<pre class="prettyprint" data-lang="c++"><code>void foo();
func_pointer = &amp;foo;
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Function pointers summary</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><strong>Invoking.</strong> Just as if you were calling a function</li>
</ul>
<pre class="prettyprint" data-lang="c++"><code>func_pointer( arg1, arg2 );
</code></pre>
<ul>
<li>Or, optionally <em>dereferencing</em> the function pointer before calling</li>
</ul>
<pre class="prettyprint" data-lang="c++"><code>(*func_pointer)( arg1, arg2 );
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Function objects</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Function objects (aka “functors”) can be treated as though they are a function or function pointer</li>
<li>C++ allows you to overload <code>operator()</code>, the <em>function call</em> operator<ul>
<li>Flexible: it can take any number of arguments of any types and return anything it wishes to</li>
<li>All the other operators have a fixed number of arguments</li>
</ul>
</li>
<li>Use a a functor's constructor to embed information that is later used inside the implementation of <code>operator()</code></li>
</ul>
<pre class="prettyprint" data-lang="c++"><code>class MyFunctorClass {
public:
    MyFunctorClass (int x) : x_(x) {}
    int operator() (int y) { return x_ + y; }
private:
    int x_;
};

int main() {
    MyFunctorClass addFive(5);
    std::cout &lt;&lt; addFive(6);     
    return 0;
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Lambda functions</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><code>[ capture-list ] ( params ) { body }</code></li>
<li><em>Capture list</em>, for variables to be used in body of lambda<ul>
<li><code>[a,&amp;b]</code>, captures <code>a</code> by <em>copy</em>, and <code>b</code> by <em>reference</em></li>
<li><code>[&amp;]</code>, captures everything by <em>reference</em></li>
<li><code>[=]</code>, captures everything by <em>copy</em></li>
<li><code>[]</code> captures nothing </li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="c++"><code>vector&lt;int&gt; c = {1, 2, 3, 4, 5, 6, 7};
int x = 5;
c.erase(remove_if(c.begin(), c.end(),
    [x](int n) { return n &lt; x; }), c.end());
</code></pre>
<blockquote></blockquote>
<p><a href="https://github.com/tomamic/fondinfo/blob/master/cpp/fifteen/gamegui.cpp">https://github.com/tomamic/fondinfo/blob/master/cpp/fifteen/gamegui.cpp</a></p></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>C++, or C with classes</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Hidden this pointer</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="C++"><code>class Accumulator {
private:
    int value = 0;
public:
    add(int inc) {
        value += inc;
    }
    get_val() { return y; }
};
</code></pre>
<pre class="prettyprint" data-lang="C++"><code>int main() {
    Accumulator a;
    a.add(10);
    cout &lt;&lt; a.get_val() &lt;&lt; endl;
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Hidden this, exposed</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>When we call <code>a.add(10)</code>, compiler actually calls stg. like <code>Accumulator__add(&amp;a, 10)</code><ul>
<li>Real name mangling is more complicated and proprietary</li>
</ul>
</li>
<li>Inside <code>add</code> f., the <code>this</code> pointer holds the address of object <code>a</code><ul>
<li>Any member variables inside <code>add</code> f. are prefixed with <code>this-&gt;</code></li>
<li>So when we say <code>value += inc</code>, compiler actually executes <code>this-&gt;value += inc</code></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>C++ class layout</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/cpp-struct-layout-a.png">
        
      </figure><ul>
<li>C-like structs<ul>
<li>C++mostly upwards-compatible with C</li>
<li>Same simple struct layout rules</li>
<li>Members laid out in their declaration order</li>
<li>Implementation defined alignment padding</li>
</ul>
</li>
<li><em>Note</em>: C++ structs are like classes, defaulting to <code>public</code></li>
</ul>
<pre class="prettyprint" data-lang="C++"><code>struct A {  // or class
    char c;
    int i;
};
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>More members</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/cpp-struct-layout-b.png">
        
      </figure><pre class="prettyprint" data-lang="C++"><code>struct B {  // or class
public:
    int bm1;
protected:
    int bm2;
private:
    int bm3;
    static int bsm;
    void bf();
    static void bsf();
    typedef void* bpv;
    struct N { };
};
</code></pre>
<ul>
<li>Only the <em>non-static data members</em> occupy space in each instance</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Single inheritance</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="C++"><code>struct C {
    int c1;
    void cf();
};

struct D : C {
    int d1;
    void df();
};
</code></pre>
<ul>
<li>Derived class inherits all features of base class</li>
<li>Each instance of <code>D</code> must contain a complete copy of the instance data of <code>C</code></li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Upcast for single inheritance</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/cpp-struct-layout-c.png"><img src="images/oop/cpp-struct-layout-d.png">
        
      </figure><pre class="prettyprint" data-lang="C++"><code>struct C {
    int c1;
    void cf();
};
struct D : C {
    int d1;
    void df();
};
</code></pre>
<ul>
<li>New instance data of <code>D</code> is simply <em>appended</em> to layout of <code>C</code><ul>
<li>Layout used by <em>all</em> known C++ <em>implementations</em></li>
<li>Address of <code>C</code> object within <code>D</code> == first byte of <code>D</code> object</li>
<li>No displacement for <em>upcasting</em>, to obtain address of embedded <code>C</code></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Multiple inheritance</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Model for an organization that has:<ul>
<li>A class <code>Manager</code> (who delegates), and</li>
<li>A class <code>Worker</code> (who actually does the work)</li>
</ul>
</li>
<li>How can we model a class <code>MiddleManager</code>?<ul>
<li>Like a <code>Worker</code>, accepts work assignments from manager</li>
<li>Like a <code>Manager</code>, delegates work to employees</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="C++"><code>struct Manager ... { ... };
struct Worker ... { ... };
struct MiddleManager : Manager, Worker { ... };
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Multiple inheritance layout</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/cpp-struct-layout-e.png"><img src="images/oop/cpp-struct-layout-f.png">
        
      </figure><pre class="prettyprint" data-lang="C++"><code>struct E {
    int e1;
    void ef();
};
struct F : C, E {
    int f1;
    void ff();
};
</code></pre>
<ul>
<li>Struct <code>F</code> multiply inherits from <code>C</code> and <code>E</code></li>
<li>As with single inheritance, <code>F</code> contains a copy of instance data of each base class</li>
<li>Here, address of embedded <code>E</code> within <code>F</code> ≠ address of <code>F</code> itself</li>
<li>Displacement leads to a small overhead, for casting</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Diamond problem</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/diamond-inheritance.svg">
        
      </figure><ul>
<li>What if both <code>Manager</code> and <code>Worker</code> are derived from <code>Employee</code>?</li>
</ul>
<pre class="prettyprint" data-lang="C++"><code>struct Employee { ... };
struct Manager : Employee { ... };
struct Worker : Employee { ... };
struct MiddleManager : Manager, Worker { ... };
</code></pre>
<ul>
<li>They each contain a copy of <code>Employee</code> instance data</li>
<li><code>MiddleManager</code> will contain two instances of <code>Employee</code>, one from each base</li>
<li>Duplication = storage overhead, inconsistencies</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Virtual inheritance</h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>In C++, this “sharing inheritance” is (unfortunately) called <em>virtual inheritance</em></p>
<pre class="prettyprint" data-lang="C++"><code>struct Employee { ... };
struct Manager : virtual Employee { ... };
struct Worker : virtual Employee { ... };
struct MiddleManager : Manager, Worker { ... };
</code></pre>
<ul>
<li>More expensive to implement and use</li>
<li>No fixed displacement from the address point of the derived class to its virtual base</li>
<li>If derived class is further derived from, shared base placed at different offset</li>
</ul></article>
 
</slide>


<slide class="thank-you-slide segue nobackground">
  <aside class="gdbar right"><img src="images/logo.png"></aside>
  <article class="flexbox vleft auto-fadein">
    <h2>&lt;Domande?&gt;</h2>
  </article>
  <p class="auto-fadein" data-config-contact>
    Michele Tomaiuolo
    <br>
    Palazzina 1, int. 5708
    <br>
    Ingegneria dell'Informazione, UniPR
    <br>
    <a href="http://www.ce.unipr.it/people/tomamic">www.ce.unipr.it/people/tomamic</a>
  </p>
</slide>

<slide class="backdrop"></slide>

</slides>

</body>
</html>