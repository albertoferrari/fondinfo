<!--
Google IO 2012 HTML5 Slide Template

Authors: Eric Bidelman <ebidel@gmail.com>
         Luke Mahe <lukem@google.com>

URL: https://code.google.com/p/io-2012-slides
-->
<!DOCTYPE html>
<html>
<head>
  <title>Python for data analysis</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="stylesheet" media="all" href="theme/css/default.css">
  <link rel="stylesheet" media="all" href="theme/css/tomamic.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="theme/css/phone.css">
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
  <script data-main="js/slides" src="js/require-1.0.8.min.js"></script>
</head>
<body style="opacity: 0">

<slides class="layout-widescreen">

<slide class="title-slide segue nobackground">
  <aside class="gdbar"><img src="images/logo.png"></aside>
  <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
  <h1 data-config-title><!-- populated from slide_config.json --></h1>
  <figure><img src="images/oop/modules.png"></figure>
  <hgroup>
    <h2>NumPy, Pandas, PyPlotLib</h2>
    <p>Michele Tomaiuolo<br>Ingegneria dell'Informazione, UniPR</p>
  </hgroup>
</slide>


<slide  >
  
    <hgroup>
      <h2>Lista</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/fun/month-list.svg">
        
      </figure><ul>
<li>Sequenza di elementi, <em>di solito</em> dello stesso <strong>tipo</strong><ul>
<li>L'intera lista può essere assegnata ad una variabile, così diamo un <strong>nome</strong> alla lista</li>
</ul>
</li>
<li>I singoli elementi sono <strong>numerati</strong><ul>
<li>Gli indici partono da 0!</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="python"><code>to_buy = ["spam", "eggs", "beans"]
</code></pre>
<pre class="prettyprint" data-lang="python"><code>rainfall_data = [13, 24, 18, 15]
</code></pre>
<pre class="prettyprint" data-lang="python"><code>months = ["Jan", "Feb", "Mar",
          "Apr", "May", "Jun",
          "Jul", "Aug", "Sep",
          "Oct", "Nov", "Dec"]
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Accesso agli elementi</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/fun/wile-coyote.png">
        
      </figure><ul>
<li><strong>Attenzione ad usare indici validi!</strong><ul>
<li><em>Lunghezza</em> attuale di una lista <code>x</code>: <code>len(x)</code></li>
<li>Elementi <em>numerati</em> da <code>0</code> a <code>len(x)-1</code></li>
<li>Indici <em>negativi</em> contano dalla fine</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="python"><code>n = len(months)            # 12
months[3]                  # "Apr"
months[-2]                 # "Nov", same as n - 2
</code></pre>
<pre class="prettyprint" data-lang="python"><code>to_buy = ["spam", "eggs", "beans"]

to_buy[1] = "ketchup"      # replace an element
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Appartenenza, inserimento, rimozione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/fun/shopping-list.jpg">
        
      </figure><pre class="prettyprint" data-lang="python"><code>to_buy = ["spam", "eggs", "beans"]

"eggs" in to_buy           # True, to_buy contains "eggs"
</code></pre>
<pre class="prettyprint" data-lang="python"><code>to_buy.append("bacon")     # add an element to the end
to_buy.pop()               # remove (and return) last element

to_buy.insert(1, "bacon")  # other elements shift
removed = to_buy.pop(1)    # remove (and return) element at index
# del to_buy[1]            # only remove element at index

to_buy.remove("eggs")      # remove an element by value
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Slice: porzioni di lista</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="python"><code>spring = months[2:5]       # ["Mar", "Apr", "May"]
quart1 = months[:3]        # ["Jan", "Feb", "Mar"]
quart4 = months[-3:]       # ["Oct", "Nov", "Dec"]
but_spring = months[:]     # Copy the whole list
del but_spring[2:5]        # Remove spring months
</code></pre>
<pre class="prettyprint" data-lang="python"><code>list1 = ["spam", "eggs", "beans"]
list2 = ["sausage", "mushrooms"]
to_buy = list1 + list2     # List concatenation
</code></pre>
<pre class="prettyprint" data-lang="python"><code>so_boring = [1, 2] * 3     # List repetition:
                           # [1, 2, 1, 2, 1, 2]
results_by_month = [0] * 12
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Uguaglianza e identità</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="python"><code>a = [3, 4, 5]
b = a[:]       # b = [3, 4, 5] -- a new list!
b == a         # True, they contain the same values
b is a         # False, they are two objects in memory
               # (try and modify one of them...)
c = a
c is a         # True, same object in memory
               # (try and modify one of them...)
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Stringhe e liste</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><strong>Stringa</strong>: sequenza <em>immutabile</em> di caratteri</li>
<li><strong><code>join</code></strong> e <strong><code>split</code></strong>: da lista a stringa e viceversa</li>
</ul>
<pre class="prettyprint" data-lang="python"><code>txt = "Monty Python's Flying Circus"
txt[0]    # 'M'
txt[1]    # 'o'
txt[-1]   # 's'
txt[6:12] # "Python"
txt[-6:]  # "Circus"

days = ["tue", "thu", "sat"]
txt = "|".join(days)  # "tue|thu|sat"

days = "mon|wed|fri".split("|")
# ["mon", "wed", "fri"]
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Tupla</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Sequenza <strong>immutabile</strong> di valori, anche di <em>tipo diverso</em></li>
</ul>
<pre class="prettyprint" data-lang="python"><code># Tuple packing
pt = 5, 6, "red"
pt[0]  # 5
pt[1]  # 6
pt[2]  # "red"

# multiple assignments, from a tuple
x, y, colour = pt  # sequence unpacking
a, b = 3, 4
a, b = b, a
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Cicli su liste: for</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="python"><code>shopping_list = ["spam", "eggs", "bacon", "ketchup"]

print("Your shopping list contains:")

for product in shopping_list:
    print(product)
</code></pre>
<ul>
<li>Ad ogni iterazione, a <code>product</code> è assegnato un diverso elemento della lista <code>shopping_list</code></li>
<li>Si può usare un ciclo <code>for</code> su qualsiasi sequenza, anche su una <em>stringa</em></li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Funzioni su liste</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="python"><code>def limit_values(values, max_val):
    # procedure: process data, no direct result
    for i in range(len(values)):
        if values[i] &gt; max_val:
            values[i] = max_val

    # the pythonic way: for i, val in enumerate(values): ...

def main ():
    data = [5, 4, 2]
    limit_values(data, 4)
    print(data)

main()
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>List comprehension</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/ninjago-green.jpg">
        
      </figure><ul>
<li>Modo conciso per creare una lista</li>
<li>Ogni elemento: risultato di una operazione su un membro di altro iterabile</li>
<li>Condizione sugli elementi, opzionale</li>
</ul>
<pre class="prettyprint" data-lang="python"><code>squares = [x ** 2 for x in range(12)]
# squares = []
# for x in range(12):
#    squares.append(x ** 2)
</code></pre>
<pre class="prettyprint" data-lang="python"><code>even_nums = [str(x) for x in range(12) if (x % 2) == 0]
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Enumerate</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/repr/child-fingers.png">
        
      </figure><ul>
<li>Accoppia ciascun valore di una sequenza ad un indice crescente</li>
<li>Genera una sequenza di tuple (coppie)</li>
<li>Spesso si usa nei cicli <code>for</code>, quando serve sia il valore che l'indice</li>
</ul>
<pre class="prettyprint" data-lang="python"><code>&gt;&gt;&gt; shopping_list = ["spam", "eggs", "bacon", "ketchup"]
&gt;&gt;&gt; list(enumerate(shopping_list))
[(0, "spam"), (1, "eggs"), (2, "bacon"), (3, "ketchup")]
</code></pre>
<pre class="prettyprint" data-lang="python"><code>shopping_list = ["spam", "eggs", "bacon", "ketchup"]
for i, val in enumerate(shopping_list):
    print(i, val)
</code></pre>
<p>Risultati in lista, solo (!) per visualizzarli <br>
Altrimenti, Python non genera immediatamente i risultati (<em>lazy</em>)</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Zip</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/fun/zip.jpg">
        
      </figure><ul>
<li>Accoppia gli elementi di due sequenze</li>
<li>Genera una sequenza di tuple (coppie)</li>
<li>Il risultato ha la lunghezza della sequenza più breve</li>
</ul>
<pre class="prettyprint" data-lang="python"><code>&gt;&gt;&gt; shopping_list = ["spam", "eggs", "bacon", "ketchup"]
&gt;&gt;&gt; quantities = ["100 g", "6 pc", "200 g", "1 bottle", "too much"]
&gt;&gt;&gt; list(zip(shopping_list, quantities))
[("spam", "100 g"), ("eggs", "6 pc"), ("bacon", "200 g"),
("ketchup", "1 bottle")]
</code></pre>
<p>Risultati in lista, solo (!) per visualizzarli</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Map</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/fun/legomap.png">
        
      </figure><ul>
<li>Prende come parametri una funzione ed una sequenza</li>
<li><em>Funzione di ordine superiore</em></li>
<li>Applica la funzione a ciascuno dei valori</li>
<li>Restituisce la sequenza di risultati</li>
</ul>
<pre class="prettyprint" data-lang="python"><code>&gt;&gt;&gt; from math import sqrt
&gt;&gt;&gt; values = [0, 1, 2, 3, 4]
&gt;&gt;&gt; list(map(sqrt, values))
[0.0, 1.0, 1.4142, 1.7320, 2.0]
</code></pre>
<pre class="prettyprint" data-lang="python"><code>&gt;&gt;&gt; from math import sqrt
&gt;&gt;&gt; list(map(sqrt, range(5)))
[0.0, 1.0, 1.4142, 1.7320, 2.0]
</code></pre>
<p>Risultati in lista, solo (!) per visualizzarli</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Dizionario</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/fun/dictionary.png">
        
      </figure><ul>
<li>A volte chiamato <em>mappa</em> o <em>array associativo</em></li>
<li>Insieme non ordinato di coppie chiave / valore<ul>
<li>Le chiavi sono <em>uniche</em>: come nelle liste fanno da <em>indice</em> per accedere al valore corrispondente</li>
<li>Ma possono essere <code>int</code> o <strong><code>str</code></strong> (o altro tipo immutabile)</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="python"><code>&gt;&gt;&gt; tel = {"john": 4098, "terry": 4139}
&gt;&gt;&gt; tel["john"]
4098
&gt;&gt;&gt; tel["graham"] = 4127
&gt;&gt;&gt; tel
{"graham": 4127, "terry": 4139, "john": 4098}
</code></pre>
<p>Provare anche <code>list(tel)</code> e <code>list(tel.items())</code></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Liste multidimensionali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="python"><code>a = [['A', 'B', 'C', 'D'],
     ['E', 'F', 'G', 'H'],
     ['I', 'L', 'M', 'N']]          # 2D

b = ['A', 'B', 'C', 'D',
     'E', 'F', 'G', 'H',
     'I', 'L', 'M', 'N']            # 1D

i = y * cols + x                    # 2D -&gt; 1D

y = i // cols
x = i % cols                        # 1D -&gt; 2D
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Somma colonne: matrice</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="python"><code>matrix = [[2, 4, 3, 8],
          [9, 3, 2, 7],
          [5, 6, 9, 1]]
rows = len(matrix)
cols = len(matrix[0])

for x in range(cols):
    total = 0
    for y in range(rows):
        val = matrix[y][x]
        total += val
    print("Col #", x, "sums to", total)
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Lista come pseudo-matrice</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="python"><code>matrix = [2, 4, 3, 8,
          9, 3, 2, 7,
          5, 6, 9, 1]
rows = 3  # Cannot be guessed from matrix alone
cols = len(matrix) // rows

for x in range(cols):
    total = 0
    for y in range(rows):
        val = matrix[y * cols + x]   # 2D -&gt; 1D
        total += val
    print("Col #", x, "sums to", total)
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Matrici di dimensioni note</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="python"><code>matrix = [[' ' for x in range(cols)] for y in range(rows)]
# all elements are inited as ' ' -- your need may vary
</code></pre>
<pre class="prettyprint" data-lang="python"><code>matrix = []
for y in range(rows):
    new_row = []
    for x in range(cols):
        new_row.append(' ')
    matrix.append(new_row)
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Flussi di dati</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/fun/magnetic-tape.png">
        
      </figure><ul>
<li><strong>Stream</strong>: astrazione per flussi di informazione<ul>
<li>Lettura o scrittura di informazioni su <em>qualunque</em> dispositivo I/O (<em>file, ma non solo</em>)</li>
</ul>
</li>
<li><strong>File di testo</strong><ul>
<li>Varie codifiche (<em>UTF-8</em> o altro)</li>
<li>Conversioni automatiche, es. <code>"\n"</code> → <code>"\r\n"</code></li>
</ul>
</li>
<li><strong>File binari</strong><ul>
<li>I/O preciso byte a byte, senza nessuna conversione</li>
<li>Qualsiasi file... anche di testo!</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Scrittura su file</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Funzione <code>open</code> per accedere ad un file (di testo)<ul>
<li>Modalità scrittura o lettura: <code>"w"</code>, o <code>"r"</code></li>
</ul>
</li>
<li>Scrittura su file: funzione <code>print</code>, o metodo <code>write</code></li>
<li>Blocco <code>with</code>: chiude il file al termine delle operazioni (anche in caso di errore)</li>
</ul>
<pre class="prettyprint" data-lang="python"><code>with open("some_file.txt", "w") as f1:
    f1.write("First line\n")   # explicit newline
    f1.write("Second line\n")  # continue writing here...

with open("other_file.txt", "w") as f2:
    for x in range(10):
        print(x, x ** 2, file=f2)
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Lettura da file</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="python"><code>with open("some_file.txt", "r") as f1:
    first_line = f1.readline()
    second_line = f1.readline()
    # both strings contain '\n' at the end
    # at end of file, an empty string is read

with open("other_file.txt", "r") as f2:
    whole_text = f2.read()
    # do stg with whole_text

with open("last_file.txt", "r") as f3:
    for line in f3:
        # line contains '\n' at the end
        # strip() removes withespaces at both ends
        print(line.strip(), ':', len(line))
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>I/O su stringhe e console</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Stringhe come stream: <code>io.StringIO</code></li>
<li>Console come stream: <code>sys.stdin</code>, <code>sys.stdout</code>, <code>sys.stderr</code></li>
</ul>
<pre class="prettyprint" data-lang="python"><code>import io, sys

with io.StringIO() as output:
    output.write("First line.\n")
    print("Second line.", file=output)
    # Retrieve stream contents, i.e. "First line.\nSecond line.\n"
    contents = output.getvalue()
    sys.stdout.write(contents)
</code></pre>
<pre class="prettyprint" data-lang="python"><code>for line in sys.stdin:  # CTRL-D (Lin) or CTRL-Z (Win) to end the input
    print(len(line))    # notice '\n' at the end
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Errori da file</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/fun/garbled-tape.png">
        
      </figure><ul>
<li><strong>Eccezioni</strong>: per gestire separatamente i casi inattesi<ul>
<li>Errore all'interno di <code>try</code>: esecuzione interrotta subito</li>
<li>Eseguito il blocco <code>except</code> che gestisce il tipo di errore verificatosi (possibile avere diversi blocchi <code>except</code>)</li>
<li>Il blocco <code>with</code> assicura la chiusura del file</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="python"><code>try:
    with open("other_file.txt", "r") as f:
        whole_text = f.read()
        # do stg with whole_text
except IOError as err:
    print("Oh, my!")
</code></pre></article>
 
</slide>

<slide class="large-image" >
  
    <hgroup>
      <h2>Liste in memoria</h2>
      <h3></h3>
    </hgroup>
    <article >
      <p><img alt="" src="images/fun/python-list-list.svg" /></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Number crunching in Python</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><code>a + b</code> executed as:<ul>
<li><code>a.__add__(b)</code>, or...</li>
<li><code>b.__radd__(a)</code>, if <code>__add__</code> not found</li>
</ul>
</li>
<li>Python is <strong>dynamic</strong><ul>
<li><em>Monkey patching</em></li>
<li>Any method, special or not, can be changed or <em>decorated</em> at any time</li>
<li>Lookup at each call</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Method lookup</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>In general, methods are handled as attributes<ul>
<li>Complex lookup in multiple dictionaries</li>
<li>Starts with <code>a.__getattribute__("something")</code></li>
<li>An <em>instance</em> has its own methods</li>
<li>A <em>class</em> has its own methods</li>
<li>A <em>base class</em> has its own methods</li>
<li>A <em>metaclass</em> may also alter the lookup</li>
</ul>
</li>
<li>“Special methods” are... <em>special</em><ul>
<li>Cannot be set for a single instance</li>
<li>Faster lookup</li>
<li>Still possibly going through multiple dictionaries</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>NumPy</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Modulo NumPy</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Numeric, 1995; NumPy, 2006</li>
<li>Homogeneously typed, n-dimensional array</li>
<li>Efficient algorithms, implemented in Fortran, C/C++, Cython</li>
<li>Functionality comparable to basic MATLAB</li>
<li>Base of SciPy ecosystem: MatPlotLib, SymPy, Pandas, Scikit-learn, Scikit-image</li>
<li>Also used for images in Python bindings of OpenCV</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>NumPy arrays</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="Python"><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.array([2, 3, 4])
&gt;&gt;&gt; a
array([2, 3, 4])
&gt;&gt;&gt; a.dtype
dtype('int64')
</code></pre>
<pre class="prettyprint" data-lang="Python"><code>&gt;&gt;&gt; b = np.array([1.2, 3.5, 5.1])
&gt;&gt;&gt; b.dtype
dtype('float64')
</code></pre>
<pre class="prettyprint" data-lang="Python"><code>c = np.array([[1, 2], [3, 4]], dtype=np.float64)
&gt;&gt;&gt; c
array([[1., 2.],
       [3., 4.]])
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Zeros and ones</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="Python"><code>&gt;&gt;&gt; np.zeros(4)
array([0., 0., 0., 0.])

&gt;&gt;&gt; np.ones((2, 3), dtype=np.int16)  # dtype can also be specified
array([[[ 1, 1, 1],
        [ 1, 1, 1]], dtype=int16)

&gt;&gt;&gt; np.empty((2, 3))  # uninitialized, output may vary
array([[3.73603959e-262, 6.02658058e-154, 6.55490914e-260],
       [5.30498948e-313, 3.14673309e-307, 1.00000000e+000]])

&gt;&gt;&gt; np.random.random((2, 3))
array([[ 0.1528439 ,  0.00263175,  0.21967677],
       [ 0.66804669,  0.84067279,  0.23624629]])
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Range and shape</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="Python"><code>&gt;&gt;&gt; np.arange(10, 30, 5)  # from 10, to 30, step 3
array([10, 15, 20, 25])
</code></pre>
<pre class="prettyprint" data-lang="Python"><code>&gt;&gt;&gt; np.linspace(0, 2, 5)  # 5 numbers from 0 to 2
array([0., 0.5, 1., 1.5, 2.])
</code></pre>
<pre class="prettyprint" data-lang="Python"><code>&gt;&gt;&gt; a = np.arange(15).reshape(3, 5)
&gt;&gt;&gt; a
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])
&gt;&gt;&gt; a.shape
(3, 5)
</code></pre>
<ul>
<li><em>Shape</em>: the number of elements along each axis</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Elementwise operations</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Most operators apply elementwise</li>
<li>A new array holds the result</li>
<li>Some ops act <em>in place</em>: <code>+=</code>, <code>*=</code>, ...</li>
</ul>
<pre class="prettyprint" data-lang="Python"><code>&gt;&gt;&gt; a = np.array([20, 30, 40, 50])
&gt;&gt;&gt; a &lt; 35
array([True, True, False, False])

&gt;&gt;&gt; b = np.arange(4)
&gt;&gt;&gt; b ** 2
array([0, 1, 4, 9])
&gt;&gt;&gt; a - b
array([20, 29, 38, 47])
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Matrix multiplication</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="Python"><code>&gt;&gt;&gt; A = np.array([[1, 1],
...               [0, 1]])
&gt;&gt;&gt; B = np.array([[2, 0],
...               [3, 4]])
&gt;&gt;&gt; A * B                       # elementwise product
array([[2, 0],
       [0, 4]])
&gt;&gt;&gt; A @ B                       # matrix product
array([[5, 4],
       [3, 4]])
&gt;&gt;&gt; A.dot(B)                    # another matrix product
array([[5, 4],
       [3, 4]])
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Aggregate functions</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>By default, array handled as a list of numbers, regardless of shape</li>
</ul>
<pre class="prettyprint" data-lang="Python"><code>&gt;&gt;&gt; b = np.arange(12).reshape(3, 4)
&gt;&gt;&gt; b
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
&gt;&gt;&gt; b.sum()  ## guess also min and max
66
&gt;&gt;&gt; b.sum(axis=0)                            # sum of each column
array([12, 15, 18, 21])
&gt;&gt;&gt;
&gt;&gt;&gt; b.min(axis=1)                            # min of each row
array([0, 4, 8])
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Universal functions</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Math funcs provided as “<em>universal functions</em>” (<em>ufunc</em>)<ul>
<li>Operate elementwise and return an array</li>
<li><code>sin</code>, <code>cos</code>, <code>exp</code> etc.</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="Python"><code>&gt;&gt;&gt; A = np.linspace(0, np.pi/2, 4)
&gt;&gt;&gt; np.sin(A)
array([0., 0.5, 0.8660254, 1.])
</code></pre>
<pre class="prettyprint" data-lang="Python"><code>&gt;&gt;&gt; B = np.arange(3)
&gt;&gt;&gt; B
array([0, 1, 2])
&gt;&gt;&gt; np.exp(B)
array([1., 2.71828183, 7.3890561])
&gt;&gt;&gt; np.sqrt(B)
array([0., 1., 1.41421356])
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Indexing and slicing</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Multidimensional arrays: one index per axis<ul>
<li>Indices are given in a tuple separated by commas</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="Python"><code>&gt;&gt;&gt; def f(y, x): return 10 * y + x
&gt;&gt;&gt; b = np.fromfunction(f, (3, 4), dtype=int)
&gt;&gt;&gt; b
array([[ 0,  1,  2,  3],
       [10, 11, 12, 13],
       [20, 21, 22, 23]])
&gt;&gt;&gt; b[2, 3]
23
&gt;&gt;&gt; b[:, 1]  # each row in the second column of b
array([1, 11, 21])
&gt;&gt;&gt; b[1:3, 0:2]
array([[10, 11],
       [20, 21]])
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Dots</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Dots (<code>...</code>) represent as many colons as needed<ul>
<li>... to produce a complete indexing tuple</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="Python"><code>&gt;&gt;&gt; c = np.array( [[[  0,  1,  2],    # a 3D array
                    [ 10, 12, 13]],
                   [[100,101,102],
                    [110,112,113]]])
&gt;&gt;&gt; c.shape
(2, 2, 3)
&gt;&gt;&gt; c[1,...]  # same as c[1,:,:] or c[1]
array([[100, 101, 102],
       [110, 112, 113]])
&gt;&gt;&gt; c[...,2]  # same as c[:,:,2]
array([[  2,  13],
       [102, 113]])
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Iterating</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Iterating over a multidim. array: wrt the first axis</li>
<li>The <code>flat</code> attribute is an iterator over all the elements</li>
</ul>
<pre class="prettyprint" data-lang="Python"><code>&gt;&gt;&gt; b
array([[ 0,  1,  2,  3],
       [10, 11, 12, 13],
       [20, 21, 22, 23]])
&gt;&gt;&gt; for row in b: print(row)
[0 1 2 3]
[10 11 12 13]
[20 21 22 23]
&gt;&gt;&gt; for val in b.flat: print(val, end=" ")
0 1 2 3 10 11 12 13 20 21 22 23
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Shape manipulation</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="Python"><code>&gt;&gt;&gt; a = np.floor(10 * np.random.random((3, 4)))
&gt;&gt;&gt; a
array([[ 2.,  8.,  0.,  6.],
       [ 4.,  5.,  1.,  1.],
       [ 8.,  9.,  3.,  6.]])
&gt;&gt;&gt; a.ravel()  # returns a new view, flattened
array([ 2.,  8.,  0.,  6.,  4.,  5.,  1.,  1.,  8.,  9.,  3.,  6.])
&gt;&gt;&gt; a.reshape(2, 6)  # new view, different shape
array([[ 2.,  8.,  0.,  6.,  4.,  5.],
       [ 1.,  1.,  8.,  9.,  3.,  6.]])
&gt;&gt;&gt; a.resize(2, 6)  # modifies the array itself
&gt;&gt;&gt; a
array([[ 2.,  8.,  0.,  6.,  4.,  5.],
       [ 1.,  1.,  8.,  9.,  3.,  6.]])
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Transposition</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="Python"><code>&gt;&gt;&gt; a = np.array([[ 2.,  8.,  0.],
                  [ 4.,  5.,  1.]])
&gt;&gt;&gt; a.T  # returns a transposed view, same as a.transpose()
array([[ 2.,  4.],
       [ 8.,  5.],
       [ 0.,  1.]])
&gt;&gt;&gt; a.T.shape
(3, 2)
&gt;&gt;&gt; a.shape
(2, 3)
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Stacking</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="Python"><code>&gt;&gt;&gt; a = np. array([[ 8.,  8.],
                   [ 0.,  0.]])
&gt;&gt;&gt; b = np.array([[ 1.,  8.],
                  [ 0.,  4.]])
&gt;&gt;&gt; np.vstack((a, b))
array([[ 8.,  8.],
       [ 0.,  0.],
       [ 1.,  8.],
       [ 0.,  4.]])
&gt;&gt;&gt; np.hstack((a, b))
array([[ 8.,  8.,  1.,  8.],
       [ 0.,  0.,  0.,  4.]])
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Splitting into several arrays</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><code>hsplit</code> splits an array along its horizontal axis<ul>
<li>Specify the number of equally shaped arrays to return, or...</li>
<li>Specifying the columns where division should occur</li>
</ul>
</li>
<li><code>vsplit</code> works on the vertical axis</li>
</ul>
<pre class="prettyprint" data-lang="Python"><code>&gt;&gt;&gt; a = np.array([[9., 5., 6., 3., 6., 8., 0., 7., 9.],
                  [1., 4., 9., 2., 2., 1., 0., 6., 2.]])
&gt;&gt;&gt; np.hsplit(a, 3)   # Split a into 3
[array([[ 9.,  5.,  6.], [ 1.,  4.,  9.]]),
 array([[ 3.,  6.,  8.], [ 2.,  2.,  1.]]),
 array([[ 0.,  7.,  9.], [ 0.,  6.,  2.]])]
&gt;&gt;&gt; np.hsplit(a, (3, 4))   # Split after 3rd and 4th column
[array([[ 9.,  5.,  6.], [ 1.,  4.,  9.]]),
 array([[ 3.], [ 2.]]),
 array([[ 6.,  8.,  0.,  7.,  9.], [ 2.,  1.,  0.,  6.,  2.]])]
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Linear algebra</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre><code>&gt;&gt;&gt; a = np.array([[1.0, 2.0],
                  [3.0, 4.0]])
&gt;&gt;&gt; b = np.linalg.inv(a)
&gt;&gt;&gt; b
array([[-2. ,  1. ],
       [ 1.5, -0.5]])
&gt;&gt;&gt; a @ b
array([[ 1.,  0. ],
       [ 0.,  1. ]])
&gt;&gt;&gt; u = np.eye(2)  # unit 2x2 matrix; "eye" represents "I"
&gt;&gt;&gt; u
array([[ 1.,  0.],
       [ 0.,  1.]])
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>At the end of the day</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Cost of a ticket for a fair<ul>
<li>4.00€ for adults</li>
<li>1,50€ for children</li>
</ul>
</li>
<li>At the end of the day:<ul>
<li>2200 visitors have entered (b1)</li>
<li>5050€ have been collected (b2)</li>
</ul>
</li>
<li>How many adults (x1) and how many children (x2) have entered?<ul>
<li>Linear system (<code>a @ x = b</code>)</li>
<li>Solve with matrix operations</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Determinant and autovectors</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="Python"><code>&gt;&gt;&gt; a = np.array([[1.0, 2.0],
                  [3.0, 4.0]])
&gt;&gt;&gt; np.linalg.det(a)
-2.0
&gt;&gt;&gt; w, v = np.linalg.eig(a)
&gt;&gt;&gt; w  ## eigenvalues
array([-0.37228132,  5.37228132])
&gt;&gt;&gt; np.linalg.det(w[0] * np.eye(2) - a)  ## det(λI − A) = 0
0.0
&gt;&gt;&gt; v.T  ## eigenvectors, normalized but transposed (!)
array([[-0.82456484,  0.56576746],
       [-0.41597356, -0.90937671]])
&gt;&gt;&gt; sum(v.T[0] ** 2)
1.0
&gt;&gt;&gt; (w[0] * np.eye(2) - a) @ v.T[0]  ## (λI − A)v = 0   
array([ 0.,  0.])
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Solve a linear system</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="Python"><code>&gt;&gt;&gt; a = np.array([[1, 1],
                  [4, 1.5]])
&gt;&gt;&gt; b = np.array([2200, 5050])
&gt;&gt;&gt; np.linalg.inv(a) @ b
array([  700.,  1500.])
&gt;&gt;&gt; np.linalg.solve(a, b)   
array([  700.,  1500.])
</code></pre></article>
 
</slide>


<slide class="thank-you-slide segue nobackground">
  <aside class="gdbar right"><img src="images/logo.png"></aside>
  <article class="flexbox vleft auto-fadein">
    <h2>&lt;Domande?&gt;</h2>
  </article>
  <p class="auto-fadein" data-config-contact>
    Michele Tomaiuolo
    <br>
    Palazzina 1, int. 5708
    <br>
    Ingegneria dell'Informazione, UniPR
    <br>
    <a href="http://sowide.unipr.it/tomamic">sowide.unipr.it/tomamic</a>
  </p>
</slide>

<slide class="backdrop"></slide>

</slides>

</body>
</html>